{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#documentation-index","title":"Documentation Index","text":"<p>Welcome to the Flarelette JWT Kit documentation! Below is a list of available guides and references to help you get started and understand the project.</p>"},{"location":"#guides","title":"Guides","text":"<ul> <li>Setup Guide: Learn how to set up the development environment, install dependencies, and configure the project.</li> <li>Usage Guide: Explore how to use Flarelette JWT Kit for signing, verifying, and managing JWTs.</li> <li>Security Guide: Learn about the security features and requirements of the project.</li> <li>Service Delegation: Understand how to implement zero-trust delegation patterns.</li> <li>Core Concepts: Dive into the architecture and key principles of the toolkit.</li> </ul>"},{"location":"#references","title":"References","text":"<ul> <li>Cloudflare Workers Guide: Specific instructions for deploying and using the toolkit in Cloudflare Workers.</li> <li>Architecture Overview: Explore the architectural design behind the toolkit (provided by archlette).</li> <li>Quick Reference: A handy reference for dependencies and requirements.</li> </ul> <p>For more information, visit the individual files linked above or explore the repository.</p>"},{"location":"#flarelette-jwt-kit","title":"Flarelette JWT Kit","text":"<p>Environment-driven JWT authentication for Cloudflare Workers. Like Starlette, but for the edge.</p> <p>Cross-language JWT toolkit (TypeScript + Python) with identical APIs. Automatically selects HS512 or EdDSA based on environment configuration, loads secrets via Cloudflare bindings, and works across Workers, Node.js, and Python runtimes.</p>"},{"location":"#part-of-the-flarelette-ecosystem","title":"Part of the Flarelette Ecosystem","text":"<p>Flarelette JWT Kit provides the core cryptographic operations for the Flarelette authentication stack. It's framework-neutral by design \u2014 use it directly for low-level JWT operations or through higher-level adapters like <code>flarelette-hono</code> for route guards and middleware integration.</p> <p>Stack layers:</p> <ul> <li>Your services \u2192 Use JWT auth in APIs and UIs</li> <li><code>flarelette</code> / <code>flarelette-hono</code> \u2192 Framework middleware and route guards</li> <li><code>flarelette-jwt-kit</code> (this package) \u2192 Core JWT signing, verification, and key management</li> <li>Platform secrets \u2192 Cloudflare bindings, environment variables</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"TypeScriptPython <pre><code>npm install @chrislyons-dev/flarelette-jwt\n</code></pre> <pre><code>pip install flarelette-jwt\n</code></pre> <p>Cloudflare Workers Only</p> <p>Python package requires Cloudflare Workers runtime (Pyodide)</p>"},{"location":"#basic-example","title":"Basic Example","text":"TypeScriptPython <pre><code>import { sign, verify } from '@chrislyons-dev/flarelette-jwt'\n\n// Sign a token (algorithm chosen from environment)\nconst token = await sign({ sub: 'user123', permissions: ['read:data'] })\n\n// Verify a token\nconst payload = await verify(token)\nif (payload) {\n  console.log('Valid token:', payload.sub)\n}\n</code></pre> <pre><code>from flarelette_jwt import sign, verify\n\n# Sign a token (algorithm chosen from environment)\ntoken = await sign({\"sub\": \"user123\", \"permissions\": [\"read:data\"]})\n\n# Verify a token\npayload = await verify(token)\nif payload:\n    print(f\"Valid token: {payload.get('sub')}\")\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Algorithm auto-detection \u2014 Chooses HS512 or EdDSA based on environment variables</li> <li>Secret-name indirection \u2014 References Cloudflare secret bindings instead of raw values</li> <li>Identical TypeScript + Python APIs \u2014 Same function names and behavior across languages</li> <li>Service bindings for JWKS \u2014 Direct Worker-to-Worker RPC for key distribution</li> <li>Zero-trust delegation \u2014 RFC 8693 actor claims for service-to-service authentication</li> <li>Policy-based authorization \u2014 Fluent API for composing permission and role requirements</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<p>Configuration is entirely environment-driven. No config files required.</p> <p>Common environment variables:</p> <pre><code>JWT_ISS=https://gateway.example.com    # Token issuer\nJWT_AUD=api.example.com                 # Token audience\nJWT_TTL_SECONDS=900                     # Token lifetime (default: 15 min)\nJWT_LEEWAY=90                           # Clock skew tolerance (default: 90 sec)\n</code></pre> <p>HS512 mode (symmetric, shared secret):</p> <pre><code>JWT_SECRET_NAME=MY_JWT_SECRET           # Reference to secret binding\n</code></pre> <p>EdDSA mode (asymmetric, Ed25519):</p> <pre><code># Producer (signs tokens):\nJWT_PRIVATE_JWK_NAME=GATEWAY_PRIVATE_KEY\nJWT_KID=ed25519-2025-01\n\n# Consumer (verifies tokens):\nJWT_PUBLIC_JWK_NAME=GATEWAY_PUBLIC_KEY\n# OR for key rotation:\nJWT_JWKS_SERVICE_NAME=GATEWAY_BINDING\n</code></pre>"},{"location":"#cli-tools","title":"CLI Tools","text":"<p>Generate HS512 secrets:</p> <pre><code>npx flarelette-jwt-secret --len=64 --dotenv\n</code></pre> <p>Generate EdDSA keypairs:</p> <pre><code>npx flarelette-jwt-keygen --kid=ed25519-2025-01\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> Getting Started</li> </ul> <p>Install the packages and create your first JWT token</p> <p> Installation guide</p> <ul> <li> Core Concepts</li> </ul> <p>Learn about algorithms, modes, and architecture patterns</p> <p> Core concepts</p> <ul> <li> Usage Guide</li> </ul> <p>Complete API reference for TypeScript and Python</p> <p> API reference</p> <ul> <li> Security Guide</li> </ul> <p>Cryptographic profiles, key management, and best practices</p> <p> Security guide</p>"},{"location":"#license","title":"License","text":"<p>MIT \u2014 see LICENSE for details.</p>"},{"location":"#security","title":"Security","text":"<p>For security concerns or vulnerability reports, see the Security Guide or open a security issue on GitHub.</p>"},{"location":"cloudflare-workers/","title":"Cloudflare Workers","text":"<p>Deploy Flarelette JWT Kit to Cloudflare Workers with proper secret management and service bindings.</p>"},{"location":"cloudflare-workers/#why-cloudflare-workers","title":"Why Cloudflare Workers?","text":"<ul> <li>Edge computing \u2014 Run authentication logic close to users worldwide</li> <li>Zero cold starts \u2014 Instant response times</li> <li>Integrated secrets \u2014 Built-in secret management with bindings</li> <li>Service bindings \u2014 Direct Worker-to-Worker RPC for JWKS</li> <li>Cost-effective \u2014 Free tier covers most small-to-medium deployments</li> </ul>"},{"location":"cloudflare-workers/#environment-differences","title":"Environment Differences","text":"<p>Workers don't provide standard environment access:</p> <ul> <li>\u274c No <code>process.env</code> (Node.js)</li> <li>\u274c <code>os.environ</code> not auto-populated (Python)</li> <li>\u2705 Environment passed as <code>env</code> object to fetch handler</li> </ul> <p>The kit provides adapters to inject Worker environments.</p>"},{"location":"cloudflare-workers/#quick-start","title":"Quick Start","text":""},{"location":"cloudflare-workers/#typescript-worker","title":"TypeScript Worker","text":"<p>Install:</p> <pre><code>npm install @chrislyons-dev/flarelette-jwt hono\n</code></pre> <p><code>src/index.ts</code>:</p> <pre><code>import { Hono } from 'hono'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\nimport type { WorkerEnv } from '@chrislyons-dev/flarelette-jwt'\n\nconst app = new Hono&lt;{ Bindings: WorkerEnv }&gt;()\n\n// Inject environment\napp.use('*', async (c, next) =&gt; {\n  const jwt = makeKit(c.env)\n  c.set('jwt', jwt)\n  await next()\n})\n\n// Protected route\napp.get('/secure', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  const auth = await jwt.checkAuth(token, jwt.policy().build())\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  return c.json({ data: 'secure', user: auth.sub })\n})\n\nexport default app\n</code></pre> <p><code>wrangler.toml</code>:</p> <pre><code>name = \"my-api\"\nmain = \"src/index.ts\"\ncompatibility_date = \"2024-01-01\"\n\n[vars]\nJWT_SECRET_NAME = \"API_JWT_SECRET\"\nJWT_ISS = \"https://api.example.com\"\nJWT_AUD = \"api.example.com\"\nJWT_TTL_SECONDS = \"900\"\n</code></pre> <p>Deploy:</p> <pre><code># Store secret\nwrangler secret put API_JWT_SECRET\n\n# Deploy\nwrangler deploy\n</code></pre>"},{"location":"cloudflare-workers/#python-worker","title":"Python Worker","text":"<p>Install:</p> <pre><code>pip install flarelette-jwt\n</code></pre> <p><code>src/index.py</code>:</p> <pre><code>from flarelette_jwt.adapters import apply_env_bindings\nfrom flarelette_jwt import check_auth, policy\nfrom js import Response\n\nasync def on_fetch(request, env, ctx):\n    # Inject environment\n    apply_env_bindings(env)\n\n    # Get token\n    auth_header = request.headers.get('Authorization', '')\n    token = auth_header.removeprefix('Bearer ')\n\n    # Verify and authorize\n    auth = await check_auth(token, **policy().build())\n    if not auth:\n        return Response.new('{\"error\": \"Unauthorized\"}', status=401)\n\n    return Response.new(f'{{\"data\": \"secure\", \"user\": \"{auth[\"sub\"]}\"}}')\n</code></pre> <p><code>wrangler.toml</code>:</p> <pre><code>name = \"my-python-api\"\nmain = \"src/index.py\"\ncompatibility_date = \"2024-01-01\"\n\n[vars]\nJWT_SECRET_NAME = \"API_JWT_SECRET\"\nJWT_ISS = \"https://api.example.com\"\nJWT_AUD = \"api.example.com\"\n</code></pre> <p>Deploy:</p> <pre><code>wrangler secret put API_JWT_SECRET\nwrangler deploy\n</code></pre>"},{"location":"cloudflare-workers/#secret-management","title":"Secret Management","text":""},{"location":"cloudflare-workers/#secret-bindings","title":"Secret Bindings","text":"<p>Never commit secrets to wrangler.toml. Use the secret-name indirection pattern:</p> <pre><code>[vars]\nJWT_SECRET_NAME = \"MY_SECRET\"  # \u2705 Reference name, not value\n</code></pre> <pre><code>wrangler secret put MY_SECRET  # \u2705 Store actual secret\n</code></pre>"},{"location":"cloudflare-workers/#multiple-environments","title":"Multiple Environments","text":"<p>Configure different secrets per environment:</p> <p><code>wrangler.toml</code> (base):</p> <pre><code>name = \"my-api\"\nmain = \"src/index.ts\"\n\n[env.dev]\nvars = { JWT_SECRET_NAME = \"JWT_SECRET_DEV\" }\n\n[env.staging]\nvars = { JWT_SECRET_NAME = \"JWT_SECRET_STAGING\" }\n\n[env.production]\nvars = { JWT_SECRET_NAME = \"JWT_SECRET_PROD\" }\n</code></pre> <p>Deploy secrets:</p> <pre><code>wrangler secret put JWT_SECRET_DEV --env dev\nwrangler secret put JWT_SECRET_STAGING --env staging\nwrangler secret put JWT_SECRET_PROD --env production\n</code></pre>"},{"location":"cloudflare-workers/#generating-secrets","title":"Generating Secrets","text":"<p>For HS512:</p> <pre><code>npx flarelette-jwt-secret --len=64 --dotenv\n</code></pre> <p>Copy the output and paste when running <code>wrangler secret put</code>.</p> <p>For EdDSA:</p> <pre><code>npx flarelette-jwt-keygen --kid=ed25519-2025-01 &gt; keys.json\n\n# Store private key\nwrangler secret put GATEWAY_PRIVATE &lt; keys.json\n\n# Store public key (or use service binding)\nwrangler secret put GATEWAY_PUBLIC &lt; keys.json\n</code></pre>"},{"location":"cloudflare-workers/#service-bindings-for-jwks","title":"Service Bindings for JWKS","text":"<p>Service bindings enable direct Worker-to-Worker RPC for key distribution. Recommended for EdDSA deployments.</p>"},{"location":"cloudflare-workers/#benefits","title":"Benefits","text":"<ul> <li>No public endpoint \u2014 JWKS served privately between Workers</li> <li>Lower latency \u2014 Direct RPC, no DNS/TLS overhead</li> <li>Better security \u2014 No internet-facing JWKS endpoint</li> <li>Integrated routing \u2014 Cloudflare handles service discovery</li> </ul>"},{"location":"cloudflare-workers/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   JWT Gateway (Producer)     \u2502\n\u2502                              \u2502\n\u2502   Roles:                     \u2502\n\u2502   1. Signs JWT tokens        \u2502\n\u2502   2. Exposes JWKS endpoint   \u2502\n\u2502      (/.well-known/jwks.json)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                \u2502\n       \u2502 JWT token      \u2502 Service Binding\n       \u2502 (HTTP/auth)    \u2502 (JWKS fetch)\n       \u2502                \u2502\n   \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n   \u2502                        \u2502\n   \u25bc                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Consumer #1     \u2502      \u2502  Consumer #2     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cloudflare-workers/#gateway-setup","title":"Gateway Setup","text":"<p><code>wrangler.toml</code> (gateway):</p> <pre><code>name = \"jwt-gateway\"\nmain = \"src/gateway.ts\"\n\n[vars]\nJWT_PRIVATE_JWK_NAME = \"GATEWAY_PRIVATE\"\nJWT_PUBLIC_JWK_NAME = \"GATEWAY_PUBLIC\"\nJWT_KID = \"ed25519-2025-01\"\nJWT_ISS = \"https://gateway.internal\"\nJWT_AUD = \"internal-api\"\n</code></pre> <p><code>src/gateway.ts</code>:</p> <pre><code>import { Hono } from 'hono'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\n\nconst app = new Hono()\n\napp.use('*', async (c, next) =&gt; {\n  c.set('jwt', makeKit(c.env))\n  await next()\n})\n\n// JWKS endpoint\napp.get('/.well-known/jwks.json', async c =&gt; {\n  const publicJwk = JSON.parse(c.env.GATEWAY_PUBLIC)\n  return c.json({ keys: [publicJwk] })\n})\n\n// Sign tokens\napp.post('/sign', async c =&gt; {\n  const jwt = c.get('jwt')\n  const body = await c.req.json()\n  const token = await jwt.sign(body)\n  return c.json({ token })\n})\n\nexport default app\n</code></pre> <p>Deploy:</p> <pre><code># Generate keypair\nnpx flarelette-jwt-keygen --kid=ed25519-2025-01 &gt; keys.json\n\n# Store private key\nwrangler secret put GATEWAY_PRIVATE --config wrangler.gateway.toml\n# Paste privateJwk from keys.json\n\n# Store public key\nwrangler secret put GATEWAY_PUBLIC --config wrangler.gateway.toml\n# Paste publicJwk from keys.json\n\n# Deploy\nwrangler deploy --config wrangler.gateway.toml\n</code></pre>"},{"location":"cloudflare-workers/#consumer-setup","title":"Consumer Setup","text":"<p><code>wrangler.toml</code> (consumer):</p> <pre><code>name = \"consumer-api\"\nmain = \"src/consumer.ts\"\n\n[vars]\nJWT_JWKS_SERVICE_NAME = \"GATEWAY_BINDING\"\nJWT_ISS = \"https://gateway.internal\"\nJWT_AUD = \"internal-api\"\n\n# Service binding to gateway\n[[services]]\nbinding = \"GATEWAY_BINDING\"\nservice = \"jwt-gateway\"\nenvironment = \"production\"\n</code></pre> <p><code>src/consumer.ts</code>:</p> <pre><code>import { Hono } from 'hono'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\n\nconst app = new Hono()\n\napp.use('*', async (c, next) =&gt; {\n  c.set('jwt', makeKit(c.env)) // Automatically detects service binding\n  await next()\n})\n\napp.get('/secure', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  const auth = await jwt.checkAuth(token, jwt.policy().build())\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  return c.json({ data: 'secure', user: auth.sub })\n})\n\nexport default app\n</code></pre> <p>Deploy:</p> <pre><code>wrangler deploy --config wrangler.consumer.toml\n</code></pre>"},{"location":"cloudflare-workers/#testing-locally","title":"Testing Locally","text":"<p>With Wrangler:</p> <pre><code>wrangler dev\n</code></pre> <p>Set secrets for local development:</p> <pre><code># Create .dev.vars file (gitignored)\nJWT_SECRET_NAME=MY_SECRET\nMY_SECRET=&lt;generated-secret&gt;\nJWT_ISS=https://localhost:8787\nJWT_AUD=localhost\n</code></pre> <p>Test with curl:</p> <pre><code># Get a token (if you have a /sign endpoint)\nTOKEN=$(curl http://localhost:8787/sign -d '{\"sub\":\"test\"}' | jq -r .token)\n\n# Use the token\ncurl -H \"Authorization: Bearer $TOKEN\" http://localhost:8787/secure\n</code></pre>"},{"location":"cloudflare-workers/#performance-considerations","title":"Performance Considerations","text":""},{"location":"cloudflare-workers/#jwks-caching","title":"JWKS Caching","text":"<p>The kit caches JWKS responses for 5 minutes by default. This reduces load on the gateway and improves verification performance.</p> <p>Cache behavior:</p> <ul> <li>First verification: Fetches JWKS from service binding</li> <li>Subsequent verifications: Uses cached keys (5 min)</li> <li>After 5 min: Refetches JWKS</li> </ul> <p>No configuration needed \u2014 caching is automatic.</p>"},{"location":"cloudflare-workers/#token-size","title":"Token Size","text":"<p>Keep tokens under 8KB for optimal performance:</p> <ul> <li>Headers limited to 16KB total</li> <li>Smaller tokens = faster transmission</li> <li>Less parsing overhead</li> </ul> <p>Monitor token size:</p> <pre><code>const token = await sign({ sub: 'user123', permissions: [...] })\nconsole.log(`Token size: ${token.length} bytes`)\n</code></pre>"},{"location":"cloudflare-workers/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"cloudflare-workers/#wrangler-tail","title":"Wrangler Tail","text":"<p>Stream logs from deployed Workers:</p> <pre><code>wrangler tail\n</code></pre>"},{"location":"cloudflare-workers/#log-jwt-verification","title":"Log JWT Verification","text":"<p>Safe logging pattern:</p> <pre><code>const auth = await checkAuth(token, policy().build())\n\nconsole.log({\n  timestamp: new Date().toISOString(),\n  jti: auth?.payload.jti,\n  sub: auth?.sub,\n  success: !!auth,\n})\n</code></pre>"},{"location":"cloudflare-workers/#common-issues","title":"Common Issues","text":"<p>\"JWT secret missing\":</p> <ul> <li>Verify <code>wrangler secret list</code> shows your secret</li> <li>Check <code>JWT_SECRET_NAME</code> matches secret binding name</li> <li>Ensure <code>makeKit(c.env)</code> or <code>apply_env_bindings(env)</code> called</li> </ul> <p>\"EdDSA verification fails\":</p> <ul> <li>For service bindings: Verify <code>[[services]]</code> config correct</li> <li>For inline JWK: Check <code>JWT_PUBLIC_JWK_NAME</code> resolves</li> <li>Verify gateway JWKS endpoint accessible</li> </ul> <p>Mode detection wrong:</p> <ul> <li>Check environment variables with <code>wrangler tail</code></li> <li>Verify no conflicting <code>JWT_*</code> variables</li> <li>Use <code>envMode('consumer')</code> to debug detection</li> </ul>"},{"location":"cloudflare-workers/#references","title":"References","text":"<ul> <li>Cloudflare Workers Docs</li> <li>Wrangler CLI</li> <li>Service Bindings</li> <li>Secrets Management</li> <li>Core Concepts \u2014 Algorithm selection and architecture</li> <li>Security Guide \u2014 Best practices and threat model</li> </ul>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>Understanding how Flarelette JWT Kit makes cryptographic and architectural decisions.</p>"},{"location":"core-concepts/#algorithm-selection","title":"Algorithm Selection","text":"<p>The kit supports exactly two JWT algorithms by design. No configuration required \u2014 the mode is detected automatically from your environment.</p>"},{"location":"core-concepts/#hs512-symmetric","title":"HS512 (Symmetric)","text":"<p>HMAC-SHA-512 with 64-byte shared secrets.</p> <p>Use when:</p> <ul> <li>Producer and consumer both trust each other</li> <li>Both services can securely share a secret</li> <li>Simplest deployment with no key distribution needed</li> </ul> <p>Security properties:</p> <ul> <li>~256-bit security with 64-byte keys</li> <li>Symmetric: same secret signs and verifies</li> <li>Fast signing and verification</li> <li>No key rotation complexity</li> </ul> <p>Environment detection:</p> <pre><code>JWT_SECRET_NAME=MY_SECRET    # Points to secret binding\n# OR\nJWT_SECRET=&lt;base64url-secret&gt;  # Direct secret (not recommended for production)\n</code></pre>"},{"location":"core-concepts/#eddsa-asymmetric","title":"EdDSA (Asymmetric)","text":"<p>Ed25519 digital signatures with JSON Web Keys.</p> <p>Use when:</p> <ul> <li>Public verification required (consumers don't need signing capability)</li> <li>Key rotation needed (multiple active keys via JWKS)</li> <li>One-way trust: gateway signs, services verify</li> <li>Zero-trust architecture with distributed services</li> </ul> <p>Security properties:</p> <ul> <li>Strong asymmetric signatures with 32-byte private keys</li> <li>Public key can be distributed safely</li> <li>Supports key rotation via <code>kid</code> header</li> <li>Slightly slower than HS512 but still fast</li> </ul> <p>Environment detection (producer):</p> <pre><code>JWT_PRIVATE_JWK_NAME=GATEWAY_PRIVATE  # Points to private key binding\nJWT_KID=ed25519-2025-01               # Key ID for rotation\n</code></pre> <p>Environment detection (consumer):</p> <pre><code># Option 1: Inline public key (single key, no rotation)\nJWT_PUBLIC_JWK_NAME=GATEWAY_PUBLIC\n\n# Option 2: Service binding for JWKS (supports rotation)\nJWT_JWKS_SERVICE_NAME=GATEWAY_BINDING\n</code></pre>"},{"location":"core-concepts/#why-only-two-algorithms","title":"Why Only Two Algorithms?","text":"<p>Reduced attack surface: Fewer algorithms means less code to audit and fewer potential vulnerabilities.</p> <p>Simplified key management: HS512 for simple deployments, EdDSA for complex ones. No need to choose between RSA key sizes, ECDSA curves, or other variants.</p> <p>Clear trade-offs: Each algorithm has an obvious use case. No analysis paralysis.</p>"},{"location":"core-concepts/#mode-detection","title":"Mode Detection","text":"<p>The kit automatically detects which algorithm to use based on environment variables. No manual configuration needed.</p> <p>Detection logic:</p> <pre><code>Producer (signing):\n  If JWT_PRIVATE_JWK* exists \u2192 EdDSA mode\n  Otherwise \u2192 HS512 mode\n\nConsumer (verification):\n  If JWT_PUBLIC_JWK* or JWT_JWKS_SERVICE* exists \u2192 EdDSA mode\n  Otherwise \u2192 HS512 mode\n</code></pre> <p>Verification in code:</p> <p>TypeScript:</p> <pre><code>import { envMode } from '@chrislyons-dev/flarelette-jwt'\n\nconst mode = envMode('producer') // or 'consumer'\nconsole.log('Detected mode:', mode) // \"HS512\" or \"EdDSA\"\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import mode\n\ndetected = mode('producer')  # or 'consumer'\nprint(f'Detected mode: {detected}')  # \"HS512\" or \"EdDSA\"\n</code></pre>"},{"location":"core-concepts/#secret-name-indirection","title":"Secret-Name Indirection","text":"<p>Instead of storing secrets directly in environment variables, reference the binding name. This enables proper secret management in Cloudflare Workers.</p>"},{"location":"core-concepts/#the-pattern","title":"The Pattern","text":"<p>Without indirection (insecure):</p> <pre><code># wrangler.toml - DON'T DO THIS\n[vars]\nJWT_SECRET = \"actual-secret-value-exposed\"  # \u274c Secret in version control\n</code></pre> <p>With indirection (secure):</p> <pre><code># wrangler.toml - Safe to commit\n[vars]\nJWT_SECRET_NAME = \"MY_JWT_SECRET\"  # \u2705 References binding, not value\nJWT_ISS = \"https://gateway.example.com\"\n</code></pre> <pre><code># Deploy secret separately\nwrangler secret put MY_JWT_SECRET\n# Paste secret when prompted\n</code></pre>"},{"location":"core-concepts/#how-it-works","title":"How It Works","text":"<p>Resolution order:</p> <ol> <li>Check if <code>JWT_SECRET_NAME</code> is set (e.g., <code>\"MY_JWT_SECRET\"</code>)</li> <li>If set, look up that environment variable (<code>env.MY_JWT_SECRET</code> or <code>os.environ['MY_JWT_SECRET']</code>)</li> <li>If not set, fall back to <code>JWT_SECRET</code> directly</li> </ol> <p>Applies to all secrets:</p> <ul> <li><code>JWT_SECRET_NAME</code> \u2192 <code>JWT_SECRET</code></li> <li><code>JWT_PRIVATE_JWK_NAME</code> \u2192 <code>JWT_PRIVATE_JWK</code></li> <li><code>JWT_PUBLIC_JWK_NAME</code> \u2192 <code>JWT_PUBLIC_JWK</code></li> <li><code>JWT_JWKS_SERVICE_NAME</code> \u2192 <code>JWT_JWKS_SERVICE</code></li> </ul> <p>Benefits:</p> <ul> <li>Secrets never appear in configuration files</li> <li>Same code works across environments (dev/stage/prod use different binding names)</li> <li>Supports Cloudflare's secret rotation workflows</li> </ul>"},{"location":"core-concepts/#environment-injection","title":"Environment Injection","text":"<p>Cloudflare Workers don't expose <code>process.env</code> (Node.js) or populate <code>os.environ</code> (Python) automatically. The kit provides adapters to inject the Worker environment.</p>"},{"location":"core-concepts/#typescript-adapter","title":"TypeScript Adapter","text":"<pre><code>import { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\n\nexport default {\n  async fetch(req, env) {\n    const jwt = makeKit(env) // Injects Worker env globally\n\n    const token = await jwt.sign({ sub: 'user123' })\n    const verified = await jwt.verify(token)\n\n    return new Response(JSON.stringify(verified))\n  },\n}\n</code></pre> <p>What it does:</p> <ol> <li>Extracts string variables and Fetcher service bindings from <code>env</code></li> <li>Stores vars in <code>globalThis.__FLARELETTE_ENV</code></li> <li>Stores services in <code>globalThis.__FLARELETTE_SERVICES</code></li> <li>All kit functions read from these globals</li> </ol>"},{"location":"core-concepts/#python-adapter","title":"Python Adapter","text":"<pre><code>from flarelette_jwt.adapters import apply_env_bindings\nfrom flarelette_jwt import sign, verify\n\nasync def on_fetch(request, env, ctx):\n    apply_env_bindings(env)  # Copy Worker env to os.environ\n\n    token = await sign({\"sub\": \"user123\"})\n    verified = await verify(token)\n\n    return Response.new(str(verified))\n</code></pre> <p>What it does:</p> <ol> <li>Iterates over Worker <code>env</code> mapping</li> <li>Copies string values to <code>os.environ</code></li> <li>All kit functions read from <code>os.environ</code></li> </ol> <p>Note: Python Workers don't support Fetcher service bindings for JWKS. Use inline <code>JWT_PUBLIC_JWK</code> instead.</p>"},{"location":"core-concepts/#token-structure","title":"Token Structure","text":""},{"location":"core-concepts/#header","title":"Header","text":"<pre><code>{\n  \"alg\": \"EdDSA\", // or \"HS512\"\n  \"typ\": \"JWT\",\n  \"kid\": \"ed25519-2025-01\" // Key ID (EdDSA only, for rotation)\n}\n</code></pre>"},{"location":"core-concepts/#payload-standard-claims","title":"Payload (Standard Claims)","text":"<pre><code>{\n  \"iss\": \"https://gateway.example.com\", // Issuer\n  \"aud\": \"api.example.com\", // Audience\n  \"sub\": \"user123\", // Subject (user ID)\n  \"iat\": 1704067200, // Issued at (Unix timestamp)\n  \"exp\": 1704068100, // Expiration (Unix timestamp)\n  \"jti\": \"a1b2c3d4\" // JWT ID (optional, for replay prevention)\n}\n</code></pre>"},{"location":"core-concepts/#payload-custom-claims","title":"Payload (Custom Claims)","text":"<pre><code>{\n  // Standard claims above, plus:\n  \"permissions\": [\"read:data\", \"write:data\"],\n  \"roles\": [\"user\", \"editor\"],\n  \"email\": \"user@example.com\",\n  \"tid\": \"tenant-123\", // Tenant ID (multi-tenant apps)\n  \"act\": {\n    // Actor claim (service delegation, RFC 8693)\n    \"sub\": \"gateway-service\"\n  }\n}\n</code></pre>"},{"location":"core-concepts/#verification-process","title":"Verification Process","text":"<p>When you call <code>verify()</code> or <code>checkAuth()</code>, the kit performs these checks in order:</p> <ol> <li>Signature verification \u2014 Validates cryptographic signature using detected algorithm</li> <li>Issuer check \u2014 <code>iss</code> claim must match <code>JWT_ISS</code></li> <li>Audience check \u2014 <code>aud</code> claim must match <code>JWT_AUD</code> (or be in list if multiple)</li> <li>Expiration check \u2014 Token must not be expired (<code>exp</code> &gt; current time - leeway)</li> <li>Not before check \u2014 If <code>nbf</code> claim present, token must be valid (<code>nbf</code> &lt; current time + leeway)</li> <li>Authorization checks \u2014 If using <code>checkAuth()</code>, validates permissions and roles</li> </ol> <p>Fail-silent behavior:</p> <ul> <li>Returns <code>null</code> (TypeScript) or <code>None</code> (Python) on any verification failure</li> <li>Never throws exceptions</li> <li>Simplifies error handling in request handlers</li> </ul> <p>Clock skew tolerance:</p> <ul> <li>Default 90 seconds leeway via <code>JWT_LEEWAY</code></li> <li>Applied to <code>exp</code>, <code>nbf</code>, and <code>iat</code> checks</li> <li>Accounts for time sync differences between services</li> </ul>"},{"location":"core-concepts/#cross-language-parity","title":"Cross-Language Parity","text":"<p>TypeScript and Python implementations are kept in sync:</p> Feature TypeScript Python HS512 signing \u2705 \u2705 HS512 verification \u2705 \u2705 EdDSA signing \u2705 \u274c (use Node gateway) EdDSA verification \u2705 \u2705 (inline JWK only) JWKS fetch \u2705 \u274c (inline JWK only) Service bindings \u2705 \u274c Secret-name indirection \u2705 \u2705 Policy builder \u2705 \u2705 CLI tools \u2705 \u2705 <p>Why Python limitations?</p> <ul> <li>EdDSA signing: WebCrypto API in Pyodide doesn't support Ed25519 private key operations</li> <li>JWKS fetch: No Fetcher service binding support in Workers Python runtime</li> <li>Recommended pattern: Use Node.js gateway for EdDSA signing, Python workers for verification</li> </ul>"},{"location":"core-concepts/#architecture-patterns","title":"Architecture Patterns","text":""},{"location":"core-concepts/#pattern-1-hs512-internal-services","title":"Pattern 1: HS512 Internal Services","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  HS512    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Service A  \u2502 \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502  Service B  \u2502\n\u2502  (signs)    \u2502  shared   \u2502  (verifies) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  secret   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use when: All services trust each other and can share a secret.</p>"},{"location":"core-concepts/#pattern-2-eddsa-gateway-services","title":"Pattern 2: EdDSA Gateway + Services","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  EdDSA    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Gateway    \u2502  signed   \u2502  Service 1  \u2502\n\u2502  (Node.js)  \u2502  tokens   \u2502  (TS/Py)    \u2502\n\u2502             \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502             \u2502\n\u2502  Signs with \u2502           \u2502  Verifies   \u2502\n\u2502  private    \u2502           \u2502  with       \u2502\n\u2502  key        \u2502           \u2502  public key \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                         \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2193\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502  Service 2  \u2502\n              \u2502  (TS/Py)    \u2502\n              \u2502             \u2502\n              \u2502  Verifies   \u2502\n              \u2502  with       \u2502\n              \u2502  public key \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use when: Gateway handles external auth, internal services only verify.</p>"},{"location":"core-concepts/#pattern-3-service-binding-jwks","title":"Pattern 3: Service Binding JWKS","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   JWT Gateway (Producer)     \u2502\n\u2502                              \u2502\n\u2502   - Signs tokens             \u2502\n\u2502   - Exposes JWKS endpoint    \u2502\n\u2502      (/.well-known/jwks.json)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                \u2502\n       \u2502 JWT token      \u2502 Service Binding\n       \u2502 (HTTP/auth)    \u2502 (JWKS fetch)\n       \u2502                \u2502\n   \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n   \u2502                        \u2502\n   \u25bc                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Consumer #1     \u2502      \u2502  Consumer #2     \u2502\n\u2502  (Worker)        \u2502      \u2502  (Worker)        \u2502\n\u2502                  \u2502      \u2502                  \u2502\n\u2502  - Receives JWT  \u2502      \u2502  - Receives JWT  \u2502\n\u2502  - Fetches JWKS  \u2502      \u2502  - Fetches JWKS  \u2502\n\u2502  - Verifies      \u2502      \u2502  - Verifies      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use when: Key rotation needed, multiple active keys, or zero-trust architecture.</p>"},{"location":"core-concepts/#next-topics","title":"Next Topics","text":"<ul> <li>Usage Guide \u2014 Complete API reference</li> <li>Service Delegation \u2014 RFC 8693 actor claims</li> <li>Cloudflare Workers \u2014 Workers deployment guide</li> <li>Security Guide \u2014 Cryptographic profiles and best practices</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide walks you through installing Flarelette JWT Kit and creating your first authenticated token.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#typescriptjavascript","title":"TypeScript/JavaScript","text":"<pre><code>npm install @chrislyons-dev/flarelette-jwt\n</code></pre> <p>Requirements:</p> <ul> <li>Node.js 18+ or Cloudflare Workers runtime</li> <li>TypeScript 5.0+ (if using TypeScript)</li> </ul>"},{"location":"getting-started/#python","title":"Python","text":"<pre><code>pip install flarelette-jwt\n</code></pre> <p>Requirements:</p> <ul> <li>Cloudflare Workers Python runtime (Pyodide)</li> <li>Python 3.11+ (Pyodide-based)</li> </ul> <p>Cloudflare Workers Only</p> <p>The Python package is designed exclusively for Cloudflare Workers Python runtime (Pyodide). It uses the <code>js</code> module to access WebCrypto APIs, which is not available in standard Python environments.</p>"},{"location":"getting-started/#your-first-token","title":"Your First Token","text":""},{"location":"getting-started/#step-1-configure-environment","title":"Step 1: Configure Environment","text":"<p>Create a <code>.env</code> file or configure your runtime environment:</p> <pre><code># Required configuration\nJWT_ISS=https://your-service.example.com\nJWT_AUD=your-api-audience\nJWT_SECRET_NAME=MY_JWT_SECRET\n\n# Optional (shown with defaults)\nJWT_TTL_SECONDS=900  # 15 minutes\nJWT_LEEWAY=90        # 90 seconds clock skew tolerance\n</code></pre>"},{"location":"getting-started/#step-2-generate-a-secret","title":"Step 2: Generate a Secret","text":"<p>For development:</p> <pre><code>npx flarelette-jwt-secret --len=64 --dotenv\n</code></pre> <p>This outputs a secure base64url-encoded secret:</p> <pre><code>JWT_SECRET=&lt;64-byte-base64url-string&gt;\n</code></pre> <p>For production (Cloudflare Workers):</p> <pre><code># Store secret in Cloudflare\nwrangler secret put MY_JWT_SECRET\n\n# Configure wrangler.toml to reference it\n[vars]\nJWT_SECRET_NAME = \"MY_JWT_SECRET\"\nJWT_ISS = \"https://gateway.example.com\"\nJWT_AUD = \"api.example.com\"\n</code></pre>"},{"location":"getting-started/#step-3-sign-your-first-token","title":"Step 3: Sign Your First Token","text":"<p>TypeScript:</p> <pre><code>import { sign, verify } from '@chrislyons-dev/flarelette-jwt'\n\nasync function example() {\n  // Create a token\n  const token = await sign({\n    sub: 'user123',\n    permissions: ['read:data', 'write:data'],\n    roles: ['user'],\n  })\n\n  console.log('Token:', token)\n\n  // Verify the token\n  const payload = await verify(token)\n  if (payload) {\n    console.log('Valid token for user:', payload.sub)\n    console.log('Permissions:', payload.permissions)\n  } else {\n    console.log('Invalid token')\n  }\n}\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import sign, verify\nimport asyncio\n\nasync def example():\n    # Create a token\n    token = await sign({\n        \"sub\": \"user123\",\n        \"permissions\": [\"read:data\", \"write:data\"],\n        \"roles\": [\"user\"]\n    })\n\n    print(f\"Token: {token}\")\n\n    # Verify the token\n    payload = await verify(token)\n    if payload:\n        print(f\"Valid token for user: {payload.get('sub')}\")\n        print(f\"Permissions: {payload.get('permissions')}\")\n    else:\n        print(\"Invalid token\")\n\nasyncio.run(example())\n</code></pre>"},{"location":"getting-started/#using-high-level-helpers","title":"Using High-Level Helpers","text":"<p>The kit provides high-level functions for common patterns.</p>"},{"location":"getting-started/#creating-tokens-with-options","title":"Creating Tokens with Options","text":"<p>TypeScript:</p> <pre><code>import { createToken } from '@chrislyons-dev/flarelette-jwt'\n\nconst token = await createToken(\n  {\n    sub: 'user123',\n    permissions: ['read:data'],\n  },\n  {\n    ttlSeconds: 600, // Override default TTL\n    aud: 'special-api', // Override default audience\n  }\n)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import create_token\n\ntoken = await create_token(\n    {\"sub\": \"user123\", \"permissions\": [\"read:data\"]},\n    ttl_seconds=600,  # Override default TTL\n    aud=\"special-api\"  # Override default audience\n)\n</code></pre>"},{"location":"getting-started/#authorization-with-policies","title":"Authorization with Policies","text":"<p>TypeScript:</p> <pre><code>import { checkAuth, policy } from '@chrislyons-dev/flarelette-jwt'\n\nconst authPolicy = policy()\n  .needAll('read:data', 'write:data')\n  .rolesAny('admin', 'editor')\n  .build()\n\nconst auth = await checkAuth(token, authPolicy)\nif (auth) {\n  console.log('Authorized user:', auth.sub)\n  console.log('Permissions:', auth.permissions)\n} else {\n  console.log('Authorization failed')\n}\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import check_auth, policy\n\nauth_policy = (\n    policy()\n    .need_all('read:data', 'write:data')\n    .roles_any('admin', 'editor')\n    .build()\n)\n\nauth = await check_auth(token, **auth_policy)\nif auth:\n    print(f\"Authorized user: {auth['sub']}\")\n    print(f\"Permissions: {auth['permissions']}\")\nelse:\n    print(\"Authorization failed\")\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts \u2014 Understand algorithms, modes, and architecture</li> <li>Usage Guide \u2014 Explore the complete API</li> <li>Cloudflare Workers \u2014 Deploy to Workers with proper secret management</li> <li>Security Guide \u2014 Learn cryptographic profiles and best practices</li> </ul>"},{"location":"getting-started/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/#jwt-secret-missing-error","title":"\"JWT secret missing\" Error","text":"<p>Cause: Environment variable not set or secret-name indirection not resolving.</p> <p>Solution:</p> <ol> <li>Verify <code>JWT_SECRET_NAME</code> points to an actual environment variable</li> <li>For Workers, ensure you ran <code>wrangler secret put &lt;NAME&gt;</code></li> <li>Check your wrangler.toml has the correct <code>JWT_SECRET_NAME</code> value</li> </ol>"},{"location":"getting-started/#algorithm-mismatch","title":"Algorithm Mismatch","text":"<p>Cause: Token was signed with one algorithm but consumer expects another.</p> <p>Solution:</p> <ul> <li>Verify both producer and consumer use the same environment configuration</li> <li>Check which mode is active using the <code>envMode()</code> function (TypeScript) or <code>mode()</code> function (Python)</li> <li>See Core Concepts for mode detection rules</li> </ul>"},{"location":"getting-started/#token-always-returns-null","title":"Token Always Returns Null","text":"<p>Cause: Verification failure due to mismatched claims or expired token.</p> <p>Solution:</p> <ol> <li>Check <code>JWT_ISS</code> and <code>JWT_AUD</code> match between producer and consumer</li> <li>Verify token hasn't expired (default 15 min TTL)</li> <li>Use <code>parse()</code> to inspect token contents without verification:    <pre><code>import { parse } from '@chrislyons-dev/flarelette-jwt'\nconst { header, payload } = parse(token)\nconsole.log('Algorithm:', header.alg)\nconsole.log('Issuer:', payload.iss)\nconsole.log('Expires:', new Date(payload.exp * 1000))\n</code></pre></li> </ol>"},{"location":"security-guide/","title":"Security Guide","text":"<p>Comprehensive security baseline for Flarelette JWT Kit across HS512 and EdDSA profiles.</p>"},{"location":"security-guide/#cryptographic-profiles","title":"Cryptographic Profiles","text":"<p>The kit supports exactly two JWT algorithms by design. Each has specific security properties and use cases.</p>"},{"location":"security-guide/#hs512-symmetric","title":"HS512 (Symmetric)","text":"Property Value Algorithm HMAC-SHA-512 Key material 64-byte base64url secret Security level ~256-bit Key distribution Shared secret between producer and consumer Use case Internal trusted services with shared secret <p>Security properties:</p> <ul> <li>Fast signing and verification</li> <li>Simple key management (single shared secret)</li> <li>No public key distribution needed</li> <li>Requires mutual trust between producer and consumer</li> </ul> <p>When to use:</p> <ul> <li>Both producer and consumer are trusted services</li> <li>Services can securely share a secret</li> <li>Simplest deployment with no key rotation requirements</li> </ul>"},{"location":"security-guide/#eddsa-ed25519","title":"EdDSA (Ed25519)","text":"Property Value Algorithm Ed25519 digital signature Key material 32-byte private key + public key (JSON Web Keys) Security level ~128-bit (quantum-safe path exists) Key distribution Public key distributed via JWKS or inline Use case One-way trust, public verification, key rotation <p>Security properties:</p> <ul> <li>Asymmetric: private key signs, public key verifies</li> <li>Public key can be distributed safely</li> <li>Supports key rotation via <code>kid</code> header</li> <li>Resistant to timing attacks</li> </ul> <p>When to use:</p> <ul> <li>Gateway signs, multiple services verify</li> <li>Key rotation required (multiple active keys)</li> <li>Zero-trust architecture with distributed services</li> <li>Public verification needed (consumers don't need signing capability)</li> </ul>"},{"location":"security-guide/#key-generation","title":"Key Generation","text":""},{"location":"security-guide/#hs512-secrets","title":"HS512 Secrets","text":"<p>Requirements:</p> <ul> <li>Minimum 64 bytes (512 bits)</li> <li>Cryptographically random</li> <li>Base64url-encoded for safe storage</li> </ul> <p>Generate with CLI:</p> <pre><code>npx flarelette-jwt-secret --len=64 --dotenv\n</code></pre> <p>Output:</p> <pre><code>JWT_SECRET=&lt;64-byte-base64url-string&gt;\n</code></pre> <p>Generate programmatically:</p> <p>TypeScript:</p> <pre><code>import { generateSecret } from '@chrislyons-dev/flarelette-jwt'\n\nconst secret = generateSecret(64)\nconsole.log(`JWT_SECRET=${secret}`)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import generate_secret\n\nsecret = generate_secret(64)\nprint(f\"JWT_SECRET={secret}\")\n</code></pre>"},{"location":"security-guide/#eddsa-keypairs","title":"EdDSA Keypairs","text":"<p>Generate with CLI:</p> <pre><code>npx flarelette-jwt-keygen --kid=ed25519-2025-01\n</code></pre> <p>Output:</p> <pre><code>{\n  \"kid\": \"ed25519-2025-01\",\n  \"publicJwk\": {\n    \"kty\": \"OKP\",\n    \"crv\": \"Ed25519\",\n    \"x\": \"&lt;base64url-public-key&gt;\",\n    \"kid\": \"ed25519-2025-01\"\n  },\n  \"privateJwk\": {\n    \"kty\": \"OKP\",\n    \"crv\": \"Ed25519\",\n    \"x\": \"&lt;base64url-public-key&gt;\",\n    \"d\": \"&lt;base64url-private-key&gt;\",\n    \"kid\": \"ed25519-2025-01\"\n  }\n}\n</code></pre> <p>Best practice for production:</p> <ul> <li>Generate keys during deployment CI (ephemeral keys no human ever sees)</li> <li>Store private key in secret binding immediately</li> <li>Distribute public key via JWKS or environment binding</li> </ul>"},{"location":"security-guide/#secret-storage","title":"Secret Storage","text":""},{"location":"security-guide/#never-commit-secrets","title":"Never Commit Secrets","text":"<p>\u274c Never do this:</p> <pre><code># wrangler.toml - DON'T COMMIT THIS\n[vars]\nJWT_SECRET = \"actual-secret-value\"  # \u274c Exposed in version control\n</code></pre> <p>\u2705 Use secret-name indirection:</p> <pre><code># wrangler.toml - Safe to commit\n[vars]\nJWT_SECRET_NAME = \"MY_JWT_SECRET\"  # References binding, not value\nJWT_ISS = \"https://gateway.example.com\"\nJWT_AUD = \"api.example.com\"\n</code></pre> <pre><code># Deploy secret separately\nwrangler secret put MY_JWT_SECRET\n# Paste secret when prompted\n</code></pre>"},{"location":"security-guide/#environment-scoping","title":"Environment Scoping","text":"<p>Use different secret bindings for each environment.</p> <pre><code># wrangler.dev.toml\n[vars]\nJWT_SECRET_NAME = \"JWT_SECRET_DEV\"\n\n# wrangler.staging.toml\n[vars]\nJWT_SECRET_NAME = \"JWT_SECRET_STAGING\"\n\n# wrangler.production.toml\n[vars]\nJWT_SECRET_NAME = \"JWT_SECRET_PROD\"\n</code></pre> <p>Deploy secrets to each environment:</p> <pre><code>wrangler secret put JWT_SECRET_DEV --env dev\nwrangler secret put JWT_SECRET_STAGING --env staging\nwrangler secret put JWT_SECRET_PROD --env production\n</code></pre>"},{"location":"security-guide/#eddsa-key-distribution","title":"EdDSA Key Distribution","text":"<p>Production (Service Binding - Recommended):</p> <ol> <li>Deploy JWT gateway with JWKS endpoint and public key</li> <li>Configure consumer workers with service binding</li> <li>Keys fetched via direct Worker-to-Worker RPC (private, low-latency)</li> </ol> <p>Benefits:</p> <ul> <li>No public HTTP endpoint required</li> <li>Lower latency (direct RPC, no DNS/TLS overhead)</li> <li>Better security (private Worker communication only)</li> <li>Integrated with Cloudflare routing</li> </ul> <p>Development/Offline (Inline JWK):</p> <ol> <li>Deploy public key directly to consumer environment</li> <li>Configure <code>JWT_PUBLIC_JWK_NAME</code> pointing to secret binding</li> <li>Note: Requires redeployment for key rotation, no JWKS support</li> </ol> <p>Optional: Thumbprint Pinning</p> <p>For additional security, pin trusted key thumbprints:</p> <pre><code>JWT_ALLOWED_THUMBPRINTS=abc123def456,789ghi012jkl\n</code></pre> <p>Only keys matching these thumbprints will be accepted for verification.</p>"},{"location":"security-guide/#key-rotation","title":"Key Rotation","text":""},{"location":"security-guide/#hs512-rotation","title":"HS512 Rotation","text":"<p>Process:</p> <ol> <li>Generate new secret</li> <li>Deploy new secret to producer and all consumers</li> <li>Start signing with new secret</li> <li>Wait for maximum token TTL (default 15 min)</li> <li>Remove old secret</li> </ol> <p>Downtime: None (if consumers support both secrets during transition)</p> <p>Frequency: Rotate at least every 90 days or immediately on suspicion of compromise.</p>"},{"location":"security-guide/#eddsa-rotation","title":"EdDSA Rotation","text":"<p>Process:</p> <ol> <li>Generate new keypair with new <code>kid</code></li> <li>Publish new JWKS including both old and new public keys</li> <li>Update producer to sign with new key</li> <li>Allow dual verification during TTL window</li> <li>After TTL expires, remove old key from JWKS</li> </ol> <p>Example:</p> <p>Before rotation (JWKS):</p> <pre><code>{\n  \"keys\": [\n    { \"kid\": \"ed25519-2025-01\", \"kty\": \"OKP\", ... }\n  ]\n}\n</code></pre> <p>During rotation (both keys active):</p> <pre><code>{\n  \"keys\": [\n    { \"kid\": \"ed25519-2025-01\", \"kty\": \"OKP\", ... },\n    { \"kid\": \"ed25519-2025-02\", \"kty\": \"OKP\", ... }\n  ]\n}\n</code></pre> <p>After rotation (old key removed):</p> <pre><code>{\n  \"keys\": [\n    { \"kid\": \"ed25519-2025-02\", \"kty\": \"OKP\", ... }\n  ]\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Zero downtime</li> <li>Consumers automatically fetch new keys</li> <li>No consumer redeployment needed</li> <li>Full audit trail via <code>kid</code> header</li> </ul>"},{"location":"security-guide/#token-issuance","title":"Token Issuance","text":""},{"location":"security-guide/#automatic-claims","title":"Automatic Claims","text":"<p>These claims are automatically populated:</p> <ul> <li><code>iss</code> \u2014 Token issuer (from <code>JWT_ISS</code>)</li> <li><code>aud</code> \u2014 Token audience (from <code>JWT_AUD</code>)</li> <li><code>iat</code> \u2014 Issued at (current timestamp)</li> <li><code>exp</code> \u2014 Expiration (current timestamp + TTL)</li> <li><code>jti</code> \u2014 JWT ID (optional, for replay prevention)</li> </ul>"},{"location":"security-guide/#manual-claims","title":"Manual Claims","text":"<p>Add custom claims with user identity and authorization:</p> <pre><code>const token = await sign({\n  sub: 'user123', // Subject (user ID)\n  permissions: ['read:data'], // Permission strings\n  roles: ['user', 'editor'], // Role strings\n  email: 'user@example.com', // OIDC standard claim\n  tid: 'tenant-123', // Multi-tenant apps\n})\n</code></pre>"},{"location":"security-guide/#minimal-claims-principle","title":"Minimal Claims Principle","text":"<p>Only include claims necessary for authorization decisions. Never include:</p> <ul> <li>Passwords or password hashes</li> <li>Credit card numbers or payment information</li> <li>Social security numbers or national IDs</li> <li>Full medical records</li> <li>Large datasets (keep tokens &lt; 8KB)</li> </ul> <p>Why: Tokens are transmitted with every request and logged in various places. Treat them as semi-public.</p>"},{"location":"security-guide/#token-lifetime","title":"Token Lifetime","text":"<p>Default: 900 seconds (15 minutes)</p> <p>Recommendation:</p> <ul> <li>External-facing APIs: 15-60 minutes</li> <li>Internal service tokens: 5-15 minutes</li> <li>Delegated tokens: 5 minutes</li> </ul> <p>Configure via:</p> <pre><code>JWT_TTL_SECONDS=300  # 5 minutes\n</code></pre> <p>Or override per-token:</p> <pre><code>const token = await createToken({ sub: 'user123' }, { ttlSeconds: 300 })\n</code></pre>"},{"location":"security-guide/#token-validation","title":"Token Validation","text":""},{"location":"security-guide/#automatic-verification","title":"Automatic Verification","text":"<p>When calling <code>verify()</code> or <code>checkAuth()</code>, these checks are performed:</p> <ol> <li>Signature verification \u2014 Cryptographic signature valid for detected algorithm</li> <li>Issuer check \u2014 <code>iss</code> matches <code>JWT_ISS</code></li> <li>Audience check \u2014 <code>aud</code> matches <code>JWT_AUD</code></li> <li>Expiration check \u2014 Token not expired (<code>exp</code> &gt; now - leeway)</li> <li>Not before check \u2014 If <code>nbf</code> present, token is valid (<code>nbf</code> &lt; now + leeway)</li> </ol>"},{"location":"security-guide/#clock-skew-tolerance","title":"Clock Skew Tolerance","text":"<p>Default leeway: 90 seconds</p> <p>Accounts for:</p> <ul> <li>Time sync differences between services</li> <li>Network latency</li> <li>Clock drift</li> </ul> <p>Configure via:</p> <pre><code>JWT_LEEWAY=120  # 2 minutes\n</code></pre> <p>Or override per-verification:</p> <pre><code>const payload = await verify(token, { leeway: 120 })\n</code></pre> <p>Security consideration: Keep leeway \u2264 90 seconds to avoid excessive expiry drift.</p>"},{"location":"security-guide/#algorithm-verification","title":"Algorithm Verification","text":"<p>The kit rejects tokens with unexpected <code>alg</code> headers. This prevents algorithm substitution attacks.</p> <p>Example: If environment detects HS512 mode, EdDSA tokens are rejected (and vice versa).</p>"},{"location":"security-guide/#replay-prevention-optional","title":"Replay Prevention (Optional)","text":"<p>For APIs requiring replay prevention, store <code>jti</code> in a short-TTL key-value store.</p> <pre><code>import { checkAuth } from '@chrislyons-dev/flarelette-jwt'\n\nconst auth = await checkAuth(token, policy().build())\nif (!auth) {\n  return new Response('Unauthorized', { status: 401 })\n}\n\n// Check if token was already used\nconst jti = auth.payload.jti\nif (await kv.get(`used:${jti}`)) {\n  return new Response('Token already used', { status: 403 })\n}\n\n// Mark token as used (expires with token TTL)\nawait kv.put(`used:${jti}`, 'true', {\n  expirationTtl: auth.payload.exp - Date.now() / 1000,\n})\n</code></pre>"},{"location":"security-guide/#transport-security","title":"Transport Security","text":""},{"location":"security-guide/#tls-everywhere","title":"TLS Everywhere","text":"<p>Never transmit tokens over plaintext HTTP. Always use HTTPS/TLS for:</p> <ul> <li>External API requests</li> <li>Internal service-to-service communication</li> <li>JWKS endpoint (if not using service bindings)</li> </ul>"},{"location":"security-guide/#authorization-header","title":"Authorization Header","text":"<p>\u2705 Correct:</p> <pre><code>Authorization: Bearer &lt;jwt-token&gt;\n</code></pre> <p>\u274c Never:</p> <ul> <li>Query parameters: <code>?token=&lt;jwt&gt;</code> (logged in access logs, proxy logs, browser history)</li> <li>Request body: <code>{\"token\": \"&lt;jwt&gt;\"}</code> (unnecessarily verbose)</li> <li>Cookies: (unless specifically designed for cookie-based auth with CSRF protection)</li> </ul>"},{"location":"security-guide/#logging-practices","title":"Logging Practices","text":"<p>Never log entire tokens. Log only non-sensitive parts:</p> <p>\u2705 Safe to log:</p> <pre><code>console.log({\n  jti: payload.jti, // JWT ID\n  sub: payload.sub, // Subject (user ID)\n  iss: payload.iss, // Issuer\n  aud: payload.aud, // Audience\n  exp: payload.exp, // Expiration\n  action: 'read:data', // Action performed\n})\n</code></pre> <p>\u274c Never log:</p> <pre><code>console.log(`Token: ${token}`) // \u274c Full token exposed\nconsole.log(`Bearer ${token}`) // \u274c Full token exposed\n</code></pre> <p>Redact in APM and telemetry:</p> <ul> <li>Configure log redaction rules for <code>Authorization</code> headers</li> <li>Use allowlists for logged fields (never log entire objects containing tokens)</li> </ul>"},{"location":"security-guide/#time-and-clock-skew","title":"Time and Clock Skew","text":""},{"location":"security-guide/#time-synchronization","title":"Time Synchronization","text":"<p>Depend on platform time sync:</p> <ul> <li>Cloudflare Workers: NTP-backed, reliable</li> <li>Node.js/Python: Ensure host has NTP configured</li> </ul>"},{"location":"security-guide/#leeway-configuration","title":"Leeway Configuration","text":"<p>Keep leeway \u2264 90 seconds to prevent excessive expiry drift while accounting for:</p> <ul> <li>Network latency (typically &lt; 1 second)</li> <li>Clock drift (NTP keeps this minimal)</li> <li>Service restart time skew</li> </ul> <p>Balance:</p> <ul> <li>Too low: Legitimate tokens rejected due to minor clock differences</li> <li>Too high: Expired tokens accepted for too long</li> </ul>"},{"location":"security-guide/#dependency-security","title":"Dependency Security","text":""},{"location":"security-guide/#typescript-dependencies","title":"TypeScript Dependencies","text":"<ul> <li><code>jose</code> library: Pinned version for cryptographic operations</li> <li>Review changelogs before upgrading</li> <li>Run <code>npm audit</code> regularly</li> </ul>"},{"location":"security-guide/#python-dependencies","title":"Python Dependencies","text":"<ul> <li>Zero external crypto dependencies \u2014 uses WebCrypto API directly</li> <li>Stdlib only \u2014 reduces supply chain risk</li> </ul>"},{"location":"security-guide/#lockfile-management","title":"Lockfile Management","text":"<p>Commit lockfiles:</p> <ul> <li><code>package-lock.json</code> (npm)</li> <li><code>yarn.lock</code> (Yarn)</li> <li><code>pyproject.toml</code> (Python)</li> </ul> <p>Benefits:</p> <ul> <li>Reproducible builds</li> <li>Security scanning can detect vulnerable versions</li> <li>Prevents unexpected dependency changes</li> </ul>"},{"location":"security-guide/#automated-updates","title":"Automated Updates","text":"<p>Use Dependabot or Renovate for automated dependency updates:</p> <pre><code># .github/dependabot.yml\nversion: 2\nupdates:\n  - package-ecosystem: 'npm'\n    directory: '/'\n    schedule:\n      interval: 'weekly'\n\n  - package-ecosystem: 'pip'\n    directory: '/packages/flarelette-jwt-py'\n    schedule:\n      interval: 'weekly'\n</code></pre>"},{"location":"security-guide/#testing-and-cicd","title":"Testing and CI/CD","text":""},{"location":"security-guide/#required-test-coverage","title":"Required Test Coverage","text":"<p>Unit tests must cover:</p> <ul> <li>Signature verification (positive and negative cases)</li> <li>Claim validation (<code>iss</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code> with leeway)</li> <li>Authorization logic (permissions, roles, predicates)</li> <li>Mode detection (HS512 vs EdDSA based on environment)</li> <li>Secret-name indirection (resolution and fallback)</li> </ul>"},{"location":"security-guide/#static-analysis","title":"Static Analysis","text":"<p>Run these checks in CI:</p> <ul> <li>ESLint (TypeScript/JavaScript)</li> <li>Ruff (Python linting)</li> <li>mypy (Python type checking)</li> <li>TypeScript compiler (type checking)</li> </ul>"},{"location":"security-guide/#secret-scanning","title":"Secret Scanning","text":"<p>Enable secret scanning to prevent committed secrets:</p> <ul> <li>Gitleaks (open source)</li> <li>GitHub Advanced Security (GitHub)</li> <li>GitLab Secret Detection (GitLab)</li> </ul> <p>Example Gitleaks config:</p> <pre><code># .gitleaks.toml\n[[rules]]\nid = \"jwt-secrets\"\ndescription = \"JWT secrets and keys\"\nregex = '''JWT_(SECRET|PRIVATE_JWK|PUBLIC_JWK|JWKS_URL)\\s*=\\s*[\"']?[A-Za-z0-9_\\-+/={}:,\"\\.]{32,}[\"']?'''\n</code></pre>"},{"location":"security-guide/#hardening-checklist","title":"Hardening Checklist","text":"<p>Before deploying to production:</p> <ul> <li> HS512 or EdDSA explicitly enforced (not both in same environment)</li> <li> Secrets stored as Cloudflare bindings (<code>*_NAME</code> pattern)</li> <li> TTL \u2264 15 minutes; leeway \u2264 90 seconds</li> <li> No tokens in logs, URLs, or version control</li> <li> Minimal claims principle applied (no PII unless necessary)</li> <li> Rotation policy documented and tested (both HS512 and EdDSA)</li> <li> Thumbprint pinning configured (if using EdDSA with strict requirements)</li> <li> CI secret scan enabled</li> <li> Dependencies pinned in lockfiles</li> <li> Incident response runbook prepared</li> <li> TLS everywhere (no plaintext transmission)</li> <li> Authorization header used (<code>Authorization: Bearer</code>)</li> <li> Test coverage includes security-critical paths</li> </ul>"},{"location":"security-guide/#incident-response","title":"Incident Response","text":""},{"location":"security-guide/#on-leak-or-compromise","title":"On Leak or Compromise","text":"<p>Immediate actions:</p> <ol> <li>Rotate secrets/keys immediately</li> <li>Revoke sessions by shortening TTL and reissuing tokens</li> <li>Review access logs for suspicious activity</li> <li>Notify affected users if PII exposed</li> </ol> <p>Investigation:</p> <ol> <li>Identify scope of compromise (which secrets, how long exposed)</li> <li>Review logs for unusual patterns</li> <li>Check for permission escalation attempts</li> </ol> <p>Post-incident:</p> <ol> <li>Document root cause</li> <li>Update security procedures</li> <li>Add detection for similar incidents</li> <li>Consider additional controls (e.g., replay prevention, stricter TTLs)</li> </ol>"},{"location":"security-guide/#audit-logging","title":"Audit Logging","text":"<p>Log sufficient context for forensics without logging tokens:</p> <pre><code>console.log({\n  timestamp: new Date().toISOString(),\n  jti: payload.jti, // JWT ID\n  sub: payload.sub, // Subject\n  iss: payload.iss, // Issuer\n  aud: payload.aud, // Audience\n  iat: payload.iat, // Issued at\n  exp: payload.exp, // Expiration\n  actor: payload.act?.sub, // Actor service (if delegated)\n  action: 'read:sensitive', // Action performed\n  result: 'success', // Outcome\n  ip: requestIP, // Client IP (if applicable)\n})\n</code></pre>"},{"location":"security-guide/#threat-model","title":"Threat Model","text":""},{"location":"security-guide/#threats-mitigated","title":"Threats Mitigated","text":"<ul> <li>Token forgery \u2014 Cryptographic signature prevents creating valid tokens without secret/private key</li> <li>Algorithm substitution \u2014 Kit rejects tokens with unexpected <code>alg</code> headers</li> <li>Expired token reuse \u2014 Expiration checks with leeway prevent use of expired tokens</li> <li>Clock skew exploitation \u2014 Leeway limited to 90 seconds by default</li> <li>Permission escalation \u2014 Delegated tokens preserve original permissions, no escalation</li> <li>Replay attacks \u2014 Optional <code>jti</code> tracking in KV store</li> </ul>"},{"location":"security-guide/#threats-not-mitigated","title":"Threats Not Mitigated","text":"<p>Token theft:</p> <ul> <li>If attacker obtains valid token, they can use it until expiration</li> <li>Mitigate with: Short TTLs (5-15 min), TLS everywhere, secure storage</li> </ul> <p>Compromised secret/private key:</p> <ul> <li>Attacker can forge tokens indefinitely</li> <li>Mitigate with: Secret rotation, access controls, ephemeral keys, HSM storage</li> </ul> <p>Side-channel attacks:</p> <ul> <li>Timing attacks on signature verification (EdDSA resistant, HS512 uses constant-time comparisons)</li> <li>Mitigate with: Use vetted crypto libraries (<code>jose</code>, WebCrypto)</li> </ul> <p>Distributed denial of service:</p> <ul> <li>Signature verification is computationally expensive</li> <li>Mitigate with: Rate limiting, WAF rules, valid token caching</li> </ul>"},{"location":"security-guide/#references","title":"References","text":"<ul> <li>RFC 7519: JSON Web Token (JWT)</li> <li>RFC 7517: JSON Web Key (JWK)</li> <li>RFC 8693: OAuth 2.0 Token Exchange</li> <li>OWASP JWT Cheat Sheet</li> <li>Cloudflare Workers Security</li> </ul> <p>Questions or security concerns? Open a security issue or contact the maintainers directly.</p>"},{"location":"service-delegation/","title":"Service Delegation","text":"<p>Zero-trust service-to-service authentication using RFC 8693 actor claims.</p>"},{"location":"service-delegation/#the-problem","title":"The Problem","text":"<p>In a zero-trust microservices architecture, external tokens (like Auth0 JWTs) should not propagate beyond the edge. Instead, the gateway mints short-lived internal tokens for service-to-service communication.</p> <p>Challenge: How do internal services know which service is acting on behalf of the original user?</p> <p>Solution: RFC 8693 actor claims \u2014 tokens declare \"I'm <code>&lt;service&gt;</code> acting on behalf of <code>&lt;user&gt;</code>\".</p>"},{"location":"service-delegation/#actor-claims-rfc-8693","title":"Actor Claims (RFC 8693)","text":"<p>The <code>act</code> (actor) claim identifies a service acting on behalf of another principal.</p> <p>Structure:</p> <pre><code>{\n  \"sub\": \"user@example.com\", // Original end user\n  \"permissions\": [\"read:data\"], // Original permissions (no escalation)\n  \"act\": {\n    \"sub\": \"gateway-service\" // Service acting on behalf of user\n  }\n}\n</code></pre> <p>For delegation chains (service calling another service):</p> <pre><code>{\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\"],\n  \"act\": {\n    \"sub\": \"api-service\", // Current actor\n    \"act\": {\n      \"sub\": \"gateway-service\" // Previous actor (nested)\n    }\n  }\n}\n</code></pre>"},{"location":"service-delegation/#creating-delegated-tokens","title":"Creating Delegated Tokens","text":"<p>Use <code>createDelegatedToken()</code> to mint tokens for internal service communication.</p>"},{"location":"service-delegation/#typescript","title":"TypeScript","text":"<pre><code>import { createDelegatedToken } from '@chrislyons-dev/flarelette-jwt'\n\n// Gateway receives external token (e.g., from Auth0)\nconst externalPayload = await verifyAuth0Token(externalToken)\n\n// Create internal token for API service\nconst internalToken = await createDelegatedToken(\n  externalPayload, // Original verified payload\n  'gateway-service', // Actor service identifier\n  {\n    aud: 'internal-api', // Internal audience\n    ttlSeconds: 300, // Short-lived (5 min)\n  }\n)\n\n// Pass internal token to downstream service\nconst response = await fetch('https://api.internal', {\n  headers: { Authorization: `Bearer ${internalToken}` },\n})\n</code></pre>"},{"location":"service-delegation/#python","title":"Python","text":"<pre><code>from flarelette_jwt import create_delegated_token\n\n# Gateway receives external token\nexternal_payload = await verify_auth0_token(external_token)\n\n# Create internal token for API service\ninternal_token = await create_delegated_token(\n    external_payload,         # Original verified payload\n    \"gateway-service\",        # Actor service identifier\n    aud=\"internal-api\",       # Internal audience\n    ttl_seconds=300           # Short-lived (5 min)\n)\n\n# Pass internal token to downstream service\nresponse = await fetch(\"https://api.internal\", {\n    \"headers\": {\"Authorization\": f\"Bearer {internal_token}\"}\n})\n</code></pre>"},{"location":"service-delegation/#what-gets-preserved","title":"What Gets Preserved","text":"<p><code>createDelegatedToken()</code> automatically preserves identity and authorization context:</p> <p>Always copied:</p> <ul> <li><code>sub</code> \u2014 Original user identifier</li> <li><code>permissions</code> \u2014 Original permission list (no escalation)</li> <li><code>roles</code> \u2014 Original role list</li> </ul> <p>Conditionally copied (if present):</p> <ul> <li><code>email</code> \u2014 User email address</li> <li><code>name</code> \u2014 User display name</li> <li><code>groups</code> \u2014 Group memberships</li> <li><code>tid</code> \u2014 Tenant ID (multi-tenant apps)</li> <li><code>org_id</code> \u2014 Organization ID</li> <li><code>department</code> \u2014 Department/division</li> </ul> <p>Never copied:</p> <ul> <li>External token fields (<code>exp</code>, <code>iat</code>, <code>nbf</code>, <code>jti</code>) \u2014 New values generated</li> <li>Provider-specific fields \u2014 Not relevant for internal tokens</li> </ul>"},{"location":"service-delegation/#permission-preservation","title":"Permission Preservation","text":"<p>Critical security property: no permission escalation.</p> <pre><code>// External Auth0 token\n{\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\"]  // Limited scope\n}\n\n// Internal delegated token\n{\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\"],  // \u2705 Same permissions, no escalation\n  \"act\": { \"sub\": \"gateway-service\" }\n}\n\n// \u274c WRONG \u2014 Never do this\nconst badToken = await sign({\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\", \"admin:all\"],  // \u274c Escalation!\n  \"act\": { \"sub\": \"gateway-service\" }\n})\n</code></pre> <p>Why it matters:</p> <ul> <li>External auth providers control original permissions</li> <li>Internal services cannot grant additional permissions</li> <li>Prevents compromised services from escalating privileges</li> </ul>"},{"location":"service-delegation/#delegation-chains","title":"Delegation Chains","text":"<p>When services call other services, the <code>act</code> claim nests.</p>"},{"location":"service-delegation/#example-three-service-chain","title":"Example: Three-Service Chain","text":"<ol> <li>Gateway receives Auth0 token for <code>user@example.com</code></li> <li>Gateway \u2192 API Service with delegated token</li> <li>API Service \u2192 Data Service with further delegated token</li> </ol> <p>Token at step 2 (Gateway \u2192 API):</p> <pre><code>{\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\"],\n  \"act\": {\n    \"sub\": \"gateway-service\"\n  }\n}\n</code></pre> <p>Token at step 3 (API \u2192 Data):</p> <pre><code>import { createDelegatedToken } from '@chrislyons-dev/flarelette-jwt'\n\n// API service receives token from gateway\nconst gatewayPayload = await verify(gatewayToken)\n\n// API creates new token for data service\nconst dataToken = await createDelegatedToken(\n  gatewayPayload,\n  'api-service', // Current actor\n  { aud: 'data-service' }\n)\n</code></pre> <p>Resulting token:</p> <pre><code>{\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\"],\n  \"act\": {\n    \"sub\": \"api-service\", // Current actor\n    \"act\": {\n      \"sub\": \"gateway-service\" // Previous actor (nested)\n    }\n  }\n}\n</code></pre> <p>Audit trail:</p> <ul> <li>Original user: <code>user@example.com</code></li> <li>Request path: Gateway \u2192 API \u2192 Data</li> <li>Each service identified in nested <code>act</code> claims</li> </ul>"},{"location":"service-delegation/#verification-and-authorization","title":"Verification and Authorization","text":"<p>Services receiving delegated tokens verify them normally.</p> <pre><code>import { checkAuth, policy } from '@chrislyons-dev/flarelette-jwt'\n\n// Verify token and check permissions\nconst auth = await checkAuth(token, policy().needAll('read:data').build())\n\nif (!auth) {\n  return new Response('Unauthorized', { status: 401 })\n}\n\n// Access original user and actor\nconsole.log('User:', auth.sub) // user@example.com\nconsole.log('Actor:', auth.payload.act?.sub) // gateway-service\nconsole.log('Permissions:', auth.permissions) // [\"read:data\"]\n</code></pre> <p>Authorization still checks original permissions, not the actor service. The actor claim provides audit context, not additional authority.</p>"},{"location":"service-delegation/#architecture-pattern","title":"Architecture Pattern","text":""},{"location":"service-delegation/#recommended-eddsa-gateway-service-bindings","title":"Recommended: EdDSA Gateway + Service Bindings","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   External Auth Provider         \u2502\n\u2502   (Auth0, Okta, etc.)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502 External token\n                \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Gateway (Node.js + EdDSA)      \u2502\n\u2502                                  \u2502\n\u2502   1. Verify external token       \u2502\n\u2502   2. Create delegated token      \u2502\n\u2502   3. Pass to internal services   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502 Internal token (short TTL)\n                \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2193                \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 API Service  \u2502   \u2502 Data Service \u2502\n\u2502 (TS/Python)  \u2502   \u2502 (TS/Python)  \u2502\n\u2502              \u2502   \u2502              \u2502\n\u2502 Verify token \u2502   \u2502 Verify token \u2502\n\u2502 Check perms  \u2502   \u2502 Check perms  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits:</p> <ul> <li>External tokens never enter internal network</li> <li>Short-lived internal tokens (5-15 min)</li> <li>Full audit trail via nested <code>act</code> claims</li> <li>No permission escalation possible</li> </ul>"},{"location":"service-delegation/#configuration","title":"Configuration","text":"<p>Gateway (Producer):</p> <pre><code># wrangler.toml\n[vars]\nJWT_PRIVATE_JWK_NAME = \"GATEWAY_PRIVATE\"\nJWT_KID = \"ed25519-2025-01\"\nJWT_ISS = \"https://gateway.internal\"\nJWT_AUD = \"internal-services\"\nJWT_TTL_SECONDS = \"300\"  # 5 minutes\n</code></pre> <p>Internal Services (Consumers):</p> <pre><code># wrangler.toml\n[vars]\nJWT_JWKS_SERVICE_NAME = \"GATEWAY_BINDING\"\nJWT_ISS = \"https://gateway.internal\"\nJWT_AUD = \"internal-services\"\n\n# Service binding to gateway\n[[services]]\nbinding = \"GATEWAY_BINDING\"\nservice = \"gateway\"\nenvironment = \"production\"\n</code></pre>"},{"location":"service-delegation/#security-considerations","title":"Security Considerations","text":""},{"location":"service-delegation/#token-lifetime","title":"Token Lifetime","text":"<p>External tokens: Long-lived (hours), managed by external provider</p> <p>Delegated tokens: Short-lived (5-15 minutes)</p> <ul> <li>Reduces blast radius if token leaked</li> <li>Forces services to re-verify frequently</li> <li>Limits time window for replay attacks</li> </ul> <pre><code>// Short TTL for internal tokens\nconst token = await createDelegatedToken(\n  externalPayload,\n  'gateway-service',\n  { ttlSeconds: 300 } // \u2705 5 minutes\n)\n</code></pre>"},{"location":"service-delegation/#audience-scoping","title":"Audience Scoping","text":"<p>Use specific audiences for each internal service.</p> <pre><code>// \u2705 GOOD \u2014 Specific audience per service\nawait createDelegatedToken(payload, 'gateway', { aud: 'data-api' })\nawait createDelegatedToken(payload, 'gateway', { aud: 'billing-api' })\n\n// \u274c BAD \u2014 Generic audience\nawait createDelegatedToken(payload, 'gateway', { aud: 'all-services' })\n</code></pre> <p>Why: Prevents token meant for one service from being used by another.</p>"},{"location":"service-delegation/#actor-verification","title":"Actor Verification","text":"<p>Downstream services can verify which service created the token.</p> <pre><code>const auth = await checkAuth(token, policy().build())\n\nif (auth?.payload.act?.sub !== 'gateway-service') {\n  return new Response('Invalid actor', { status: 403 })\n}\n</code></pre> <p>Use when: Only specific services should be able to call your API.</p>"},{"location":"service-delegation/#permission-auditing","title":"Permission Auditing","text":"<p>Log actor claims for audit trails.</p> <pre><code>const auth = await checkAuth(token, policy().build())\n\nconsole.log({\n  user: auth.sub,\n  actor: auth.payload.act?.sub,\n  permissions: auth.permissions,\n  timestamp: new Date().toISOString(),\n})\n</code></pre>"},{"location":"service-delegation/#complete-example","title":"Complete Example","text":""},{"location":"service-delegation/#gateway-service","title":"Gateway Service","text":"<pre><code>import { Hono } from 'hono'\nimport { createDelegatedToken } from '@chrislyons-dev/flarelette-jwt'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\n\nconst app = new Hono&lt;{ Bindings: WorkerEnv }&gt;()\n\napp.use('*', async (c, next) =&gt; {\n  const jwt = makeKit(c.env)\n  c.set('jwt', jwt)\n  await next()\n})\n\napp.post('/internal-auth', async c =&gt; {\n  // Get external token from request\n  const externalToken = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  // Verify external token (Auth0, Okta, etc.)\n  const externalPayload = await verifyExternalToken(externalToken)\n  if (!externalPayload) {\n    return c.json({ error: 'Invalid external token' }, 401)\n  }\n\n  // Create delegated token for internal use\n  const internalToken = await createDelegatedToken(externalPayload, 'gateway-service', {\n    aud: 'internal-api',\n    ttlSeconds: 300, // 5 minutes\n  })\n\n  return c.json({ token: internalToken })\n})\n\nexport default app\n</code></pre>"},{"location":"service-delegation/#internal-api-service","title":"Internal API Service","text":"<pre><code>import { Hono } from 'hono'\nimport { checkAuth, policy } from '@chrislyons-dev/flarelette-jwt'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\n\nconst app = new Hono&lt;{ Bindings: WorkerEnv }&gt;()\n\napp.use('*', async (c, next) =&gt; {\n  const jwt = makeKit(c.env)\n  c.set('jwt', jwt)\n  await next()\n})\n\napp.get('/data', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  // Verify and authorize\n  const auth = await jwt.checkAuth(token, policy().needAll('read:data').build())\n\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  // Log for audit\n  console.log({\n    user: auth.sub,\n    actor: auth.payload.act?.sub,\n    action: 'read:data',\n    timestamp: new Date().toISOString(),\n  })\n\n  return c.json({ data: 'sensitive information', user: auth.sub })\n})\n\nexport default app\n</code></pre>"},{"location":"service-delegation/#references","title":"References","text":"<ul> <li>RFC 8693: OAuth 2.0 Token Exchange \u2014 Actor claim specification</li> <li>Core Concepts \u2014 Algorithm selection and architecture</li> <li>Security Guide \u2014 Cryptographic profiles and best practices</li> <li>Cloudflare Workers \u2014 Deployment and configuration</li> </ul>"},{"location":"usage-guide/","title":"Usage Guide","text":"<p>Complete API reference for Flarelette JWT Kit with examples in TypeScript and Python.</p>"},{"location":"usage-guide/#overview","title":"Overview","text":"<p>This guide covers all exported functions, types, and patterns for both languages. For conceptual understanding, see Core Concepts. For security best practices, see Security Guide.</p>"},{"location":"usage-guide/#core-functions","title":"Core Functions","text":""},{"location":"usage-guide/#sign","title":"sign()","text":"<p>Low-level JWT signing function. Algorithm (HS512 or EdDSA) is automatically detected from environment.</p> <p>TypeScript:</p> <pre><code>import { sign } from '@chrislyons-dev/flarelette-jwt'\n\nconst token = await sign({\n  sub: 'user123',\n  permissions: ['read:data', 'write:data'],\n  roles: ['user', 'editor'],\n})\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import sign\n\ntoken = await sign({\n    \"sub\": \"user123\",\n    \"permissions\": [\"read:data\", \"write:data\"],\n    \"roles\": [\"user\", \"editor\"]\n})\n</code></pre> <p>Parameters:</p> <ul> <li><code>payload</code> (ClaimsDict) - Custom claims to include in token. Standard claims (<code>iss</code>, <code>aud</code>, <code>iat</code>, <code>exp</code>) are added automatically from environment.</li> </ul> <p>Returns: <code>Promise&lt;string&gt;</code> (TypeScript) or <code>str</code> (Python) - Signed JWT token</p> <p>Automatically added claims:</p> <ul> <li><code>iss</code> - From <code>JWT_ISS</code> environment variable</li> <li><code>aud</code> - From <code>JWT_AUD</code> environment variable</li> <li><code>iat</code> - Current Unix timestamp</li> <li><code>exp</code> - Current timestamp + <code>JWT_TTL_SECONDS</code> (default 900)</li> <li><code>jti</code> - Optional, if <code>JWT_JTI</code> is set</li> </ul>"},{"location":"usage-guide/#verify","title":"verify()","text":"<p>Low-level JWT verification function. Validates signature, issuer, audience, and expiration.</p> <p>TypeScript:</p> <pre><code>import { verify } from '@chrislyons-dev/flarelette-jwt'\n\nconst payload = await verify(token)\nif (payload) {\n  console.log('Valid token for user:', payload.sub)\n} else {\n  console.log('Invalid or expired token')\n}\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import verify\n\npayload = await verify(token)\nif payload:\n    print(f\"Valid token for user: {payload.get('sub')}\")\nelse:\n    print(\"Invalid or expired token\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>token</code> (string) - JWT token to verify</li> <li><code>options</code> (optional) - Verification options:</li> <li><code>leeway</code> (number) - Clock skew tolerance in seconds (overrides <code>JWT_LEEWAY</code>)</li> </ul> <p>Returns: <code>Promise&lt;JwtPayload | null&gt;</code> (TypeScript) or <code>JwtPayload | None</code> (Python)</p> <p>Fail-silent behavior: Returns <code>null</code>/<code>None</code> on any verification failure (invalid signature, expired, wrong issuer/audience, etc.)</p>"},{"location":"usage-guide/#parse","title":"parse()","text":"<p>Parse JWT token without verification. Useful for inspecting token contents.</p> <p>TypeScript:</p> <pre><code>import { parse } from '@chrislyons-dev/flarelette-jwt'\n\nconst { header, payload } = parse(token)\nconsole.log('Algorithm:', header.alg)\nconsole.log('Key ID:', header.kid)\nconsole.log('Issuer:', payload.iss)\nconsole.log('Expires:', new Date(payload.exp * 1000))\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import parse\n\nparsed = parse(token)\nprint(f\"Algorithm: {parsed['header']['alg']}\")\nprint(f\"Key ID: {parsed['header'].get('kid')}\")\nprint(f\"Issuer: {parsed['payload']['iss']}\")\nprint(f\"Expires: {parsed['payload']['exp']}\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>token</code> (string) - JWT token to parse</li> </ul> <p>Returns: <code>ParsedJwt</code> - Object with <code>header</code> and <code>payload</code> fields</p> <p>Warning: Does not validate signature or claims. Never use parsed data for authorization decisions without calling <code>verify()</code> first.</p>"},{"location":"usage-guide/#high-level-functions","title":"High-Level Functions","text":""},{"location":"usage-guide/#createtoken","title":"createToken()","text":"<p>High-level token creation with options. Wraps <code>sign()</code> with additional configurability.</p> <p>TypeScript:</p> <pre><code>import { createToken } from '@chrislyons-dev/flarelette-jwt'\n\nconst token = await createToken(\n  {\n    sub: 'user123',\n    permissions: ['read:data'],\n    email: 'user@example.com',\n  },\n  {\n    ttlSeconds: 600, // Override default TTL\n    aud: 'special-api', // Override default audience\n  }\n)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import create_token\n\ntoken = await create_token(\n    {\"sub\": \"user123\", \"permissions\": [\"read:data\"], \"email\": \"user@example.com\"},\n    ttl_seconds=600,  # Override default TTL\n    aud=\"special-api\"  # Override default audience\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>claims</code> (ClaimsDict) - Custom claims</li> <li><code>options</code> (optional):</li> <li><code>ttlSeconds</code> / <code>ttl_seconds</code> (number) - Token lifetime in seconds (overrides <code>JWT_TTL_SECONDS</code>)</li> <li><code>aud</code> (string) - Audience claim (overrides <code>JWT_AUD</code>)</li> </ul> <p>Returns: <code>Promise&lt;string&gt;</code> (TypeScript) or <code>str</code> (Python) - Signed JWT token</p>"},{"location":"usage-guide/#checkauth","title":"checkAuth()","text":"<p>Verify token and check authorization policy in one call.</p> <p>TypeScript:</p> <pre><code>import { checkAuth, policy } from '@chrislyons-dev/flarelette-jwt'\n\nconst authPolicy = policy()\n  .needAll('read:data', 'write:data')\n  .rolesAny('admin', 'editor')\n  .build()\n\nconst auth = await checkAuth(token, authPolicy)\nif (auth) {\n  console.log('Authorized user:', auth.sub)\n  console.log('Permissions:', auth.permissions)\n  console.log('Full payload:', auth.payload)\n} else {\n  console.log('Authorization failed')\n}\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import check_auth, policy\n\nauth_policy = (\n    policy()\n    .need_all('read:data', 'write:data')\n    .roles_any('admin', 'editor')\n    .build()\n)\n\nauth = await check_auth(token, **auth_policy)\nif auth:\n    print(f\"Authorized user: {auth['sub']}\")\n    print(f\"Permissions: {auth['permissions']}\")\n    print(f\"Full payload: {auth['payload']}\")\nelse:\n    print(\"Authorization failed\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>token</code> (string) - JWT token to verify</li> <li><code>authzOpts</code> (AuthzOpts / dict) - Authorization requirements (from <code>policy().build()</code>)</li> </ul> <p>Returns: <code>Promise&lt;AuthUser | null&gt;</code> (TypeScript) or <code>AuthUser | None</code> (Python)</p> <p>AuthUser fields:</p> <ul> <li><code>sub</code> - Subject (user ID)</li> <li><code>permissions</code> - List of permission strings</li> <li><code>roles</code> - List of role strings</li> <li><code>payload</code> - Full JWT payload</li> </ul>"},{"location":"usage-guide/#createdelegatedtoken","title":"createDelegatedToken()","text":"<p>Create delegated token for service-to-service authentication using RFC 8693 actor claims.</p> <p>TypeScript:</p> <pre><code>import { createDelegatedToken } from '@chrislyons-dev/flarelette-jwt'\n\n// Gateway receives external token\nconst externalPayload = await verifyAuth0Token(externalToken)\n\n// Create internal token for API service\nconst internalToken = await createDelegatedToken(\n  externalPayload, // Original verified payload\n  'gateway-service', // Actor service identifier\n  {\n    aud: 'internal-api', // Internal audience\n    ttlSeconds: 300, // Short-lived (5 min)\n  }\n)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import create_delegated_token\n\n# Gateway receives external token\nexternal_payload = await verify_auth0_token(external_token)\n\n# Create internal token for API service\ninternal_token = await create_delegated_token(\n    external_payload,        # Original verified payload\n    \"gateway-service\",       # Actor service identifier\n    aud=\"internal-api\",      # Internal audience\n    ttl_seconds=300          # Short-lived (5 min)\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>originalPayload</code> / <code>original_payload</code> (JwtPayload) - Verified payload from external token</li> <li><code>actorServiceId</code> / <code>actor_service_id</code> (string) - Service identifier for <code>act</code> claim</li> <li><code>options</code> (optional):</li> <li><code>ttlSeconds</code> / <code>ttl_seconds</code> (number) - Token lifetime (default: 300 seconds)</li> <li><code>aud</code> (string) - Internal audience (overrides <code>JWT_AUD</code>)</li> </ul> <p>Returns: <code>Promise&lt;string&gt;</code> (TypeScript) or <code>str</code> (Python) - Delegated JWT token</p> <p>Preserved claims:</p> <ul> <li><code>sub</code> - Original user identifier</li> <li><code>permissions</code> - Original permissions (no escalation)</li> <li><code>roles</code> - Original roles</li> <li><code>email</code>, <code>name</code>, <code>groups</code>, <code>tid</code>, <code>org_id</code>, <code>department</code> - If present</li> </ul> <p>Added claims:</p> <ul> <li><code>act</code> - Actor claim with <code>sub</code> field containing <code>actorServiceId</code></li> <li>New <code>iss</code>, <code>aud</code>, <code>iat</code>, <code>exp</code>, <code>jti</code> - For internal token</li> </ul> <p>Delegation chains: If <code>originalPayload</code> already has an <code>act</code> claim, it is nested:</p> <pre><code>{\n  \"sub\": \"user@example.com\",\n  \"act\": {\n    \"sub\": \"api-service\",\n    \"act\": {\n      \"sub\": \"gateway-service\"\n    }\n  }\n}\n</code></pre> <p>See Service Delegation for detailed usage patterns.</p>"},{"location":"usage-guide/#policy","title":"policy()","text":"<p>Fluent builder for authorization policies.</p> <p>TypeScript:</p> <pre><code>import { policy } from '@chrislyons-dev/flarelette-jwt'\n\n// Require all listed permissions\nconst p1 = policy().needAll('read:data', 'write:data').build()\n\n// Require at least one listed permission\nconst p2 = policy().needAny('read:data', 'admin:all').build()\n\n// Require at least one listed role\nconst p3 = policy().rolesAny('admin', 'editor').build()\n\n// Require all listed roles\nconst p4 = policy().rolesAll('user', 'verified').build()\n\n// Custom predicate function\nconst p5 = policy()\n  .predicate(payload =&gt; payload.email?.endsWith('@example.com'))\n  .build()\n\n// Combine multiple requirements\nconst p6 = policy()\n  .needAll('read:data')\n  .rolesAny('admin', 'editor')\n  .predicate(payload =&gt; payload.email?.endsWith('@example.com'))\n  .build()\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import policy\n\n# Require all listed permissions\np1 = policy().need_all('read:data', 'write:data').build()\n\n# Require at least one listed permission\np2 = policy().need_any('read:data', 'admin:all').build()\n\n# Require at least one listed role\np3 = policy().roles_any('admin', 'editor').build()\n\n# Require all listed roles\np4 = policy().roles_all('user', 'verified').build()\n\n# Custom predicate function\np5 = policy().predicate(lambda payload: payload.get(\"email\", \"\").endswith(\"@example.com\")).build()\n\n# Combine multiple requirements\np6 = (\n    policy()\n    .need_all('read:data')\n    .roles_any('admin', 'editor')\n    .predicate(lambda payload: payload.get(\"email\", \"\").endswith(\"@example.com\"))\n    .build()\n)\n</code></pre> <p>Builder methods:</p> <ul> <li><code>needAll(...perms)</code> / <code>need_all(...perms)</code> - Require all listed permissions</li> <li><code>needAny(...perms)</code> / <code>need_any(...perms)</code> - Require at least one listed permission</li> <li><code>rolesAll(...roles)</code> / <code>roles_all(...roles)</code> - Require all listed roles</li> <li><code>rolesAny(...roles)</code> / <code>roles_any(...roles)</code> - Require at least one listed role</li> <li><code>predicate(fn)</code> - Add custom validation function</li> <li><code>build()</code> - Return authorization options object</li> </ul> <p>Predicates: Functions that receive <code>JwtPayload</code> and return boolean. Multiple predicates are AND-ed together.</p>"},{"location":"usage-guide/#configuration-functions","title":"Configuration Functions","text":""},{"location":"usage-guide/#envmode-mode","title":"envMode() / mode()","text":"<p>Detect which algorithm mode is active based on environment variables.</p> <p>TypeScript:</p> <pre><code>import { envMode } from '@chrislyons-dev/flarelette-jwt'\n\nconst producerMode = envMode('producer')\nconsole.log('Producer mode:', producerMode) // \"HS512\" or \"EdDSA\"\n\nconst consumerMode = envMode('consumer')\nconsole.log('Consumer mode:', consumerMode) // \"HS512\" or \"EdDSA\"\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import mode\n\nproducer_mode = mode('producer')\nprint(f'Producer mode: {producer_mode}')  # \"HS512\" or \"EdDSA\"\n\nconsumer_mode = mode('consumer')\nprint(f'Consumer mode: {consumer_mode}')  # \"HS512\" or \"EdDSA\"\n</code></pre> <p>Parameters:</p> <ul> <li><code>role</code> - Either <code>\"producer\"</code> (signing) or <code>\"consumer\"</code> (verification)</li> </ul> <p>Returns: <code>\"HS512\"</code> or <code>\"EdDSA\"</code></p> <p>Detection logic:</p> <ul> <li>Producer: If <code>JWT_PRIVATE_JWK_NAME</code> or <code>JWT_PRIVATE_JWK</code> exists \u2192 <code>\"EdDSA\"</code>, otherwise <code>\"HS512\"</code></li> <li>Consumer: If <code>JWT_PUBLIC_JWK_NAME</code> or <code>JWT_PUBLIC_JWK</code> or <code>JWT_JWKS_SERVICE_NAME</code> exists \u2192 <code>\"EdDSA\"</code>, otherwise <code>\"HS512\"</code></li> </ul>"},{"location":"usage-guide/#getprofile-profile","title":"getProfile() / profile()","text":"<p>Get complete JWT configuration profile for current mode.</p> <p>TypeScript:</p> <pre><code>import { getProfile } from '@chrislyons-dev/flarelette-jwt'\n\nconst producerProfile = getProfile('producer')\nconsole.log('Producer algorithm:', producerProfile.alg)\nconsole.log('Has secret:', !!producerProfile.secret)\nconsole.log('Has private key:', !!producerProfile.privateJwk)\n\nconst consumerProfile = getProfile('consumer')\nconsole.log('Consumer algorithm:', consumerProfile.alg)\nconsole.log('Has JWKS service:', !!consumerProfile.jwksService)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import profile\n\nproducer_profile = profile('producer')\nprint(f'Producer algorithm: {producer_profile[\"alg\"]}')\nprint(f'Has secret: {bool(producer_profile.get(\"secret\"))}')\n\nconsumer_profile = profile('consumer')\nprint(f'Consumer algorithm: {consumer_profile[\"alg\"]}')\n</code></pre> <p>Parameters:</p> <ul> <li><code>role</code> - Either <code>\"producer\"</code> or <code>\"consumer\"</code></li> </ul> <p>Returns: <code>JwtProfile</code> object with fields:</p> <ul> <li><code>alg</code> - Algorithm: <code>\"HS512\"</code> or <code>\"EdDSA\"</code></li> <li><code>secret</code> - Base64url-encoded secret (HS512 only)</li> <li><code>privateJwk</code> - Private JWK string (EdDSA producer only)</li> <li><code>publicJwk</code> - Public JWK string (EdDSA consumer with inline key only)</li> <li><code>jwksService</code> - Fetcher service binding (EdDSA consumer with service binding only, TypeScript only)</li> <li><code>kid</code> - Key ID (EdDSA producer only)</li> <li><code>allowedThumbprints</code> - List of allowed JWK thumbprints (EdDSA consumer only)</li> </ul>"},{"location":"usage-guide/#getcommon-common","title":"getCommon() / common()","text":"<p>Get common configuration shared by producer and consumer.</p> <p>TypeScript:</p> <pre><code>import { getCommon } from '@chrislyons-dev/flarelette-jwt'\n\nconst config = getCommon()\nconsole.log('Issuer:', config.iss)\nconsole.log('Audience:', config.aud)\nconsole.log('TTL:', config.ttlSeconds, 'seconds')\nconsole.log('Leeway:', config.leeway, 'seconds')\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import common\n\nconfig = common()\nprint(f'Issuer: {config[\"iss\"]}')\nprint(f'Audience: {config[\"aud\"]}')\nprint(f'TTL: {config[\"ttl_seconds\"]} seconds')\nprint(f'Leeway: {config[\"leeway\"]} seconds')\n</code></pre> <p>Returns: <code>JwtCommonConfig</code> object with fields:</p> <ul> <li><code>iss</code> - Token issuer (from <code>JWT_ISS</code>)</li> <li><code>aud</code> - Token audience (from <code>JWT_AUD</code>)</li> <li><code>ttlSeconds</code> / <code>ttl_seconds</code> - Token lifetime in seconds (from <code>JWT_TTL_SECONDS</code>, default 900)</li> <li><code>leeway</code> - Clock skew tolerance in seconds (from <code>JWT_LEEWAY</code>, default 90)</li> </ul>"},{"location":"usage-guide/#utility-functions","title":"Utility Functions","text":""},{"location":"usage-guide/#isexpiringsoon-is_expiring_soon","title":"isExpiringSoon() / is_expiring_soon()","text":"<p>Check if token is expiring within a threshold.</p> <p>TypeScript:</p> <pre><code>import { isExpiringSoon, verify } from '@chrislyons-dev/flarelette-jwt'\n\nconst payload = await verify(token)\nif (payload &amp;&amp; isExpiringSoon(payload, 300)) {\n  console.log('Token expires within 5 minutes, consider refreshing')\n}\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import is_expiring_soon, verify\n\npayload = await verify(token)\nif payload and is_expiring_soon(payload, 300):\n    print(\"Token expires within 5 minutes, consider refreshing\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>payload</code> (JwtPayload) - Verified JWT payload</li> <li><code>thresholdSeconds</code> / <code>threshold_seconds</code> (number) - Time window in seconds (default: 300)</li> </ul> <p>Returns: <code>boolean</code> - <code>true</code> if token expires within threshold</p>"},{"location":"usage-guide/#generatesecret-generate_secret","title":"generateSecret() / generate_secret()","text":"<p>Generate cryptographically random HS512 secret.</p> <p>TypeScript:</p> <pre><code>import { generateSecret } from '@chrislyons-dev/flarelette-jwt'\n\nconst secret = generateSecret(64) // 64 bytes\nconsole.log('JWT_SECRET=' + secret)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import generate_secret\n\nsecret = generate_secret(64)  # 64 bytes\nprint(f\"JWT_SECRET={secret}\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>length</code> (number) - Secret length in bytes (default: 64)</li> </ul> <p>Returns: <code>string</code> - Base64url-encoded secret</p> <p>Usage: For HS512, use minimum 64 bytes (512 bits) for ~256-bit security.</p>"},{"location":"usage-guide/#adapters","title":"Adapters","text":""},{"location":"usage-guide/#typescript-makekit","title":"TypeScript: makeKit()","text":"<p>Inject Cloudflare Worker environment for use in Workers runtime.</p> <pre><code>import { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\nimport { Hono } from 'hono'\nimport type { WorkerEnv } from '@chrislyons-dev/flarelette-jwt'\n\nconst app = new Hono&lt;{ Bindings: WorkerEnv }&gt;()\n\n// Inject environment middleware\napp.use('*', async (c, next) =&gt; {\n  const jwt = makeKit(c.env)\n  c.set('jwt', jwt)\n  await next()\n})\n\n// Use in routes\napp.get('/secure', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  const auth = await jwt.checkAuth(token, jwt.policy().build())\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  return c.json({ data: 'secure', user: auth.sub })\n})\n\nexport default app\n</code></pre> <p>What it does:</p> <ol> <li>Extracts string variables from Worker <code>env</code> object</li> <li>Extracts Fetcher service bindings (for JWKS)</li> <li>Stores in <code>globalThis.__FLARELETTE_ENV</code> and <code>globalThis.__FLARELETTE_SERVICES</code></li> <li>Returns object with all JWT functions bound to environment</li> </ol> <p>Returns: Object with all JWT functions pre-configured for Worker environment</p>"},{"location":"usage-guide/#python-apply_env_bindings","title":"Python: apply_env_bindings()","text":"<p>Copy Worker environment to <code>os.environ</code> for use in Python Workers.</p> <pre><code>from flarelette_jwt.adapters import apply_env_bindings\nfrom flarelette_jwt import check_auth, policy\nfrom js import Response\n\nasync def on_fetch(request, env, ctx):\n    # Inject environment (call once per request)\n    apply_env_bindings(env)\n\n    # Get token\n    auth_header = request.headers.get('Authorization', '')\n    token = auth_header.removeprefix('Bearer ')\n\n    # Verify and authorize\n    auth = await check_auth(token, **policy().build())\n    if not auth:\n        return Response.new('{\"error\": \"Unauthorized\"}', status=401)\n\n    return Response.new(f'{{\"data\": \"secure\", \"user\": \"{auth[\"sub\"]}\"}}')\n</code></pre> <p>What it does:</p> <ol> <li>Iterates over Worker <code>env</code> mapping</li> <li>Copies string values to <code>os.environ</code></li> <li>All JWT functions read from <code>os.environ</code></li> </ol> <p>Note: Python Workers don't support Fetcher service bindings. Use inline <code>JWT_PUBLIC_JWK</code> for EdDSA verification.</p>"},{"location":"usage-guide/#types-and-interfaces","title":"Types and Interfaces","text":""},{"location":"usage-guide/#typescript-types","title":"TypeScript Types","text":"<p>AlgType - JWT algorithm:</p> <pre><code>type AlgType = 'HS512' | 'EdDSA'\n</code></pre> <p>ClaimsDict - Custom token claims:</p> <pre><code>interface ClaimsDict {\n  sub?: string // Subject (user ID)\n  permissions?: string[] // Permission strings\n  roles?: string[] // Role strings\n  email?: string // User email\n  name?: string // Display name\n  [key: string]: JwtValue // Additional custom claims\n}\n</code></pre> <p>JwtValue - Allowed claim value types:</p> <pre><code>type JwtValue =\n  | string\n  | number\n  | boolean\n  | null\n  | JwtValue[]\n  | { [key: string]: JwtValue }\n</code></pre> <p>JwtHeader - JWT header:</p> <pre><code>interface JwtHeader {\n  alg: AlgType\n  typ: 'JWT'\n  kid?: string // Key ID (EdDSA only)\n}\n</code></pre> <p>JwtPayload - JWT payload:</p> <pre><code>interface JwtPayload {\n  iss: string // Issuer\n  aud: string // Audience\n  sub: string // Subject\n  iat: number // Issued at (Unix timestamp)\n  exp: number // Expiration (Unix timestamp)\n  nbf?: number // Not before (Unix timestamp)\n  jti?: string // JWT ID\n  permissions?: string[] // Permission strings\n  roles?: string[] // Role strings\n  act?: ActorClaim // Actor claim for delegation\n  [key: string]: JwtValue // Additional claims\n}\n</code></pre> <p>ActorClaim - RFC 8693 actor claim:</p> <pre><code>interface ActorClaim {\n  sub: string // Actor service identifier\n  act?: ActorClaim // Nested actor (delegation chain)\n}\n</code></pre> <p>AuthUser - Authorized user result:</p> <pre><code>interface AuthUser {\n  sub: string // Subject (user ID)\n  permissions: string[] // Permission strings\n  roles: string[] // Role strings\n  payload: JwtPayload // Full JWT payload\n}\n</code></pre> <p>ParsedJwt - Parsed token:</p> <pre><code>interface ParsedJwt {\n  header: JwtHeader\n  payload: JwtPayload\n}\n</code></pre> <p>WorkerEnv - Cloudflare Worker environment:</p> <pre><code>interface WorkerEnv {\n  [key: string]: string | Fetcher\n}\n</code></pre> <p>Fetcher - Service binding:</p> <pre><code>interface Fetcher {\n  fetch(input: RequestInfo, init?: RequestInit): Promise&lt;Response&gt;\n}\n</code></pre>"},{"location":"usage-guide/#python-types","title":"Python Types","text":"<p>Python uses TypedDicts for type hints:</p> <p>AlgType - JWT algorithm:</p> <pre><code>AlgType = Literal[\"HS512\", \"EdDSA\"]\n</code></pre> <p>ClaimsDict - Custom token claims:</p> <pre><code>class ClaimsDict(TypedDict, total=False):\n    sub: str\n    permissions: list[str]\n    roles: list[str]\n    email: str\n    name: str\n    # Additional fields allowed via NotRequired\n</code></pre> <p>JwtHeader - JWT header:</p> <pre><code>class JwtHeader(TypedDict):\n    alg: AlgType\n    typ: Literal[\"JWT\"]\n    kid: NotRequired[str]\n</code></pre> <p>JwtPayload - JWT payload:</p> <pre><code>class JwtPayload(TypedDict):\n    iss: str\n    aud: str\n    sub: str\n    iat: int\n    exp: int\n    nbf: NotRequired[int]\n    jti: NotRequired[str]\n    permissions: NotRequired[list[str]]\n    roles: NotRequired[list[str]]\n    act: NotRequired[ActorClaim]\n</code></pre> <p>ActorClaim - RFC 8693 actor claim:</p> <pre><code>class ActorClaim(TypedDict):\n    sub: str\n    act: NotRequired[ActorClaim]\n</code></pre> <p>AuthUser - Authorized user result:</p> <pre><code>class AuthUser(TypedDict):\n    sub: str\n    permissions: list[str]\n    roles: list[str]\n    payload: JwtPayload\n</code></pre> <p>ParsedJwt - Parsed token:</p> <pre><code>class ParsedJwt(TypedDict):\n    header: JwtHeader\n    payload: JwtPayload\n</code></pre>"},{"location":"usage-guide/#common-patterns","title":"Common Patterns","text":""},{"location":"usage-guide/#pattern-cloudflare-worker-typescript-with-hono","title":"Pattern: Cloudflare Worker (TypeScript with Hono)","text":"<pre><code>import { Hono } from 'hono'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\nimport type { WorkerEnv } from '@chrislyons-dev/flarelette-jwt'\n\nconst app = new Hono&lt;{ Bindings: WorkerEnv }&gt;()\n\n// Environment injection middleware\napp.use('*', async (c, next) =&gt; {\n  const jwt = makeKit(c.env)\n  c.set('jwt', jwt)\n  await next()\n})\n\n// Public route\napp.get('/health', c =&gt; c.json({ ok: true }))\n\n// Protected route with policy\napp.get('/secure', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  const auth = await jwt.checkAuth(\n    token,\n    jwt.policy().rolesAny('admin', 'editor').needAll('read:data').build()\n  )\n\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  return c.json({\n    message: 'Authorized',\n    user: auth.sub,\n    permissions: auth.permissions,\n  })\n})\n\nexport default app\n</code></pre>"},{"location":"usage-guide/#pattern-cloudflare-worker-python","title":"Pattern: Cloudflare Worker (Python)","text":"<pre><code>from flarelette_jwt.adapters import apply_env_bindings\nfrom flarelette_jwt import check_auth, policy\nfrom js import Response\n\nasync def on_fetch(request, env, ctx):\n    # Inject environment\n    apply_env_bindings(env)\n\n    # Parse authorization header\n    auth_header = request.headers.get('Authorization', '')\n    token = auth_header.removeprefix('Bearer ')\n\n    # Public endpoint\n    if request.url.endswith('/health'):\n        return Response.new('{\"ok\": true}', status=200)\n\n    # Protected endpoint\n    auth = await check_auth(\n        token,\n        **policy()\n            .roles_any('admin', 'editor')\n            .need_all('read:data')\n            .build()\n    )\n\n    if not auth:\n        return Response.new('{\"error\": \"Unauthorized\"}', status=401)\n\n    return Response.new(\n        f'{{\"message\": \"Authorized\", \"user\": \"{auth[\"sub\"]}\"}}',\n        status=200\n    )\n</code></pre>"},{"location":"usage-guide/#pattern-service-delegation-gateway","title":"Pattern: Service Delegation (Gateway)","text":"<pre><code>import { Hono } from 'hono'\nimport { makeKit, createDelegatedToken } from '@chrislyons-dev/flarelette-jwt'\n\nconst app = new Hono()\n\napp.use('*', async (c, next) =&gt; {\n  c.set('jwt', makeKit(c.env))\n  await next()\n})\n\napp.post('/internal-auth', async c =&gt; {\n  const jwt = c.get('jwt')\n\n  // Get external token from request\n  const externalToken = c.req.header('Authorization')?.replace('Bearer ', '')\n  if (!externalToken) {\n    return c.json({ error: 'No token provided' }, 401)\n  }\n\n  // Verify external token (Auth0, Okta, etc.)\n  const externalPayload = await verifyExternalToken(externalToken)\n  if (!externalPayload) {\n    return c.json({ error: 'Invalid external token' }, 401)\n  }\n\n  // Create delegated token for internal use\n  const internalToken = await createDelegatedToken(externalPayload, 'gateway-service', {\n    aud: 'internal-api',\n    ttlSeconds: 300, // 5 minutes\n  })\n\n  return c.json({ token: internalToken })\n})\n\nexport default app\n</code></pre>"},{"location":"usage-guide/#pattern-service-consumer","title":"Pattern: Service Consumer","text":"<pre><code>import { Hono } from 'hono'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt'\n\nconst app = new Hono()\n\napp.use('*', async (c, next) =&gt; {\n  c.set('jwt', makeKit(c.env))\n  await next()\n})\n\napp.get('/data', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  // Verify delegated token\n  const auth = await jwt.checkAuth(token, jwt.policy().needAll('read:data').build())\n\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  // Log actor for audit\n  console.log({\n    user: auth.sub,\n    actor: auth.payload.act?.sub,\n    action: 'read:data',\n    timestamp: new Date().toISOString(),\n  })\n\n  return c.json({ data: 'sensitive information', user: auth.sub })\n})\n\nexport default app\n</code></pre>"},{"location":"usage-guide/#next-topics","title":"Next Topics","text":"<ul> <li>Getting Started \u2014 Installation and first token</li> <li>Core Concepts \u2014 Algorithms, modes, and architecture</li> <li>Service Delegation \u2014 RFC 8693 actor claims for zero-trust</li> <li>Security Guide \u2014 Cryptographic profiles and best practices</li> <li>Cloudflare Workers \u2014 Workers deployment and configuration</li> </ul>"},{"location":"architecture/","title":"\ud83c\udfd7\ufe0f flarelette-jwt-kit","text":"<p>Architecture Documentation Generated 2025-11-02 06:03:12</p>"},{"location":"architecture/#overview","title":"Overview","text":"<p>JWT authentication and authorization library</p>"},{"location":"architecture/#system-context","title":"System Context","text":"<p>The system context diagram shows how flarelette-jwt-kit fits into its environment, including external systems and users.</p> <p></p>"},{"location":"architecture/#containers","title":"Containers","text":"<p>The container diagram shows the high-level technology choices and how containers communicate.</p> <p></p> Container Type Description Details @chrislyons-dev/flarelette-jwt <code>Service</code> Environment-driven JWT authentication for Cloudflare Workers with secret-name indirection View \u2192 flarelette-jwt <code>Service</code> Environment-driven JWT authentication for Cloudflare Workers Python with secret-name indirection View \u2192 <sub>Generated with Archlette Architecture-as-Code toolkit</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt/","title":"@chrislyons-dev/flarelette-jwt","text":"<p>\u2190 Back to System Overview</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt/#container-context","title":"Container Context","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt/#container-information","title":"Container Information","text":"Name @chrislyons-dev/flarelette-jwt Type <code>Service</code> Description Environment-driven JWT authentication for Cloudflare Workers with secret-name indirection Tags <code>Auto-generated</code>"},{"location":"architecture/chrislyons_dev_flarelette_jwt/#components","title":"Components","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt/#component-view","title":"Component View","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt/#component-details","title":"Component Details","text":"Component Type Description Code core <code>module</code> CLI utility for generating JWT secrets.  This script provides options to generate secrets in various formats, including JSON and dotenv. It is designed to be executed as a standalone Node.js script. | Configuration utilities for JWT operations.  This module provides functions to read environment variables and derive JWT-related configurations. It includes support for both symmetric (HS512) and asymmetric (EdDSA) algorithms. | JWT signing utilities.  This module provides functions to sign JWT tokens using either HS512 or EdDSA algorithms. It supports custom claims and configuration overrides. View \u2192 util <code>module</code> High-level JWT utilities for creating, delegating, verifying, and authorizing JWT tokens | JSON Web Key Set (JWKS) utilities.  This module provides functions to fetch and manage JWKS, including caching and key lookup by key ID (kid). It supports integration with external JWKS services. | Key generation utility for EdDSA keys.  This script generates EdDSA key pairs and exports them in JWK format. It is designed to be executed as a standalone Node.js script. | Secret generation and validation utilities.  This module provides functions to generate secure secrets and validate base64url-encoded secrets. It ensures compatibility with JWT signing requirements. | Utility functions for JWT operations.  This module provides helper functions for parsing JWTs, checking expiration, and mapping OAuth scopes. It is designed to support core JWT functionalities. | JWT verification utilities.  This module provides functions to verify JWT tokens using either HS512 or EdDSA algorithms. It supports integration with JWKS services and thumbprint pinning. View \u2192 main <code>module</code> Entry point for the flarelette-jwt library.  This module re-exports core functionalities, including signing, verification, utilities, and type definitions. It serves as the main interface for library consumers. View \u2192 types <code>module</code> Type definitions for JWT operations.  This module defines types for JWT headers, payloads, profiles, and related structures. It ensures type safety and consistency across the library. View \u2192 adapters <code>module</code> Component inferred from directory: adapters View \u2192 <sub>\u2190 Back to System Overview | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__adapters/","title":"adapters \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__adapters/#component-information","title":"Component Information","text":"Component adapters Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description Component inferred from directory: adapters"},{"location":"architecture/chrislyons_dev_flarelette_jwt__adapters/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__adapters/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__adapters/#code-elements","title":"Code Elements","text":"3 code element(s)    #### Functions  ##### `bindEnv()`  Store both environment variables and service bindings globally   Type <code>function</code> Visibility <code>public</code> Returns <code>void</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/adapters/hono.ts:13</code>   **Parameters:**  - `env`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").WorkerEnv</code>  --- ##### `getServiceBinding()`  Get service binding by name from global storage   Type <code>function</code> Visibility <code>private</code> Returns <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").Fetcher</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/adapters/hono.ts:35</code>   **Parameters:**  - `name`: <code>string</code>  --- ##### `makeKit()`  Returns a namespaced kit whose calls use the provided env bag. Automatically injects JWKS service binding if configured.   Type <code>function</code> Visibility <code>public</code> Returns <code>{ sign: typeof import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/sign\").sign; verify: (token: string, opts?: Partial&lt;{ iss: string; aud: string; leeway: number; }&gt;) =&gt; Promise; createToken: typeof import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high\").createToken; checkAuth: (token: string, opts?: import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high\").AuthzOpts) =&gt; Promise; policy: typeof import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high\").policy; parse: typeof import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/util\").parse; isExpiringSoon: typeof import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/util\").isExpiringSoon; } Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/adapters/hono.ts:45</code>   **Parameters:**  - `env`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").WorkerEnv</code>  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__core/","title":"core \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__core/#component-information","title":"Component Information","text":"Component core Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description CLI utility for generating JWT secrets.  This script provides options to generate secrets in various formats, including JSON and dotenv. It is designed to be executed as a standalone Node.js script. | Configuration utilities for JWT operations.  This module provides functions to read environment variables and derive JWT-related configurations. It includes support for both symmetric (HS512) and asymmetric (EdDSA) algorithms. | JWT signing utilities.  This module provides functions to sign JWT tokens using either HS512 or EdDSA algorithms. It supports custom claims and configuration overrides."},{"location":"architecture/chrislyons_dev_flarelette_jwt__core/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__core/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__core/#code-elements","title":"Code Elements","text":"9 code element(s)    #### Functions  ##### `envRead()`    Type <code>function</code> Visibility <code>private</code> Returns <code>string</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:13</code>   **Parameters:**  - `name`: <code>string</code>  --- ##### `envMode()`    Type <code>function</code> Visibility <code>public</code> Returns <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").AlgType</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:23</code>   **Parameters:**  - `role`: <code>\"producer\" | \"consumer\"</code>  --- ##### `getCommon()`  Get common JWT configuration from environment Returns partial JwtProfile-compatible configuration   Type <code>function</code> Visibility <code>public</code> Returns <code>{ iss: string; aud: string; leeway: number; ttlSeconds: number; }</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:54</code>     --- ##### `getProfile()`  Get JWT profile from environment Returns complete JwtProfile with detected algorithm   Type <code>function</code> Visibility <code>public</code> Returns <code>Partial &amp; { ttlSeconds: number; } Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:67</code>   **Parameters:**  - `role`: <code>\"producer\" | \"consumer\"</code>  --- ##### `getHSSecret()`    Type <code>function</code> Visibility <code>public</code> Returns <code>Uint8Array Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:82</code>     --- ##### `getPrivateJwkString()`    Type <code>function</code> Visibility <code>public</code> Returns <code>string</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:109</code>     --- ##### `getPublicJwkString()`    Type <code>function</code> Visibility <code>public</code> Returns <code>string</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:115</code>     --- ##### `getJwksServiceName()`    Type <code>function</code> Visibility <code>public</code> Returns <code>string</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:121</code>     --- ##### `sign()`  Sign a JWT token with HS512 or EdDSA algorithm   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Signed JWT token string Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/sign.ts:22</code>   **Parameters:**  - `payload`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload</code> \u2014 - Claims to include in the token (can include custom claims beyond standard JWT fields)- `opts`: <code>Partial&lt;{ iss: string; aud: string | string[]; ttlSeconds: number; }&gt;</code> \u2014 - Optional overrides for iss, aud, ttlSeconds  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__main/","title":"main \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__main/#component-information","title":"Component Information","text":"Component main Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description Entry point for the flarelette-jwt library.  This module re-exports core functionalities, including signing, verification, utilities, and type definitions. It serves as the main interface for library consumers."},{"location":"architecture/chrislyons_dev_flarelette_jwt__main/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__main/#code-elements","title":"Code Elements","text":"<p>No code elements extracted for this component.</p> <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__types/","title":"types \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__types/#component-information","title":"Component Information","text":"Component types Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description Type definitions for JWT operations.  This module defines types for JWT headers, payloads, profiles, and related structures. It ensures type safety and consistency across the library."},{"location":"architecture/chrislyons_dev_flarelette_jwt__types/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__types/#code-elements","title":"Code Elements","text":"<p>No code elements extracted for this component.</p> <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__util/","title":"util \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__util/#component-information","title":"Component Information","text":"Component util Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description High-level JWT utilities for creating, delegating, verifying, and authorizing JWT tokens | JSON Web Key Set (JWKS) utilities.  This module provides functions to fetch and manage JWKS, including caching and key lookup by key ID (kid). It supports integration with external JWKS services. | Key generation utility for EdDSA keys.  This script generates EdDSA key pairs and exports them in JWK format. It is designed to be executed as a standalone Node.js script. | Secret generation and validation utilities.  This module provides functions to generate secure secrets and validate base64url-encoded secrets. It ensures compatibility with JWT signing requirements. | Utility functions for JWT operations.  This module provides helper functions for parsing JWTs, checking expiration, and mapping OAuth scopes. It is designed to support core JWT functionalities. | JWT verification utilities.  This module provides functions to verify JWT tokens using either HS512 or EdDSA algorithms. It supports integration with JWKS services and thumbprint pinning."},{"location":"architecture/chrislyons_dev_flarelette_jwt__util/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__util/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__util/#code-elements","title":"Code Elements","text":"15 code element(s)    #### Functions  ##### `createToken()`  Create a signed JWT token with optional claims   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Signed JWT token string Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high.ts:18</code>   **Parameters:**  - `claims`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload</code> \u2014 - Claims to include in the token (can include custom claims beyond standard JWT fields)- `opts`: <code>Partial&lt;{ iss: string; aud: string | string[]; ttlSeconds: number; }&gt;</code> \u2014 - Optional overrides for iss, aud, ttlSeconds  --- ##### `createDelegatedToken()`  Create a delegated JWT token following RFC 8693 actor claim pattern  Mints a new short-lived token for use within service boundaries where a service acts on behalf of the original end user. This implements zero-trust delegation: - Preserves original user identity (sub) and permissions - Identifies the acting service via 'act' claim - Prevents permission escalation by copying original permissions  Pattern: \"I'm  doing work on behalf of \"   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Signed JWT token string with delegation claim Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high.ts:61</code>   **Parameters:**  - `originalPayload`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload</code> \u2014 - The verified JWT payload from external auth (e.g., Auth0)- `actorService`: <code>string</code> \u2014 - Identifier of the service creating this delegated token- `opts`: <code>Partial&lt;{ iss: string; aud: string | string[]; ttlSeconds: number; }&gt;</code> \u2014 - Optional overrides for iss, aud, ttlSeconds **Examples:** <pre><code>\n</code></pre>  --- ##### `checkAuth()`  Verify and authorize a JWT token with policy enforcement   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 AuthUser if valid and authorized, null otherwise Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high.ts:142</code>   **Parameters:**  - `token`: <code>string</code> \u2014 - JWT token string to verify- `opts`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high\").AuthzOpts</code> \u2014 - Authorization options including verification and policy requirements  --- ##### `policy()`  Fluent builder for creating authorization policies   Type <code>function</code> Visibility <code>public</code> Returns <code>{ base(b: Partial&lt;{ iss: string; aud: string | string[]; leeway: number; }&gt;): any; needAll(...perms: string[]): any; needAny(...perms: string[]): any; rolesAll(...roles: string[]): any; rolesAny(...roles: string[]): any; where(fn: (payload: import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload) =&gt; boolean): any; build(): import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high\").AuthzOpts; }</code> \u2014 Policy builder with chainable methods Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high.ts:177</code>     --- ##### `clearJwksCache()`  Clear the JWKS cache (for testing purposes)   Type <code>function</code> Visibility <code>public</code> Returns <code>void</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/jwks.ts:37</code>     --- ##### `fetchJwksFromService()`  Fetch JWKS from a service binding Implements 5-minute caching to reduce load on JWKS service   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/jwks.ts:45</code>   **Parameters:**  - `service`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").Fetcher</code>  --- ##### `getKeyFromJwks()`  Find and import a specific key from JWKS by kid   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise | CryptoKey&gt; Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/jwks.ts:75</code>   **Parameters:**  - `kid`: <code>string</code>- `jwks`: <code>JWKWithKid[]</code>  --- ##### `allowedThumbprints()`  Get allowed thumbprints for key pinning (optional security measure)   Type <code>function</code> Visibility <code>public</code> Returns <code>Set Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/jwks.ts:104</code>     --- ##### `main()`    Type <code>function</code> Visibility <code>private</code> Async Yes Returns <code>Promise Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/keygen.ts:15</code>     --- ##### `generateSecret()`    Type <code>function</code> Visibility <code>public</code> Returns <code>string</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/secret.ts:13</code>   **Parameters:**  - `lengthBytes`: <code>number</code>  --- ##### `isValidBase64UrlSecret()`    Type <code>function</code> Visibility <code>public</code> Returns <code>boolean</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/secret.ts:25</code>   **Parameters:**  - `s`: <code>string</code>- `minBytes`: <code>number</code>  --- ##### `parse()`  Parse a JWT token into header and payload without verification   Type <code>function</code> Visibility <code>public</code> Returns <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").ParsedJwt</code> \u2014 Parsed header and payload Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/util.ts:19</code>   **Parameters:**  - `token`: <code>string</code> \u2014 - JWT token string  --- ##### `isExpiringSoon()`  Check if JWT payload will expire within specified seconds   Type <code>function</code> Visibility <code>public</code> Returns <code>boolean</code> \u2014 True if token expires within the threshold Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/util.ts:35</code>   **Parameters:**  - `payload`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload</code> \u2014 - JWT payload with 'exp' claim- `seconds`: <code>number</code> \u2014 - Number of seconds threshold  --- ##### `mapScopesToPermissions()`  Map OAuth scopes to permission strings   Type <code>function</code> Visibility <code>public</code> Returns <code>string[]</code> \u2014 List of permission strings (currently identity mapping) Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/util.ts:47</code>   **Parameters:**  - `scopes`: <code>string[]</code> \u2014 - List of OAuth scope strings  --- ##### `verify()`  Verify a JWT token with HS512 or EdDSA algorithm   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Decoded payload if valid, null otherwise Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/verify.ts:28</code>   **Parameters:**  - `token`: <code>string</code> \u2014 - JWT token string to verify- `opts`: <code>Partial&lt;{ iss: string; aud: string | string[]; leeway: number; jwksService: import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").Fetcher; }&gt;</code> \u2014 - Optional overrides for iss, aud, leeway, and jwksService  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/flarelette_jwt/","title":"flarelette-jwt","text":"<p>\u2190 Back to System Overview</p>"},{"location":"architecture/flarelette_jwt/#container-context","title":"Container Context","text":""},{"location":"architecture/flarelette_jwt/#container-information","title":"Container Information","text":"Name flarelette-jwt Type <code>Service</code> Description Environment-driven JWT authentication for Cloudflare Workers Python with secret-name indirection Tags <code>Auto-generated</code>"},{"location":"architecture/flarelette_jwt/#components","title":"Components","text":""},{"location":"architecture/flarelette_jwt/#component-view","title":"Component View","text":""},{"location":"architecture/flarelette_jwt/#component-details","title":"Component Details","text":"Component Type Description Code adapters <code>module</code> Adapters for Cloudflare Workers Environment  This module provides utilities to adapt Cloudflare Workers environment variables for use with the Flarelette JWT library. View \u2192 util <code>module</code> Environment Configuration for JWT Operations  This module provides functions to read environment variables and derive JWT-related configurations. It supports both symmetric (HS512) and asymmetric (EdDSA) algorithms. View \u2192 flarelette_jwt <code>module</code> Component derived from directory: flarelette_jwt View \u2192 <sub>\u2190 Back to System Overview | Generated with Archlette</sub>"},{"location":"architecture/flarelette_jwt__adapters/","title":"adapters \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/flarelette_jwt__adapters/#component-information","title":"Component Information","text":"Component adapters Container flarelette-jwt Type <code>module</code> Description Adapters for Cloudflare Workers Environment  This module provides utilities to adapt Cloudflare Workers environment variables for use with the Flarelette JWT library."},{"location":"architecture/flarelette_jwt__adapters/#code-structure","title":"Code Structure","text":""},{"location":"architecture/flarelette_jwt__adapters/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/flarelette_jwt__adapters/#code-elements","title":"Code Elements","text":"1 code element(s)    #### Functions  ##### `apply_env_bindings()`  Copy a Cloudflare Worker `env` mapping into os.environ so the kit can read it.   Type <code>function</code> Visibility <code></code> Returns <code>None</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\adapters.py:15</code>   **Parameters:**  - `env`: <code>Mapping[str, str]</code>  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/flarelette_jwt__flarelette_jwt/","title":"flarelette_jwt \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/flarelette_jwt__flarelette_jwt/#component-information","title":"Component Information","text":"Component flarelette_jwt Container flarelette-jwt Type <code>module</code> Description Component derived from directory: flarelette_jwt"},{"location":"architecture/flarelette_jwt__flarelette_jwt/#code-structure","title":"Code Structure","text":""},{"location":"architecture/flarelette_jwt__flarelette_jwt/#code-elements","title":"Code Elements","text":"<p>No code elements extracted for this component.</p> <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/flarelette_jwt__util/","title":"util \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/flarelette_jwt__util/#component-information","title":"Component Information","text":"Component util Container flarelette-jwt Type <code>module</code> Description Environment Configuration for JWT Operations  This module provides functions to read environment variables and derive JWT-related configurations. It supports both symmetric (HS512) and asymmetric (EdDSA) algorithms."},{"location":"architecture/flarelette_jwt__util/#code-structure","title":"Code Structure","text":""},{"location":"architecture/flarelette_jwt__util/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/flarelette_jwt__util/#code-elements","title":"Code Elements","text":"46 code element(s)   #### Classes  ##### `JwtHeader`  JWT token header structure.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:35</code>    --- ##### `ActorClaim`  Actor claim for service delegation (RFC 8693).   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:49</code>    --- ##### `JwtPayload`  JWT token payload/claims structure.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:68</code>    --- ##### `JwtProfile`  JWT Profile structure matching flarelette-jwt.profile.schema.json.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:110</code>    --- ##### `JwtCommonConfig`  Common JWT configuration from environment variables.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:125</code>    --- ##### `AuthUser`  Authenticated user information returned by check_auth.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:24</code>    --- ##### `PolicyBuilder`  Builder interface for creating JWT authorization policies.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:40</code>    --- ##### `Builder`    Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:227</code>    --- ##### `ParsedJwt`  Parsed JWT token structure.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\util.py:19</code>    ---  #### Functions  ##### `mode()`  Detect JWT algorithm mode from environment variables based on role.   Type <code>function</code> Visibility <code></code> Returns <code>AlgType</code> \u2014 Either \"HS512\" or \"EdDSA\" Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:139</code>   **Parameters:**  - `role`: <code>str</code> \u2014 Either \"producer\" (signing) or \"consumer\" (verification)  --- ##### `common()`  Get common JWT configuration from environment.   Type <code>function</code> Visibility <code></code> Returns <code>JwtCommonConfig</code> \u2014 Configuration with iss, aud, leeway, ttl_seconds Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:169</code>     --- ##### `profile()`  Get JWT profile from environment.   Type <code>function</code> Visibility <code></code> Returns <code>dict[str, Any]</code> \u2014 dict containing alg, iss, aud, leeway_seconds, and ttl_seconds Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:183</code>   **Parameters:**  - `role`: <code>str</code> \u2014 Either \"producer\" (signing) or \"consumer\" (verification)  --- ##### `_get_indirect()`    Type <code>function</code> Visibility <code></code> Returns <code>str | None</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:206</code>   **Parameters:**  - `name_var`: <code>str</code>- `direct_var`: <code>str</code>  --- ##### `get_hs_secret_bytes()`    Type <code>function</code> Visibility <code></code> Returns <code>bytes</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:213</code>     --- ##### `get_public_jwk_string()`    Type <code>function</code> Visibility <code></code> Returns <code>str | None</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:228</code>     --- ##### `create_token()`  Create a signed JWT token with optional claims.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>str</code> \u2014 Signed JWT token string Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:58</code>   **Parameters:**  - `claims`: <code>JwtPayload</code> \u2014 Claims to include in the token (can include custom claims beyond standard JWT fields)  --- ##### `create_delegated_token()`  Create a delegated JWT token following RFC 8693 actor claim pattern.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>str</code> \u2014 Signed JWT token string with delegation claim  See Also:     - RFC 8693: OAuth 2.0 Token Exchange     - security.md: Service Delegation Pattern section Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:79</code>   **Parameters:**  - `original_payload`: <code>JwtPayload</code> \u2014 The verified JWT payload from external auth (e.g., Auth0)- `actor_service`: <code>str</code> \u2014 Identifier of the service creating this delegated token **Examples:** <pre><code>\n</code></pre>  --- ##### `check_auth()`  Verify and authorize a JWT token with policy enforcement.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>AuthUser | None</code> \u2014 AuthUser if valid and authorized, None otherwise Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:166</code>   **Parameters:**  - `token`: <code>str</code> \u2014 JWT token string to verify  --- ##### `policy()`  Fluent builder for creating authorization policies.   Type <code>function</code> Visibility <code></code> Returns <code>PolicyBuilder</code> \u2014 PolicyBuilder with chainable methods Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:219</code>     --- ##### `generate_secret()`    Type <code>function</code> Visibility <code></code> Returns <code>str</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\secret.py:18</code>   **Parameters:**  - `length_bytes`: <code>int</code>  --- ##### `is_valid_base64url_secret()`    Type <code>function</code> Visibility <code></code> Returns <code>bool</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\secret.py:23</code>   **Parameters:**  - `secret`: <code>str</code>- `min_bytes`: <code>int</code>  --- ##### `main()`    Type <code>function</code> Visibility <code></code> Returns <code>int</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\secret.py:32</code>   **Parameters:**  - `argv`: <code>list[str] | None</code>  --- ##### `_b64url()`    Type <code>function</code> Visibility <code></code> Returns <code>str</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\sign.py:21</code>   **Parameters:**  - `b`: <code>bytes</code>  --- ##### `sign()`  Sign a JWT token with HS512 or EdDSA algorithm.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>str</code> \u2014 Signed JWT token string Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\sign.py:25</code>   **Parameters:**  - `payload`: <code>JwtPayload</code> \u2014 Claims to include in the token (can include custom claims beyond standard JWT fields)  --- ##### `parse()`  Parse a JWT token into header and payload without verification.   Type <code>function</code> Visibility <code></code> Returns <code>ParsedJwt</code> \u2014 Dictionary with 'header' and 'payload' keys Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\util.py:31</code>   **Parameters:**  - `token`: <code>str</code> \u2014 JWT token string  --- ##### `is_expiring_soon()`  Check if JWT payload will expire within specified seconds.   Type <code>function</code> Visibility <code></code> Returns <code>bool</code> \u2014 True if token expires within the threshold Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\util.py:49</code>   **Parameters:**  - `payload`: <code>JwtPayload</code> \u2014 JWT payload with 'exp' claim- `seconds`: <code>int</code> \u2014 Number of seconds threshold  --- ##### `map_scopes_to_permissions()`  Map OAuth scopes to permission strings.   Type <code>function</code> Visibility <code></code> Returns <code>list[str]</code> \u2014 List of permission strings (currently identity mapping) Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\util.py:63</code>   **Parameters:**  - `scopes`: <code>list[str]</code> \u2014 List of OAuth scope strings  --- ##### `_b64url_decode()`    Type <code>function</code> Visibility <code></code> Returns <code>bytes</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\verify.py:29</code>   **Parameters:**  - `s`: <code>str</code>  --- ##### `verify()`  Verify a JWT token with HS512 or EdDSA algorithm.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>JwtPayload | None</code> \u2014 Decoded payload if valid, None otherwise Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\verify.py:33</code>   **Parameters:**  - `token`: <code>str</code> \u2014 JWT token string to verify  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"}]}