{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#documentation-index","title":"Documentation Index","text":"<p>Welcome to the Flarelette JWT Kit documentation! Below is a list of available guides and references to help you get started and understand the project.</p>"},{"location":"#guides","title":"Guides","text":"<ul> <li>Setup Guide: Learn how to set up the development environment, install dependencies, and configure the project.</li> <li>Usage Guide: Explore how to use Flarelette JWT Kit for signing, verifying, and managing JWTs.</li> <li>Security Guide: Learn about the security features and requirements of the project.</li> <li>Service Delegation: Understand how to implement zero-trust delegation patterns.</li> <li>Core Concepts: Dive into the architecture and key principles of the toolkit.</li> </ul>"},{"location":"#references","title":"References","text":"<ul> <li>Cloudflare Workers Guide: Specific instructions for deploying and using the toolkit in Cloudflare Workers.</li> <li>Architecture Overview: Explore the architectural design behind the toolkit (provided by archlette).</li> <li>Quick Reference: A handy reference for dependencies and requirements.</li> </ul> <p>For more information, visit the individual files linked above or explore the repository.</p>"},{"location":"#flarelette-jwt-kit","title":"Flarelette JWT Kit","text":"<p>Environment-driven JWT authentication for Cloudflare Workers. Like Starlette, but for the edge.</p> <p>Cross-language JWT toolkit (TypeScript + Python) with identical APIs. Automatically selects HS512 or EdDSA based on environment configuration, loads secrets via Cloudflare bindings, and works across Workers, Node.js, and Python runtimes.</p>"},{"location":"#part-of-the-flarelette-ecosystem","title":"Part of the Flarelette Ecosystem","text":"<p>Flarelette JWT Kit provides the core cryptographic operations for the Flarelette authentication stack. It's framework-neutral by design \u2014 use it directly for low-level JWT operations or through higher-level adapters like <code>flarelette-hono</code> for route guards and middleware integration.</p> <p>Stack layers:</p> <ul> <li>Your services \u2192 Use JWT auth in APIs and UIs</li> <li><code>flarelette</code> / <code>flarelette-hono</code> \u2192 Framework middleware and route guards</li> <li><code>flarelette-jwt-kit</code> (this package) \u2192 Core JWT signing, verification, and key management</li> <li>Platform secrets \u2192 Cloudflare bindings, environment variables</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"TypeScriptPython <pre><code>npm install @chrislyons-dev/flarelette-jwt\n</code></pre> <pre><code>pip install flarelette-jwt\n</code></pre> <p>Cloudflare Workers Only</p> <p>Python package requires Cloudflare Workers runtime (Pyodide)</p>"},{"location":"#basic-example","title":"Basic Example","text":"TypeScriptPython <pre><code>import { sign, verify } from '@chrislyons-dev/flarelette-jwt'\n\n// Sign a token (algorithm chosen from environment)\nconst token = await sign({ sub: 'user123', permissions: ['read:data'] })\n\n// Verify a token\nconst payload = await verify(token)\nif (payload) {\n  console.log('Valid token:', payload.sub)\n}\n</code></pre> <pre><code>from flarelette_jwt import sign, verify\n\n# Sign a token (algorithm chosen from environment)\ntoken = await sign({\"sub\": \"user123\", \"permissions\": [\"read:data\"]})\n\n# Verify a token\npayload = await verify(token)\nif payload:\n    print(f\"Valid token: {payload.get('sub')}\")\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Algorithm auto-detection \u2014 Chooses HS512 or EdDSA based on environment variables</li> <li>Secret-name indirection \u2014 References Cloudflare secret bindings instead of raw values</li> <li>Identical TypeScript + Python APIs \u2014 Same function names and behavior across languages</li> <li>Service bindings for JWKS \u2014 Direct Worker-to-Worker RPC for key distribution</li> <li>Zero-trust delegation \u2014 RFC 8693 actor claims for service-to-service authentication</li> <li>Policy-based authorization \u2014 Fluent API for composing permission and role requirements</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<p>Configuration is entirely environment-driven. No config files required.</p> <p>Common environment variables:</p> <pre><code>JWT_ISS=https://gateway.example.com    # Token issuer\nJWT_AUD=api.example.com                 # Token audience\nJWT_TTL_SECONDS=900                     # Token lifetime (default: 15 min)\nJWT_LEEWAY=90                           # Clock skew tolerance (default: 90 sec)\n</code></pre> <p>HS512 mode (symmetric, shared secret):</p> <pre><code>JWT_SECRET_NAME=MY_JWT_SECRET           # Reference to secret binding\n</code></pre> <p>EdDSA mode (asymmetric, Ed25519):</p> <pre><code># Producer (signs tokens):\nJWT_PRIVATE_JWK_NAME=GATEWAY_PRIVATE_KEY\nJWT_KID=ed25519-2025-01\n\n# Consumer (verifies tokens):\nJWT_PUBLIC_JWK_NAME=GATEWAY_PUBLIC_KEY\n# OR for key rotation:\nJWT_JWKS_SERVICE_NAME=GATEWAY_BINDING\n</code></pre>"},{"location":"#cli-tools","title":"CLI Tools","text":"<p>Generate HS512 secrets:</p> <pre><code>npx flarelette-jwt-secret --len=64 --dotenv\n</code></pre> <p>Generate EdDSA keypairs:</p> <pre><code>npx flarelette-jwt-keygen --kid=ed25519-2025-01\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> Getting Started</li> </ul> <p>Install the packages and create your first JWT token</p> <p> Installation guide</p> <ul> <li> Core Concepts</li> </ul> <p>Learn about algorithms, modes, and architecture patterns</p> <p> Core concepts</p> <ul> <li> Usage Guide</li> </ul> <p>Complete API reference for TypeScript and Python</p> <p> API reference</p> <ul> <li> Security Guide</li> </ul> <p>Cryptographic profiles, key management, and best practices</p> <p> Security guide</p>"},{"location":"#license","title":"License","text":"<p>MIT \u2014 see LICENSE for details.</p>"},{"location":"#security","title":"Security","text":"<p>For security concerns or vulnerability reports, see the Security Guide or open a security issue on GitHub.</p>"},{"location":"cloudflare-workers/","title":"Cloudflare Workers","text":"<p>Deploy Flarelette JWT Kit to Cloudflare Workers with proper secret management and service bindings.</p>"},{"location":"cloudflare-workers/#why-cloudflare-workers","title":"Why Cloudflare Workers?","text":"<ul> <li>Edge computing \u2014 Run authentication logic close to users worldwide</li> <li>Zero cold starts \u2014 Instant response times</li> <li>Integrated secrets \u2014 Built-in secret management with bindings</li> <li>Service bindings \u2014 Direct Worker-to-Worker RPC for JWKS</li> <li>Cost-effective \u2014 Free tier covers most small-to-medium deployments</li> </ul>"},{"location":"cloudflare-workers/#environment-differences","title":"Environment Differences","text":"<p>Workers don't provide standard environment access:</p> <ul> <li>\u274c No <code>process.env</code> (Node.js)</li> <li>\u274c <code>os.environ</code> not auto-populated (Python)</li> <li>\u2705 Environment passed as <code>env</code> object to fetch handler</li> </ul> <p>The kit provides adapters to inject Worker environments.</p>"},{"location":"cloudflare-workers/#quick-start","title":"Quick Start","text":""},{"location":"cloudflare-workers/#typescript-worker","title":"TypeScript Worker","text":"<p>Install:</p> <pre><code>npm install @chrislyons-dev/flarelette-jwt hono\n</code></pre> <p><code>src/index.ts</code>:</p> <pre><code>import { Hono } from 'hono'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\nimport type { WorkerEnv } from '@chrislyons-dev/flarelette-jwt'\n\nconst app = new Hono&lt;{ Bindings: WorkerEnv }&gt;()\n\n// Inject environment\napp.use('*', async (c, next) =&gt; {\n  const jwt = makeKit(c.env)\n  c.set('jwt', jwt)\n  await next()\n})\n\n// Protected route\napp.get('/secure', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  const auth = await jwt.checkAuth(token, jwt.policy().build())\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  return c.json({ data: 'secure', user: auth.sub })\n})\n\nexport default app\n</code></pre> <p><code>wrangler.toml</code>:</p> <pre><code>name = \"my-api\"\nmain = \"src/index.ts\"\ncompatibility_date = \"2024-01-01\"\n\n[vars]\nJWT_SECRET_NAME = \"API_JWT_SECRET\"\nJWT_ISS = \"https://api.example.com\"\nJWT_AUD = \"api.example.com\"\nJWT_TTL_SECONDS = \"900\"\n</code></pre> <p>Deploy:</p> <pre><code># Store secret\nwrangler secret put API_JWT_SECRET\n\n# Deploy\nwrangler deploy\n</code></pre>"},{"location":"cloudflare-workers/#python-worker","title":"Python Worker","text":"<p>Install:</p> <pre><code>pip install flarelette-jwt\n</code></pre> <p><code>src/index.py</code>:</p> <pre><code>from flarelette_jwt.adapters import apply_env_bindings\nfrom flarelette_jwt import check_auth, policy\nfrom js import Response\n\nasync def on_fetch(request, env, ctx):\n    # Inject environment\n    apply_env_bindings(env)\n\n    # Get token\n    auth_header = request.headers.get('Authorization', '')\n    token = auth_header.removeprefix('Bearer ')\n\n    # Verify and authorize\n    auth = await check_auth(token, **policy().build())\n    if not auth:\n        return Response.new('{\"error\": \"Unauthorized\"}', status=401)\n\n    return Response.new(f'{{\"data\": \"secure\", \"user\": \"{auth[\"sub\"]}\"}}')\n</code></pre> <p><code>wrangler.toml</code>:</p> <pre><code>name = \"my-python-api\"\nmain = \"src/index.py\"\ncompatibility_date = \"2024-01-01\"\n\n[vars]\nJWT_SECRET_NAME = \"API_JWT_SECRET\"\nJWT_ISS = \"https://api.example.com\"\nJWT_AUD = \"api.example.com\"\n</code></pre> <p>Deploy:</p> <pre><code>wrangler secret put API_JWT_SECRET\nwrangler deploy\n</code></pre>"},{"location":"cloudflare-workers/#secret-management","title":"Secret Management","text":""},{"location":"cloudflare-workers/#secret-bindings","title":"Secret Bindings","text":"<p>Never commit secrets to wrangler.toml. Use the secret-name indirection pattern:</p> <pre><code>[vars]\nJWT_SECRET_NAME = \"MY_SECRET\"  # \u2705 Reference name, not value\n</code></pre> <pre><code>wrangler secret put MY_SECRET  # \u2705 Store actual secret\n</code></pre>"},{"location":"cloudflare-workers/#multiple-environments","title":"Multiple Environments","text":"<p>Configure different secrets per environment:</p> <p><code>wrangler.toml</code> (base):</p> <pre><code>name = \"my-api\"\nmain = \"src/index.ts\"\n\n[env.dev]\nvars = { JWT_SECRET_NAME = \"JWT_SECRET_DEV\" }\n\n[env.staging]\nvars = { JWT_SECRET_NAME = \"JWT_SECRET_STAGING\" }\n\n[env.production]\nvars = { JWT_SECRET_NAME = \"JWT_SECRET_PROD\" }\n</code></pre> <p>Deploy secrets:</p> <pre><code>wrangler secret put JWT_SECRET_DEV --env dev\nwrangler secret put JWT_SECRET_STAGING --env staging\nwrangler secret put JWT_SECRET_PROD --env production\n</code></pre>"},{"location":"cloudflare-workers/#generating-secrets","title":"Generating Secrets","text":"<p>For HS512:</p> <pre><code>npx flarelette-jwt-secret --len=64 --dotenv\n</code></pre> <p>Copy the output and paste when running <code>wrangler secret put</code>.</p> <p>For EdDSA:</p> <pre><code>npx flarelette-jwt-keygen --kid=ed25519-2025-01 &gt; keys.json\n\n# Store private key\nwrangler secret put GATEWAY_PRIVATE &lt; keys.json\n\n# Store public key (or use service binding)\nwrangler secret put GATEWAY_PUBLIC &lt; keys.json\n</code></pre>"},{"location":"cloudflare-workers/#service-bindings-for-jwks","title":"Service Bindings for JWKS","text":"<p>Service bindings enable direct Worker-to-Worker RPC for key distribution. Recommended for EdDSA deployments.</p>"},{"location":"cloudflare-workers/#benefits","title":"Benefits","text":"<ul> <li>No public endpoint \u2014 JWKS served privately between Workers</li> <li>Lower latency \u2014 Direct RPC, no DNS/TLS overhead</li> <li>Better security \u2014 No internet-facing JWKS endpoint</li> <li>Integrated routing \u2014 Cloudflare handles service discovery</li> </ul>"},{"location":"cloudflare-workers/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   JWT Gateway (Producer)     \u2502\n\u2502                              \u2502\n\u2502   Roles:                     \u2502\n\u2502   1. Signs JWT tokens        \u2502\n\u2502   2. Exposes JWKS endpoint   \u2502\n\u2502      (/.well-known/jwks.json)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                \u2502\n       \u2502 JWT token      \u2502 Service Binding\n       \u2502 (HTTP/auth)    \u2502 (JWKS fetch)\n       \u2502                \u2502\n   \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n   \u2502                        \u2502\n   \u25bc                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Consumer #1     \u2502      \u2502  Consumer #2     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cloudflare-workers/#gateway-setup","title":"Gateway Setup","text":"<p><code>wrangler.toml</code> (gateway):</p> <pre><code>name = \"jwt-gateway\"\nmain = \"src/gateway.ts\"\n\n[vars]\nJWT_PRIVATE_JWK_NAME = \"GATEWAY_PRIVATE\"\nJWT_PUBLIC_JWK_NAME = \"GATEWAY_PUBLIC\"\nJWT_KID = \"ed25519-2025-01\"\nJWT_ISS = \"https://gateway.internal\"\nJWT_AUD = \"internal-api\"\n</code></pre> <p><code>src/gateway.ts</code>:</p> <pre><code>import { Hono } from 'hono'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\n\nconst app = new Hono()\n\napp.use('*', async (c, next) =&gt; {\n  c.set('jwt', makeKit(c.env))\n  await next()\n})\n\n// JWKS endpoint\napp.get('/.well-known/jwks.json', async c =&gt; {\n  const publicJwk = JSON.parse(c.env.GATEWAY_PUBLIC)\n  return c.json({ keys: [publicJwk] })\n})\n\n// Sign tokens\napp.post('/sign', async c =&gt; {\n  const jwt = c.get('jwt')\n  const body = await c.req.json()\n  const token = await jwt.sign(body)\n  return c.json({ token })\n})\n\nexport default app\n</code></pre> <p>Deploy:</p> <pre><code># Generate keypair\nnpx flarelette-jwt-keygen --kid=ed25519-2025-01 &gt; keys.json\n\n# Store private key\nwrangler secret put GATEWAY_PRIVATE --config wrangler.gateway.toml\n# Paste privateJwk from keys.json\n\n# Store public key\nwrangler secret put GATEWAY_PUBLIC --config wrangler.gateway.toml\n# Paste publicJwk from keys.json\n\n# Deploy\nwrangler deploy --config wrangler.gateway.toml\n</code></pre>"},{"location":"cloudflare-workers/#consumer-setup","title":"Consumer Setup","text":"<p><code>wrangler.toml</code> (consumer):</p> <pre><code>name = \"consumer-api\"\nmain = \"src/consumer.ts\"\n\n[vars]\nJWT_JWKS_SERVICE_NAME = \"GATEWAY_BINDING\"\nJWT_ISS = \"https://gateway.internal\"\nJWT_AUD = \"internal-api\"\n\n# Service binding to gateway\n[[services]]\nbinding = \"GATEWAY_BINDING\"\nservice = \"jwt-gateway\"\nenvironment = \"production\"\n</code></pre> <p><code>src/consumer.ts</code>:</p> <pre><code>import { Hono } from 'hono'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\n\nconst app = new Hono()\n\napp.use('*', async (c, next) =&gt; {\n  c.set('jwt', makeKit(c.env)) // Automatically detects service binding\n  await next()\n})\n\napp.get('/secure', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  const auth = await jwt.checkAuth(token, jwt.policy().build())\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  return c.json({ data: 'secure', user: auth.sub })\n})\n\nexport default app\n</code></pre> <p>Deploy:</p> <pre><code>wrangler deploy --config wrangler.consumer.toml\n</code></pre>"},{"location":"cloudflare-workers/#testing-locally","title":"Testing Locally","text":"<p>With Wrangler:</p> <pre><code>wrangler dev\n</code></pre> <p>Set secrets for local development:</p> <pre><code># Create .dev.vars file (gitignored)\nJWT_SECRET_NAME=MY_SECRET\nMY_SECRET=&lt;generated-secret&gt;\nJWT_ISS=https://localhost:8787\nJWT_AUD=localhost\n</code></pre> <p>Test with curl:</p> <pre><code># Get a token (if you have a /sign endpoint)\nTOKEN=$(curl http://localhost:8787/sign -d '{\"sub\":\"test\"}' | jq -r .token)\n\n# Use the token\ncurl -H \"Authorization: Bearer $TOKEN\" http://localhost:8787/secure\n</code></pre>"},{"location":"cloudflare-workers/#performance-considerations","title":"Performance Considerations","text":""},{"location":"cloudflare-workers/#jwks-caching","title":"JWKS Caching","text":"<p>The kit caches JWKS responses for 5 minutes by default. This reduces load on the gateway and improves verification performance.</p> <p>Cache behavior:</p> <ul> <li>First verification: Fetches JWKS from service binding</li> <li>Subsequent verifications: Uses cached keys (5 min)</li> <li>After 5 min: Refetches JWKS</li> </ul> <p>No configuration needed \u2014 caching is automatic.</p>"},{"location":"cloudflare-workers/#token-size","title":"Token Size","text":"<p>Keep tokens under 8KB for optimal performance:</p> <ul> <li>Headers limited to 16KB total</li> <li>Smaller tokens = faster transmission</li> <li>Less parsing overhead</li> </ul> <p>Monitor token size:</p> <pre><code>const token = await sign({ sub: 'user123', permissions: [...] })\nconsole.log(`Token size: ${token.length} bytes`)\n</code></pre>"},{"location":"cloudflare-workers/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"cloudflare-workers/#wrangler-tail","title":"Wrangler Tail","text":"<p>Stream logs from deployed Workers:</p> <pre><code>wrangler tail\n</code></pre>"},{"location":"cloudflare-workers/#log-jwt-verification","title":"Log JWT Verification","text":"<p>Safe logging pattern:</p> <pre><code>const auth = await checkAuth(token, policy().build())\n\nconsole.log({\n  timestamp: new Date().toISOString(),\n  jti: auth?.payload.jti,\n  sub: auth?.sub,\n  success: !!auth,\n})\n</code></pre>"},{"location":"cloudflare-workers/#common-issues","title":"Common Issues","text":"<p>\"JWT secret missing\":</p> <ul> <li>Verify <code>wrangler secret list</code> shows your secret</li> <li>Check <code>JWT_SECRET_NAME</code> matches secret binding name</li> <li>Ensure <code>makeKit(c.env)</code> or <code>apply_env_bindings(env)</code> called</li> </ul> <p>\"EdDSA verification fails\":</p> <ul> <li>For service bindings: Verify <code>[[services]]</code> config correct</li> <li>For inline JWK: Check <code>JWT_PUBLIC_JWK_NAME</code> resolves</li> <li>Verify gateway JWKS endpoint accessible</li> </ul> <p>Mode detection wrong:</p> <ul> <li>Check environment variables with <code>wrangler tail</code></li> <li>Verify no conflicting <code>JWT_*</code> variables</li> <li>Use <code>envMode('consumer')</code> to debug detection</li> </ul>"},{"location":"cloudflare-workers/#references","title":"References","text":"<ul> <li>Cloudflare Workers Docs</li> <li>Wrangler CLI</li> <li>Service Bindings</li> <li>Secrets Management</li> <li>Core Concepts \u2014 Algorithm selection and architecture</li> <li>Security Guide \u2014 Best practices and threat model</li> </ul>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>Understanding how Flarelette JWT Kit makes cryptographic and architectural decisions.</p>"},{"location":"core-concepts/#algorithm-selection","title":"Algorithm Selection","text":"<p>The kit supports two signing algorithms (HS512, EdDSA) and three verification profiles (HS512, EdDSA, RSA). No configuration required \u2014 the mode is detected automatically from your environment.</p> <p>Signing: HS512 for symmetric trust, EdDSA for asymmetric trust.</p> <p>Verification: HS512 and EdDSA for internal tokens, RSA for external OIDC providers.</p>"},{"location":"core-concepts/#hs512-symmetric","title":"HS512 (Symmetric)","text":"<p>HMAC-SHA-512 with 64-byte shared secrets.</p> <p>Use when:</p> <ul> <li>Producer and consumer both trust each other</li> <li>Both services can securely share a secret</li> <li>Simplest deployment with no key distribution needed</li> </ul> <p>Security properties:</p> <ul> <li>~256-bit security with 64-byte keys</li> <li>Symmetric: same secret signs and verifies</li> <li>Fast signing and verification</li> <li>No key rotation complexity</li> </ul> <p>Environment detection:</p> <pre><code>JWT_SECRET_NAME=MY_SECRET    # Points to secret binding\n# OR\nJWT_SECRET=&lt;base64url-secret&gt;  # Direct secret (not recommended for production)\n</code></pre>"},{"location":"core-concepts/#eddsa-asymmetric","title":"EdDSA (Asymmetric)","text":"<p>Ed25519 digital signatures with JSON Web Keys.</p> <p>Use when:</p> <ul> <li>Public verification required (consumers don't need signing capability)</li> <li>Key rotation needed (multiple active keys via JWKS)</li> <li>One-way trust: gateway signs, services verify</li> <li>Zero-trust architecture with distributed services</li> </ul> <p>Security properties:</p> <ul> <li>Strong asymmetric signatures with 32-byte private keys</li> <li>Public key can be distributed safely</li> <li>Supports key rotation via <code>kid</code> header</li> <li>Slightly slower than HS512 but still fast</li> </ul> <p>Environment detection (producer):</p> <pre><code>JWT_PRIVATE_JWK_NAME=GATEWAY_PRIVATE  # Points to private key binding\nJWT_KID=ed25519-2025-01               # Key ID for rotation\n</code></pre> <p>Environment detection (consumer):</p> <pre><code># Option 1: Inline public key (single key, no rotation)\nJWT_PUBLIC_JWK_NAME=GATEWAY_PUBLIC\n\n# Option 2: Service binding for JWKS (supports rotation)\nJWT_JWKS_SERVICE_NAME=GATEWAY_BINDING\n\n# Option 3: HTTP JWKS URL for external OIDC providers (TypeScript only)\nJWT_JWKS_URL=https://tenant.auth0.com/.well-known/jwks.json\n</code></pre>"},{"location":"core-concepts/#rsa-external-oidc-verification","title":"RSA (External OIDC Verification)","text":"<p>RS256, RS384, RS512 verification for external OIDC providers.</p> <p>Use when:</p> <ul> <li>Verifying tokens from Auth0, Okta, Google, Azure AD, or Cloudflare Access</li> <li>Gateway integrates with external identity providers</li> <li>Tokens are signed externally, only verification is needed</li> </ul> <p>Security properties:</p> <ul> <li>Verification-only (no signing capability)</li> <li>Supports key rotation via JWKS</li> <li>HTTPS-only URL fetching with caching</li> <li>TypeScript only (Python pending Cloudflare runtime improvements)</li> </ul> <p>Environment detection (consumer):</p> <pre><code>JWT_JWKS_URL=https://tenant.auth0.com/.well-known/jwks.json\nJWT_JWKS_CACHE_TTL_SECONDS=300  # Optional: default 5 minutes\n</code></pre> <p>Supported OIDC providers:</p> <ul> <li>Auth0: <code>https://tenant.auth0.com/.well-known/jwks.json</code></li> <li>Okta: <code>https://domain.okta.com/oauth2/default/v1/keys</code></li> <li>Google: <code>https://www.googleapis.com/oauth2/v3/certs</code></li> <li>Azure AD: <code>https://login.microsoftonline.com/tenant-id/discovery/v2.0/keys</code></li> <li>Cloudflare Access: <code>https://team.cloudflareaccess.com/cdn-cgi/access/certs</code></li> </ul>"},{"location":"core-concepts/#algorithm-design-philosophy","title":"Algorithm Design Philosophy","text":"<p>Reduced attack surface: Fewer algorithms means less code to audit and fewer potential vulnerabilities.</p> <p>Simplified key management: HS512 for simple deployments, EdDSA for complex ones. No need to choose between RSA key sizes, ECDSA curves, or other variants.</p> <p>Clear trade-offs: Each algorithm has an obvious use case. No analysis paralysis.</p>"},{"location":"core-concepts/#mode-detection","title":"Mode Detection","text":"<p>The kit automatically detects which algorithm to use based on environment variables. No manual configuration needed.</p> <p>Detection logic:</p> <pre><code>Producer (signing):\n  If JWT_PRIVATE_JWK* exists \u2192 EdDSA mode\n  Otherwise \u2192 HS512 mode\n\nConsumer (verification):\n  If JWT_PUBLIC_JWK* or JWT_JWKS_SERVICE* or JWT_JWKS_URL exists \u2192 EdDSA/RSA mode\n  Otherwise \u2192 HS512 mode\n</code></pre> <p>Note: EdDSA/RSA mode supports both EdDSA (Ed25519) and RSA (RS256/384/512) verification. The actual algorithm is auto-detected from the JWK structure or token header.</p> <p>Verification in code:</p> <p>TypeScript:</p> <pre><code>import { envMode } from '@chrislyons-dev/flarelette-jwt'\n\nconst mode = envMode('producer') // or 'consumer'\nconsole.log('Detected mode:', mode) // \"HS512\" or \"EdDSA\"\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import mode\n\ndetected = mode('producer')  # or 'consumer'\nprint(f'Detected mode: {detected}')  # \"HS512\" or \"EdDSA\"\n</code></pre>"},{"location":"core-concepts/#jwks-resolution-strategies","title":"JWKS Resolution Strategies","text":"<p>When verifying EdDSA or RSA tokens, the kit supports four strategies for obtaining the verification key. Each strategy has different trade-offs for security, performance, and operational complexity.</p>"},{"location":"core-concepts/#strategy-1-hs512-shared-secret","title":"Strategy 1: HS512 Shared Secret","text":"<p>Use case: Simplest configuration for trusted producer-consumer pairs.</p> <p>Configuration:</p> <pre><code>JWT_SECRET_NAME=MY_JWT_SECRET\n</code></pre> <p>Characteristics:</p> <ul> <li>Single secret shared between producer and consumer</li> <li>No key distribution complexity</li> <li>Fastest verification (symmetric)</li> <li>Requires mutual trust between services</li> </ul> <p>When to use: Internal services where both producer and consumer are under your control.</p>"},{"location":"core-concepts/#strategy-2-inline-public-jwk","title":"Strategy 2: Inline Public JWK","text":"<p>Use case: Single EdDSA verification key, no rotation needed.</p> <p>Configuration:</p> <pre><code>JWT_PUBLIC_JWK_NAME=GATEWAY_PUBLIC\n</code></pre> <p>Characteristics:</p> <ul> <li>Public key embedded in environment</li> <li>No network calls during verification</li> <li>No key rotation support (requires redeployment to update key)</li> <li>Works in both TypeScript and Python</li> </ul> <p>When to use: Internal services with infrequent key rotation, or Python Workers verifying EdDSA tokens.</p>"},{"location":"core-concepts/#strategy-3-service-binding-jwks","title":"Strategy 3: Service Binding JWKS","text":"<p>Use case: Internal key rotation with Worker-to-Worker RPC.</p> <p>Configuration:</p> <pre><code># Consumer wrangler.toml\n[[services]]\nbinding = \"GATEWAY_BINDING\"\nservice = \"jwt-gateway\"\n\n[vars]\nJWT_JWKS_SERVICE_NAME = \"GATEWAY_BINDING\"\n</code></pre> <p>Characteristics:</p> <ul> <li>Keys fetched from internal JWKS endpoint via Worker-to-Worker RPC</li> <li>Supports multiple active keys (key rotation)</li> <li>No public HTTP endpoint required</li> <li>Cached for 5 minutes</li> <li>TypeScript only</li> </ul> <p>When to use: Internal service mesh with key rotation requirements and no external OIDC provider.</p>"},{"location":"core-concepts/#strategy-4-http-jwks-url","title":"Strategy 4: HTTP JWKS URL","text":"<p>Use case: External OIDC provider verification (Auth0, Okta, Google, Azure AD).</p> <p>Configuration:</p> <pre><code>JWT_JWKS_URL=https://tenant.auth0.com/.well-known/jwks.json\nJWT_JWKS_CACHE_TTL_SECONDS=300  # Optional: default 5 minutes\n</code></pre> <p>Characteristics:</p> <ul> <li>Keys fetched from public HTTPS endpoint</li> <li>Supports multiple active keys (key rotation)</li> <li>HTTPS-only (except localhost for testing)</li> <li>Cached with configurable TTL</li> <li>TypeScript only</li> <li>5-second timeout, 100KB size limit</li> </ul> <p>When to use: Verifying tokens from external OIDC providers like Auth0, Okta, Google Workspace, Azure AD, or Cloudflare Access.</p>"},{"location":"core-concepts/#comparison-table","title":"Comparison Table","text":"Strategy Key Rotation Network Calls Python Support Use Case HS512 Shared \u274c \u274c \u2705 Trusted internal services Inline Public JWK \u274c \u274c \u2705 Single key, no rotation Service Binding \u2705 \u2705 (internal) \u274c Internal mesh with rotation HTTP JWKS URL \u2705 \u2705 (external) \u274c External OIDC providers"},{"location":"core-concepts/#secret-name-indirection","title":"Secret-Name Indirection","text":"<p>Instead of storing secrets directly in environment variables, reference the binding name. This enables proper secret management in Cloudflare Workers.</p>"},{"location":"core-concepts/#the-pattern","title":"The Pattern","text":"<p>Without indirection (insecure):</p> <pre><code># wrangler.toml - DON'T DO THIS\n[vars]\nJWT_SECRET = \"actual-secret-value-exposed\"  # \u274c Secret in version control\n</code></pre> <p>With indirection (secure):</p> <pre><code># wrangler.toml - Safe to commit\n[vars]\nJWT_SECRET_NAME = \"MY_JWT_SECRET\"  # \u2705 References binding, not value\nJWT_ISS = \"https://gateway.example.com\"\n</code></pre> <pre><code># Deploy secret separately\nwrangler secret put MY_JWT_SECRET\n# Paste secret when prompted\n</code></pre>"},{"location":"core-concepts/#how-it-works","title":"How It Works","text":"<p>Resolution order:</p> <ol> <li>Check if <code>JWT_SECRET_NAME</code> is set (e.g., <code>\"MY_JWT_SECRET\"</code>)</li> <li>If set, look up that environment variable (<code>env.MY_JWT_SECRET</code> or <code>os.environ['MY_JWT_SECRET']</code>)</li> <li>If not set, fall back to <code>JWT_SECRET</code> directly</li> </ol> <p>Applies to all secrets:</p> <ul> <li><code>JWT_SECRET_NAME</code> \u2192 <code>JWT_SECRET</code></li> <li><code>JWT_PRIVATE_JWK_NAME</code> \u2192 <code>JWT_PRIVATE_JWK</code></li> <li><code>JWT_PUBLIC_JWK_NAME</code> \u2192 <code>JWT_PUBLIC_JWK</code></li> <li><code>JWT_JWKS_SERVICE_NAME</code> \u2192 <code>JWT_JWKS_SERVICE</code></li> </ul> <p>Benefits:</p> <ul> <li>Secrets never appear in configuration files</li> <li>Same code works across environments (dev/stage/prod use different binding names)</li> <li>Supports Cloudflare's secret rotation workflows</li> </ul>"},{"location":"core-concepts/#environment-injection","title":"Environment Injection","text":"<p>Cloudflare Workers don't expose <code>process.env</code> (Node.js) or populate <code>os.environ</code> (Python) automatically. The kit provides adapters to inject the Worker environment.</p>"},{"location":"core-concepts/#typescript-adapter","title":"TypeScript Adapter","text":"<pre><code>import { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\n\nexport default {\n  async fetch(req, env) {\n    const jwt = makeKit(env) // Injects Worker env globally\n\n    const token = await jwt.sign({ sub: 'user123' })\n    const verified = await jwt.verify(token)\n\n    return new Response(JSON.stringify(verified))\n  },\n}\n</code></pre> <p>What it does:</p> <ol> <li>Extracts string variables and Fetcher service bindings from <code>env</code></li> <li>Stores vars in <code>globalThis.__FLARELETTE_ENV</code></li> <li>Stores services in <code>globalThis.__FLARELETTE_SERVICES</code></li> <li>All kit functions read from these globals</li> </ol>"},{"location":"core-concepts/#python-adapter","title":"Python Adapter","text":"<pre><code>from flarelette_jwt.adapters import apply_env_bindings\nfrom flarelette_jwt import sign, verify\n\nasync def on_fetch(request, env, ctx):\n    apply_env_bindings(env)  # Copy Worker env to os.environ\n\n    token = await sign({\"sub\": \"user123\"})\n    verified = await verify(token)\n\n    return Response.new(str(verified))\n</code></pre> <p>What it does:</p> <ol> <li>Iterates over Worker <code>env</code> mapping</li> <li>Copies string values to <code>os.environ</code></li> <li>All kit functions read from <code>os.environ</code></li> </ol> <p>Note: Python Workers don't support Fetcher service bindings for JWKS. Use inline <code>JWT_PUBLIC_JWK</code> instead.</p>"},{"location":"core-concepts/#token-structure","title":"Token Structure","text":""},{"location":"core-concepts/#header","title":"Header","text":"<pre><code>{\n  \"alg\": \"EdDSA\", // or \"HS512\"\n  \"typ\": \"JWT\",\n  \"kid\": \"ed25519-2025-01\" // Key ID (EdDSA only, for rotation)\n}\n</code></pre>"},{"location":"core-concepts/#payload-standard-claims","title":"Payload (Standard Claims)","text":"<pre><code>{\n  \"iss\": \"https://gateway.example.com\", // Issuer\n  \"aud\": \"api.example.com\", // Audience\n  \"sub\": \"user123\", // Subject (user ID)\n  \"iat\": 1704067200, // Issued at (Unix timestamp)\n  \"exp\": 1704068100, // Expiration (Unix timestamp)\n  \"jti\": \"a1b2c3d4\" // JWT ID (optional, for replay prevention)\n}\n</code></pre>"},{"location":"core-concepts/#payload-custom-claims","title":"Payload (Custom Claims)","text":"<pre><code>{\n  // Standard claims above, plus:\n  \"permissions\": [\"read:data\", \"write:data\"],\n  \"roles\": [\"user\", \"editor\"],\n  \"email\": \"user@example.com\",\n  \"tid\": \"tenant-123\", // Tenant ID (multi-tenant apps)\n  \"act\": {\n    // Actor claim (service delegation, RFC 8693)\n    \"sub\": \"gateway-service\"\n  }\n}\n</code></pre>"},{"location":"core-concepts/#verification-process","title":"Verification Process","text":"<p>When you call <code>verify()</code> or <code>checkAuth()</code>, the kit performs these checks in order:</p> <ol> <li>Signature verification \u2014 Validates cryptographic signature using detected algorithm</li> <li>Issuer check \u2014 <code>iss</code> claim must match <code>JWT_ISS</code></li> <li>Audience check \u2014 <code>aud</code> claim must match <code>JWT_AUD</code> (or be in list if multiple)</li> <li>Expiration check \u2014 Token must not be expired (<code>exp</code> &gt; current time - leeway)</li> <li>Not before check \u2014 If <code>nbf</code> claim present, token must be valid (<code>nbf</code> &lt; current time + leeway)</li> <li>Authorization checks \u2014 If using <code>checkAuth()</code>, validates permissions and roles</li> </ol> <p>Fail-silent behavior:</p> <ul> <li>Returns <code>null</code> (TypeScript) or <code>None</code> (Python) on any verification failure</li> <li>Never throws exceptions</li> <li>Simplifies error handling in request handlers</li> </ul> <p>Clock skew tolerance:</p> <ul> <li>Default 90 seconds leeway via <code>JWT_LEEWAY</code></li> <li>Applied to <code>exp</code>, <code>nbf</code>, and <code>iat</code> checks</li> <li>Accounts for time sync differences between services</li> </ul>"},{"location":"core-concepts/#cross-language-parity","title":"Cross-Language Parity","text":"<p>TypeScript and Python implementations are kept in sync:</p> Feature TypeScript Python HS512 signing \u2705 \u2705 HS512 verification \u2705 \u2705 EdDSA signing \u2705 \u274c (use Node gateway) EdDSA verification \u2705 \u2705 (inline JWK only) RSA verification \u2705 \u274c JWKS fetch \u2705 \u274c (inline JWK only) Service bindings \u2705 \u274c Secret-name indirection \u2705 \u2705 Policy builder \u2705 \u2705 CLI tools \u2705 \u2705 <p>Why Python limitations?</p> <ul> <li>EdDSA signing: WebCrypto API in Pyodide doesn't support Ed25519 private key operations</li> <li>JWKS fetch: No Fetcher service binding support in Workers Python runtime</li> <li>Recommended pattern: Use Node.js gateway for EdDSA signing, Python workers for verification</li> </ul>"},{"location":"core-concepts/#architecture-patterns","title":"Architecture Patterns","text":""},{"location":"core-concepts/#pattern-1-hs512-internal-services","title":"Pattern 1: HS512 Internal Services","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  HS512    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Service A  \u2502 \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502  Service B  \u2502\n\u2502  (signs)    \u2502  shared   \u2502  (verifies) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  secret   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use when: All services trust each other and can share a secret.</p>"},{"location":"core-concepts/#pattern-2-eddsa-gateway-services","title":"Pattern 2: EdDSA Gateway + Services","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  EdDSA    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Gateway    \u2502  signed   \u2502  Service 1  \u2502\n\u2502  (Node.js)  \u2502  tokens   \u2502  (TS/Py)    \u2502\n\u2502             \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502             \u2502\n\u2502  Signs with \u2502           \u2502  Verifies   \u2502\n\u2502  private    \u2502           \u2502  with       \u2502\n\u2502  key        \u2502           \u2502  public key \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                         \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2193\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502  Service 2  \u2502\n              \u2502  (TS/Py)    \u2502\n              \u2502             \u2502\n              \u2502  Verifies   \u2502\n              \u2502  with       \u2502\n              \u2502  public key \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use when: Gateway handles external auth, internal services only verify.</p>"},{"location":"core-concepts/#pattern-3-service-binding-jwks","title":"Pattern 3: Service Binding JWKS","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   JWT Gateway (Producer)     \u2502\n\u2502                              \u2502\n\u2502   - Signs tokens             \u2502\n\u2502   - Exposes JWKS endpoint    \u2502\n\u2502      (/.well-known/jwks.json)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                \u2502\n       \u2502 JWT token      \u2502 Service Binding\n       \u2502 (HTTP/auth)    \u2502 (JWKS fetch)\n       \u2502                \u2502\n   \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n   \u2502                        \u2502\n   \u25bc                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Consumer #1     \u2502      \u2502  Consumer #2     \u2502\n\u2502  (Worker)        \u2502      \u2502  (Worker)        \u2502\n\u2502                  \u2502      \u2502                  \u2502\n\u2502  - Receives JWT  \u2502      \u2502  - Receives JWT  \u2502\n\u2502  - Fetches JWKS  \u2502      \u2502  - Fetches JWKS  \u2502\n\u2502  - Verifies      \u2502      \u2502  - Verifies      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use when: Key rotation needed, multiple active keys, or zero-trust architecture.</p>"},{"location":"core-concepts/#next-topics","title":"Next Topics","text":"<ul> <li>Usage Guide \u2014 Complete API reference</li> <li>Service Delegation \u2014 RFC 8693 actor claims</li> <li>Cloudflare Workers \u2014 Workers deployment guide</li> <li>Security Guide \u2014 Cryptographic profiles and best practices</li> </ul>"},{"location":"explicit-config/","title":"Explicit Configuration API","text":"<p>New in v1.9.0: Pass configuration directly without environment variables</p>"},{"location":"explicit-config/#overview","title":"Overview","text":"<p>The explicit configuration API provides a way to use flarelette-jwt-kit without relying on environment variables or global state. This is ideal for:</p> <ul> <li>Development environments where setting up <code>.env</code> files and bindings is cumbersome</li> <li>Testing where you need isolated, reproducible JWT configurations</li> <li>Multi-tenant scenarios where different tokens need different configurations</li> <li>Debugging when you want explicit control over every JWT parameter</li> </ul>"},{"location":"explicit-config/#quick-start","title":"Quick Start","text":""},{"location":"explicit-config/#hs512-symmetric-example","title":"HS512 (Symmetric) Example","text":"<pre><code>import {\n  createHS512Config,\n  createTokenWithConfig,\n  verifyWithConfig,\n} from '@chrislyons-dev/flarelette-jwt'\n\n// Create configuration object (no environment variables needed!)\nconst config = createHS512Config('your-base64url-secret-here', {\n  iss: 'https://gateway.example.com',\n  aud: 'api.example.com',\n  ttlSeconds: 900,\n})\n\n// Sign a token\nconst token = await createTokenWithConfig(\n  {\n    sub: 'user123',\n    permissions: ['read:data'],\n  },\n  config\n)\n\n// Verify the token\nconst payload = await verifyWithConfig(token, config)\nconsole.log('User:', payload?.sub)\n</code></pre>"},{"location":"explicit-config/#eddsa-asymmetric-example","title":"EdDSA (Asymmetric) Example","text":"<pre><code>import {\n  createEdDSASignConfig,\n  createEdDSAVerifyConfig,\n  signWithConfig,\n  verifyWithConfig,\n} from '@chrislyons-dev/flarelette-jwt'\n\n// Producer configuration (signs tokens)\nconst signConfig = createEdDSASignConfig(\n  {\n    kty: 'OKP',\n    crv: 'Ed25519',\n    d: 'private-key-d-value',\n    x: 'public-key-x-value',\n  },\n  {\n    iss: 'https://gateway.example.com',\n    aud: 'api.example.com',\n  },\n  'ed25519-2025-01' // Key ID\n)\n\n// Consumer configuration (verifies tokens)\nconst verifyConfig = createEdDSAVerifyConfig(\n  {\n    kty: 'OKP',\n    crv: 'Ed25519',\n    x: 'public-key-x-value',\n  },\n  {\n    iss: 'https://gateway.example.com',\n    aud: 'api.example.com',\n  }\n)\n\n// Sign and verify\nconst token = await signWithConfig({ sub: 'user456' }, signConfig)\nconst payload = await verifyWithConfig(token, verifyConfig)\n</code></pre>"},{"location":"explicit-config/#api-reference","title":"API Reference","text":""},{"location":"explicit-config/#configuration-types","title":"Configuration Types","text":""},{"location":"explicit-config/#basejwtconfig","title":"<code>BaseJwtConfig</code>","text":"<p>Base configuration shared by all JWT operations:</p> <pre><code>interface BaseJwtConfig {\n  iss: string // Token issuer (iss claim)\n  aud: string | string[] // Token audience (aud claim)\n  ttlSeconds?: number // Token lifetime (default: 900 = 15 min)\n  leeway?: number // Clock skew tolerance (default: 90 sec)\n}\n</code></pre>"},{"location":"explicit-config/#hs512config","title":"<code>HS512Config</code>","text":"<p>Symmetric (shared secret) configuration:</p> <pre><code>interface HS512Config extends BaseJwtConfig {\n  alg: 'HS512'\n  secret: Uint8Array // Minimum 64 bytes (HS512 requirement)\n}\n</code></pre>"},{"location":"explicit-config/#eddsasignconfig","title":"<code>EdDSASignConfig</code>","text":"<p>Asymmetric signing configuration:</p> <pre><code>interface EdDSASignConfig extends BaseJwtConfig {\n  alg: 'EdDSA'\n  privateJwk: JWK // Private Ed25519 key\n  kid?: string // Key ID for rotation\n}\n</code></pre>"},{"location":"explicit-config/#eddsaverifyconfig","title":"<code>EdDSAVerifyConfig</code>","text":"<p>Asymmetric verification configuration:</p> <pre><code>interface EdDSAVerifyConfig extends BaseJwtConfig {\n  alg: 'EdDSA'\n  publicJwk: JWK // Public Ed25519 key\n}\n</code></pre>"},{"location":"explicit-config/#core-functions","title":"Core Functions","text":""},{"location":"explicit-config/#signwithconfigpayload-config-overrides","title":"<code>signWithConfig(payload, config, overrides?)</code>","text":"<p>Sign a JWT token with explicit configuration.</p> <p>Parameters:</p> <ul> <li><code>payload: JwtPayload</code> - Claims to include in token</li> <li><code>config: SignConfig</code> - HS512 or EdDSA sign configuration</li> <li><code>overrides?: Partial&lt;{ iss, aud, ttlSeconds }&gt;</code> - Per-call overrides</li> </ul> <p>Returns: <code>Promise&lt;string&gt;</code> - Signed JWT token</p>"},{"location":"explicit-config/#verifywithconfigtoken-config-overrides","title":"<code>verifyWithConfig(token, config, overrides?)</code>","text":"<p>Verify a JWT token with explicit configuration.</p> <p>Parameters:</p> <ul> <li><code>token: string</code> - JWT token to verify</li> <li><code>config: VerifyConfig</code> - HS512 or EdDSA verify configuration</li> <li><code>overrides?: Partial&lt;{ iss, aud, leeway }&gt;</code> - Per-call overrides</li> </ul> <p>Returns: <code>Promise&lt;JwtPayload | null&gt;</code> - Payload if valid, null if invalid</p>"},{"location":"explicit-config/#high-level-functions","title":"High-Level Functions","text":""},{"location":"explicit-config/#createtokenwithconfigclaims-config-overrides","title":"<code>createTokenWithConfig(claims, config, overrides?)</code>","text":"<p>Convenience wrapper around <code>signWithConfig()</code>.</p>"},{"location":"explicit-config/#createdelegatedtokenwithconfigoriginalpayload-actorservice-config-overrides","title":"<code>createDelegatedTokenWithConfig(originalPayload, actorService, config, overrides?)</code>","text":"<p>Create an RFC 8693 delegated token for service-to-service authentication.</p> <p>Example:</p> <pre><code>// Gateway receives Auth0 token\nconst auth0Payload = await verifyAuth0Token(externalToken)\n\n// Create delegated token for internal API\nconst internalToken = await createDelegatedTokenWithConfig(\n  auth0Payload,\n  'gateway-service', // Actor identifier\n  config\n)\n\n// Result includes:\n// - sub: original user\n// - act: { sub: 'gateway-service' }\n// - permissions: original permissions (no escalation)\n</code></pre>"},{"location":"explicit-config/#checkauthwithconfigtoken-config-authzopts-verifyoverrides","title":"<code>checkAuthWithConfig(token, config, authzOpts?, verifyOverrides?)</code>","text":"<p>Verify and authorize a token with policy enforcement.</p> <p>Example:</p> <pre><code>const user = await checkAuthWithConfig(token, config, {\n  require_all_permissions: ['read:data', 'write:data'],\n  require_any_permission: ['admin', 'editor'],\n  require_roles_all: ['user'],\n  predicates: [payload =&gt; payload.email?.endsWith('@example.com')],\n})\n\nif (user) {\n  console.log('Authorized:', user.sub, user.permissions)\n}\n</code></pre>"},{"location":"explicit-config/#helper-functions","title":"Helper Functions","text":""},{"location":"explicit-config/#createhs512configsecret-baseconfig","title":"<code>createHS512Config(secret, baseConfig)</code>","text":"<p>Create HS512 configuration from base64url-encoded secret.</p> <p>Parameters:</p> <ul> <li><code>secret: string</code> - Base64url-encoded secret (generates with <code>npx flarelette-jwt-secret</code>)</li> <li><code>baseConfig: Omit&lt;BaseJwtConfig, 'ttlSeconds' | 'leeway'&gt; &amp; Partial&lt;...&gt;</code> - Base configuration</li> </ul> <p>Returns: <code>HS512Config</code></p>"},{"location":"explicit-config/#createeddsasignconfigprivatejwk-baseconfig-kid","title":"<code>createEdDSASignConfig(privateJwk, baseConfig, kid?)</code>","text":"<p>Create EdDSA signing configuration from private JWK.</p> <p>Parameters:</p> <ul> <li><code>privateJwk: JWK | string</code> - Private JWK object or JSON string</li> <li><code>baseConfig</code> - Base configuration</li> <li><code>kid?: string</code> - Key ID</li> </ul> <p>Returns: <code>EdDSASignConfig</code></p>"},{"location":"explicit-config/#createeddsaverifyconfigpublicjwk-baseconfig","title":"<code>createEdDSAVerifyConfig(publicJwk, baseConfig)</code>","text":"<p>Create EdDSA verification configuration from public JWK.</p> <p>Parameters:</p> <ul> <li><code>publicJwk: JWK | string</code> - Public JWK object or JSON string</li> <li><code>baseConfig</code> - Base configuration</li> </ul> <p>Returns: <code>EdDSAVerifyConfig</code></p>"},{"location":"explicit-config/#use-cases","title":"Use Cases","text":""},{"location":"explicit-config/#development-environment","title":"Development Environment","text":"<p>Problem: Setting up <code>.env</code> files and Cloudflare bindings for local development is complex.</p> <p>Solution: Create config objects directly:</p> <pre><code>// No .env files needed\nconst devConfig = {\n  alg: 'HS512' as const,\n  secret: new Uint8Array(64), // 64-byte dev secret\n  iss: 'http://localhost:3000',\n  aud: ['http://localhost:3001', 'http://localhost:3002'],\n  ttlSeconds: 3600, // 1 hour\n}\n\n// All services use the same config\nconst token = await createTokenWithConfig({ sub: 'dev-user' }, devConfig)\n</code></pre>"},{"location":"explicit-config/#testing","title":"Testing","text":"<p>Problem: Tests need isolated JWT configurations without environment pollution.</p> <p>Solution: Each test gets its own config:</p> <pre><code>describe('JWT authentication', () =&gt; {\n  const testConfig = {\n    alg: 'HS512' as const,\n    secret: new Uint8Array(64),\n    iss: 'test-issuer',\n    aud: 'test-audience',\n  }\n\n  it('should verify valid tokens', async () =&gt; {\n    const token = await createTokenWithConfig({ sub: 'test' }, testConfig)\n    const payload = await verifyWithConfig(token, testConfig)\n    expect(payload?.sub).toBe('test')\n  })\n})\n</code></pre>"},{"location":"explicit-config/#multi-tenant-applications","title":"Multi-Tenant Applications","text":"<p>Problem: Different tenants need different JWT configurations.</p> <p>Solution: Store configurations per tenant:</p> <pre><code>const tenantConfigs = new Map&lt;string, HS512Config&gt;()\n\ntenantConfigs.set('tenant-a', createHS512Config(secretA, { ... }))\ntenantConfigs.set('tenant-b', createHS512Config(secretB, { ... }))\n\n// Use tenant-specific config\nconst config = tenantConfigs.get(tenantId)\nconst token = await createTokenWithConfig(claims, config)\n</code></pre>"},{"location":"explicit-config/#comparison-environment-based-vs-explicit","title":"Comparison: Environment-Based vs Explicit","text":""},{"location":"explicit-config/#environment-based-api-original","title":"Environment-Based API (Original)","text":"<pre><code>// Requires environment variables:\n// JWT_SECRET_NAME=MY_JWT_SECRET\n// JWT_ISS=https://gateway.example.com\n// JWT_AUD=api.example.com\n\nimport { sign, verify } from '@chrislyons-dev/flarelette-jwt'\n\n// Reads from environment automatically\nconst token = await sign({ sub: 'user123' })\nconst payload = await verify(token)\n</code></pre> <p>Pros:</p> <ul> <li>Zero configuration code</li> <li>Works great in production with Cloudflare bindings</li> <li>Automatic algorithm detection</li> </ul> <p>Cons:</p> <ul> <li>Requires <code>.env</code> setup for development</li> <li>Global state makes testing harder</li> <li>Cannot use multiple configurations simultaneously</li> </ul>"},{"location":"explicit-config/#explicit-configuration-api-new","title":"Explicit Configuration API (New)","text":"<pre><code>// No environment variables required\nimport {\n  signWithConfig,\n  verifyWithConfig,\n  createHS512Config,\n} from '@chrislyons-dev/flarelette-jwt'\n\nconst config = createHS512Config(secret, {\n  iss: 'https://gateway.example.com',\n  aud: 'api.example.com',\n})\n\nconst token = await signWithConfig({ sub: 'user123' }, config)\nconst payload = await verifyWithConfig(token, config)\n</code></pre> <p>Pros:</p> <ul> <li>No environment setup required</li> <li>Explicit and testable</li> <li>Multiple configurations in same process</li> <li>No global state</li> </ul> <p>Cons:</p> <ul> <li>More verbose</li> <li>Must manage configuration objects</li> </ul>"},{"location":"explicit-config/#migration-guide","title":"Migration Guide","text":""},{"location":"explicit-config/#from-environment-based-to-explicit","title":"From Environment-Based to Explicit","text":"<p>Before:</p> <pre><code>import { sign, verify } from '@chrislyons-dev/flarelette-jwt'\n\n// .env file required:\n// JWT_SECRET_NAME=MY_JWT_SECRET\n// JWT_ISS=https://gateway.example.com\n// JWT_AUD=api.example.com\n\nconst token = await sign({ sub: 'user' })\nconst payload = await verify(token)\n</code></pre> <p>After:</p> <pre><code>import {\n  signWithConfig,\n  verifyWithConfig,\n  createHS512Config,\n} from '@chrislyons-dev/flarelette-jwt'\n\nconst config = createHS512Config(process.env.MY_JWT_SECRET!, {\n  iss: 'https://gateway.example.com',\n  aud: 'api.example.com',\n})\n\nconst token = await signWithConfig({ sub: 'user' }, config)\nconst payload = await verifyWithConfig(token, config)\n</code></pre>"},{"location":"explicit-config/#gradual-migration","title":"Gradual Migration","text":"<p>You can use both APIs in the same project:</p> <pre><code>// Production: environment-based\nimport { sign, verify } from '@chrislyons-dev/flarelette-jwt'\n\n// Development: explicit config\nimport { signWithConfig, createHS512Config } from '@chrislyons-dev/flarelette-jwt'\n\nconst config =\n  process.env.NODE_ENV === 'production'\n    ? null // Use environment-based API\n    : createHS512Config('dev-secret', { iss: '...', aud: '...' })\n\nconst token = config ? await signWithConfig(claims, config) : await sign(claims)\n</code></pre>"},{"location":"explicit-config/#best-practices","title":"Best Practices","text":"<ol> <li>Use explicit API for development and testing - Simplifies setup</li> <li>Use environment-based API for production - Leverages Cloudflare bindings</li> <li>Store secrets securely - Never hardcode secrets in source code</li> <li>Validate configurations - Check secret length, issuer/audience values</li> <li>Reuse config objects - Create once, use many times</li> <li>Consider a config factory - Abstract configuration creation</li> </ol> <pre><code>// Example: Config factory\nfunction createJwtConfig(env: 'dev' | 'prod'): HS512Config {\n  if (env === 'dev') {\n    return {\n      alg: 'HS512',\n      secret: new Uint8Array(64), // 64-byte dev secret\n      iss: 'http://localhost:3000',\n      aud: 'http://localhost:3001',\n      ttlSeconds: 3600,\n    }\n  }\n\n  return createHS512Config(process.env.JWT_SECRET!, {\n    iss: process.env.JWT_ISS!,\n    aud: process.env.JWT_AUD!,\n  })\n}\n</code></pre>"},{"location":"explicit-config/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide - Basic JWT usage</li> <li>Security Guide - Cryptographic best practices</li> <li>Service Delegation - RFC 8693 patterns</li> <li>Cloudflare Workers - Production deployment</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide walks you through installing Flarelette JWT Kit and creating your first authenticated token.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#typescriptjavascript","title":"TypeScript/JavaScript","text":"<pre><code>npm install @chrislyons-dev/flarelette-jwt\n</code></pre> <p>Requirements:</p> <ul> <li>Node.js 18+ or Cloudflare Workers runtime</li> <li>TypeScript 5.0+ (if using TypeScript)</li> </ul>"},{"location":"getting-started/#python","title":"Python","text":"<pre><code>pip install flarelette-jwt\n</code></pre> <p>Requirements:</p> <ul> <li>Cloudflare Workers Python runtime (Pyodide)</li> <li>Python 3.11+ (Pyodide-based)</li> </ul> <p>Cloudflare Workers Only</p> <p>The Python package is designed exclusively for Cloudflare Workers Python runtime (Pyodide). It uses the <code>js</code> module to access WebCrypto APIs, which is not available in standard Python environments.</p>"},{"location":"getting-started/#your-first-token","title":"Your First Token","text":""},{"location":"getting-started/#step-1-configure-environment","title":"Step 1: Configure Environment","text":"<p>Create a <code>.env</code> file or configure your runtime environment:</p> <pre><code># Required configuration\nJWT_ISS=https://your-service.example.com\nJWT_AUD=your-api-audience\nJWT_SECRET_NAME=MY_JWT_SECRET\n\n# Optional (shown with defaults)\nJWT_TTL_SECONDS=900  # 15 minutes\nJWT_LEEWAY=90        # 90 seconds clock skew tolerance\n</code></pre>"},{"location":"getting-started/#step-2-generate-a-secret","title":"Step 2: Generate a Secret","text":"<p>For development:</p> <pre><code>npx flarelette-jwt-secret --len=64 --dotenv\n</code></pre> <p>This outputs a secure base64url-encoded secret:</p> <pre><code>JWT_SECRET=&lt;64-byte-base64url-string&gt;\n</code></pre> <p>For production (Cloudflare Workers):</p> <pre><code># Store secret in Cloudflare\nwrangler secret put MY_JWT_SECRET\n\n# Configure wrangler.toml to reference it\n[vars]\nJWT_SECRET_NAME = \"MY_JWT_SECRET\"\nJWT_ISS = \"https://gateway.example.com\"\nJWT_AUD = \"api.example.com\"\n</code></pre>"},{"location":"getting-started/#step-3-sign-your-first-token","title":"Step 3: Sign Your First Token","text":"<p>TypeScript:</p> <pre><code>import { sign, verify } from '@chrislyons-dev/flarelette-jwt'\n\nasync function example() {\n  // Create a token\n  const token = await sign({\n    sub: 'user123',\n    permissions: ['read:data', 'write:data'],\n    roles: ['user'],\n  })\n\n  console.log('Token:', token)\n\n  // Verify the token\n  const payload = await verify(token)\n  if (payload) {\n    console.log('Valid token for user:', payload.sub)\n    console.log('Permissions:', payload.permissions)\n  } else {\n    console.log('Invalid token')\n  }\n}\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import sign, verify\nimport asyncio\n\nasync def example():\n    # Create a token\n    token = await sign({\n        \"sub\": \"user123\",\n        \"permissions\": [\"read:data\", \"write:data\"],\n        \"roles\": [\"user\"]\n    })\n\n    print(f\"Token: {token}\")\n\n    # Verify the token\n    payload = await verify(token)\n    if payload:\n        print(f\"Valid token for user: {payload.get('sub')}\")\n        print(f\"Permissions: {payload.get('permissions')}\")\n    else:\n        print(\"Invalid token\")\n\nasyncio.run(example())\n</code></pre>"},{"location":"getting-started/#using-high-level-helpers","title":"Using High-Level Helpers","text":"<p>The kit provides high-level functions for common patterns.</p>"},{"location":"getting-started/#creating-tokens-with-options","title":"Creating Tokens with Options","text":"<p>TypeScript:</p> <pre><code>import { createToken } from '@chrislyons-dev/flarelette-jwt'\n\nconst token = await createToken(\n  {\n    sub: 'user123',\n    permissions: ['read:data'],\n  },\n  {\n    ttlSeconds: 600, // Override default TTL\n    aud: 'special-api', // Override default audience\n  }\n)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import create_token\n\ntoken = await create_token(\n    {\"sub\": \"user123\", \"permissions\": [\"read:data\"]},\n    ttl_seconds=600,  # Override default TTL\n    aud=\"special-api\"  # Override default audience\n)\n</code></pre>"},{"location":"getting-started/#authorization-with-policies","title":"Authorization with Policies","text":"<p>TypeScript:</p> <pre><code>import { checkAuth, policy } from '@chrislyons-dev/flarelette-jwt'\n\nconst authPolicy = policy()\n  .needAll('read:data', 'write:data')\n  .rolesAny('admin', 'editor')\n  .build()\n\nconst auth = await checkAuth(token, authPolicy)\nif (auth) {\n  console.log('Authorized user:', auth.sub)\n  console.log('Permissions:', auth.permissions)\n} else {\n  console.log('Authorization failed')\n}\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import check_auth, policy\n\nauth_policy = (\n    policy()\n    .need_all('read:data', 'write:data')\n    .roles_any('admin', 'editor')\n    .build()\n)\n\nauth = await check_auth(token, **auth_policy)\nif auth:\n    print(f\"Authorized user: {auth['sub']}\")\n    print(f\"Permissions: {auth['permissions']}\")\nelse:\n    print(\"Authorization failed\")\n</code></pre>"},{"location":"getting-started/#explicit-configuration-no-environment-variables","title":"Explicit Configuration (No Environment Variables)","text":"<p>New in v1.9.0: Pass configuration directly without environment setup</p> <p>For development, testing, or scenarios where environment variables are inconvenient, use the explicit configuration API:</p> <p>TypeScript:</p> <pre><code>import {\n  createHS512Config,\n  createTokenWithConfig,\n  verifyWithConfig,\n} from '@chrislyons-dev/flarelette-jwt'\n\n// Create config object (no environment variables needed)\nconst config = createHS512Config('your-base64url-secret-here', {\n  iss: 'https://gateway.example.com',\n  aud: 'api.example.com',\n  ttlSeconds: 900,\n})\n\n// Sign and verify\nconst token = await createTokenWithConfig(\n  {\n    sub: 'user123',\n    permissions: ['read:data'],\n  },\n  config\n)\n\nconst payload = await verifyWithConfig(token, config)\nconsole.log('User:', payload?.sub)\n</code></pre> <p>When to use:</p> <ul> <li>Development environments (skip .env setup)</li> <li>Testing (isolated configs per test)</li> <li>Multi-tenant apps (different configs per tenant)</li> </ul> <p>Full documentation: Explicit Configuration API</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts \u2014 Understand algorithms, modes, and architecture</li> <li>Usage Guide \u2014 Explore the complete API</li> <li>Cloudflare Workers \u2014 Deploy to Workers with proper secret management</li> <li>Security Guide \u2014 Learn cryptographic profiles and best practices</li> </ul>"},{"location":"getting-started/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/#jwt-secret-missing-error","title":"\"JWT secret missing\" Error","text":"<p>Cause: Environment variable not set or secret-name indirection not resolving.</p> <p>Solution:</p> <ol> <li>Verify <code>JWT_SECRET_NAME</code> points to an actual environment variable</li> <li>For Workers, ensure you ran <code>wrangler secret put &lt;NAME&gt;</code></li> <li>Check your wrangler.toml has the correct <code>JWT_SECRET_NAME</code> value</li> </ol>"},{"location":"getting-started/#algorithm-mismatch","title":"Algorithm Mismatch","text":"<p>Cause: Token was signed with one algorithm but consumer expects another.</p> <p>Solution:</p> <ul> <li>Verify both producer and consumer use the same environment configuration</li> <li>Check which mode is active using the <code>envMode()</code> function (TypeScript) or <code>mode()</code> function (Python)</li> <li>See Core Concepts for mode detection rules</li> </ul>"},{"location":"getting-started/#token-always-returns-null","title":"Token Always Returns Null","text":"<p>Cause: Verification failure due to mismatched claims or expired token.</p> <p>Solution:</p> <ol> <li>Check <code>JWT_ISS</code> and <code>JWT_AUD</code> match between producer and consumer</li> <li>Verify token hasn't expired (default 15 min TTL)</li> <li>Use <code>parse()</code> to inspect token contents without verification:    <pre><code>import { parse } from '@chrislyons-dev/flarelette-jwt'\nconst { header, payload } = parse(token)\nconsole.log('Algorithm:', header.alg)\nconsole.log('Issuer:', payload.iss)\nconsole.log('Expires:', new Date(payload.exp * 1000))\n</code></pre></li> </ol>"},{"location":"quick-start-demo/","title":"Quick Start: Using Explicit Config in flarelette-demo","text":""},{"location":"quick-start-demo/#problem-solved","title":"Problem Solved","text":"<p>Previously, using flarelette-jwt in the flarelette-demo required:</p> <ol> <li>Setting up <code>.dev.vars</code> files</li> <li>Using <code>bindEnv()</code> middleware to set global state</li> <li>Complex Miniflare configurations</li> <li>Dealing with <code>globalThis.__FLARELETTE_ENV</code> pollution</li> </ol> <p>With the new explicit configuration API, none of this is required!</p>"},{"location":"quick-start-demo/#gateway-integration","title":"Gateway Integration","text":""},{"location":"quick-start-demo/#step-1-create-jwt-config-at-startup","title":"Step 1: Create JWT Config at Startup","text":"<p>In <code>workers/gateway/src/index.ts</code>:</p> <pre><code>import { createHS512Config, type HS512Config } from '@chrislyons-dev/flarelette-jwt'\n\n// Create config once at app startup\nfunction createJwtConfig(env: Env): HS512Config {\n  return createHS512Config(env.JWT_SECRET, {\n    iss: 'http://localhost:8787',\n    aud: ['http://localhost:8788', 'http://localhost:8789', 'http://localhost:8790'],\n    ttlSeconds: 900, // 15 minutes\n  })\n}\n\n// Store config in app context\napp.use('*', async (c, next) =&gt; {\n  c.set('jwtConfig', createJwtConfig(c.env))\n  await next()\n})\n</code></pre>"},{"location":"quick-start-demo/#step-2-update-token-minting-in-authts","title":"Step 2: Update Token Minting in auth.ts","text":"<p>Replace the complex environment-based code:</p> <pre><code>// OLD - Complex environment setup\nimport { sign } from '@chrislyons-dev/flarelette-jwt'\nimport { bindEnv } from '@chrislyons-dev/flarelette-jwt/adapters'\n\n// Required bindEnv() middleware\napp.use('*', (c, next) =&gt; {\n  bindEnv(c.env)\n  return next()\n})\n\n// Still reads from global state\nconst token = await sign({ sub: 'user123' })\n</code></pre> <p>With simple, explicit code:</p> <pre><code>// NEW - Explicit and clean\nimport { signWithConfig } from '@chrislyons-dev/flarelette-jwt'\n\nexport async function mintInternalToken(c: Context, claims: JwtPayload) {\n  const config = c.get('jwtConfig') // Get from context\n  return await signWithConfig(claims, config)\n}\n\n// Usage in endpoint\napp.post('/auth/token', async c =&gt; {\n  const externalToken = c.req.header('Authorization')\n  const externalPayload = await verifyAuth0Token(externalToken)\n\n  // Mint internal token with explicit config\n  const token = await mintInternalToken(c, {\n    sub: externalPayload.sub,\n    email: externalPayload.email,\n    permissions: externalPayload.permissions,\n  })\n\n  return c.json({ token })\n})\n</code></pre>"},{"location":"quick-start-demo/#backend-service-integration","title":"Backend Service Integration","text":""},{"location":"quick-start-demo/#step-3-verify-tokens-in-backend-services","title":"Step 3: Verify Tokens in Backend Services","text":"<p>In <code>workers/content-service/src/index.ts</code>:</p> <pre><code>import { verifyWithConfig, createHS512Config } from '@chrislyons-dev/flarelette-jwt'\n\n// Create config at startup\nconst jwtConfig = createHS512Config(env.JWT_SECRET, {\n  iss: 'http://localhost:8787',\n  aud: 'http://localhost:8788', // This service's URL\n})\n\n// Middleware to verify tokens\napp.use('*', async (c, next) =&gt; {\n  const authHeader = c.req.header('Authorization')\n  if (!authHeader?.startsWith('Bearer ')) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  const token = authHeader.slice(7)\n  const payload = await verifyWithConfig(token, jwtConfig)\n\n  if (!payload) {\n    return c.json({ error: 'Invalid token' }, 401)\n  }\n\n  c.set('user', payload)\n  await next()\n})\n</code></pre>"},{"location":"quick-start-demo/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"quick-start-demo/#no-devvars-required","title":"No .dev.vars Required","text":"<p>Create a shared config for all services:</p> <pre><code>// dev-config.ts (shared across all workers)\nimport { type HS512Config } from '@chrislyons-dev/flarelette-jwt'\n\n// Simple dev secret - same for all services\nconst DEV_SECRET = Buffer.alloc(32, 42) // 32 bytes, all set to 42\n\nexport const DEV_JWT_CONFIG: HS512Config = {\n  alg: 'HS512',\n  secret: DEV_SECRET,\n  iss: 'http://localhost:8787',\n  aud: ['http://localhost:8788', 'http://localhost:8789', 'http://localhost:8790'],\n  ttlSeconds: 3600, // 1 hour for dev\n}\n</code></pre> <p>Use in all services:</p> <pre><code>import { signWithConfig, verifyWithConfig } from '@chrislyons-dev/flarelette-jwt'\nimport { DEV_JWT_CONFIG } from './dev-config'\n\n// Gateway\nconst token = await signWithConfig(claims, DEV_JWT_CONFIG)\n\n// Backend services\nconst payload = await verifyWithConfig(token, DEV_JWT_CONFIG)\n</code></pre>"},{"location":"quick-start-demo/#testing","title":"Testing","text":"<p>Write tests without any environment setup:</p> <pre><code>import { describe, it, expect } from 'vitest'\nimport { signWithConfig, verifyWithConfig } from '@chrislyons-dev/flarelette-jwt'\n\ndescribe('Gateway JWT minting', () =&gt; {\n  const testConfig = {\n    alg: 'HS512' as const,\n    secret: new Uint8Array(32),\n    iss: 'test-gateway',\n    aud: 'test-service',\n  }\n\n  it('should mint valid token', async () =&gt; {\n    const token = await signWithConfig({ sub: 'user123' }, testConfig)\n    const payload = await verifyWithConfig(token, testConfig)\n\n    expect(payload?.sub).toBe('user123')\n  })\n})\n</code></pre>"},{"location":"quick-start-demo/#migration-checklist","title":"Migration Checklist","text":"<ul> <li> Update gateway to use <code>createHS512Config()</code></li> <li> Replace <code>sign()</code> with <code>signWithConfig()</code></li> <li> Update backend services to use <code>verifyWithConfig()</code></li> <li> Remove <code>bindEnv()</code> middleware calls</li> <li> Simplify <code>.dev.vars</code> files (just need <code>JWT_SECRET</code> now)</li> <li> Remove custom Miniflare scripts (can use <code>wrangler dev</code> directly)</li> <li> Update tests to use explicit config</li> <li> Remove environment variable setup from tests</li> </ul>"},{"location":"quick-start-demo/#benefits-for-flarelette-demo","title":"Benefits for flarelette-demo","text":"<ol> <li>Simpler development - No complex environment setup</li> <li>Faster startup - No need to configure bindings</li> <li>Better testing - Isolated, reproducible tests</li> <li>Clearer code - Explicit configuration is self-documenting</li> <li>Easier debugging - No hidden global state</li> <li>Multiple configs - Can test different scenarios easily</li> </ol>"},{"location":"quick-start-demo/#example-complete-gateway-setup","title":"Example: Complete Gateway Setup","text":"<pre><code>// workers/gateway/src/index.ts\nimport { Hono } from 'hono'\nimport {\n  signWithConfig,\n  createHS512Config,\n  type HS512Config,\n} from '@chrislyons-dev/flarelette-jwt'\n\ntype Env = {\n  JWT_SECRET: string\n}\n\nconst app = new Hono&lt;{ Bindings: Env; Variables: { jwtConfig: HS512Config } }&gt;()\n\n// Create config middleware\napp.use('*', async (c, next) =&gt; {\n  const config = createHS512Config(c.env.JWT_SECRET, {\n    iss: 'http://localhost:8787',\n    aud: ['http://localhost:8788', 'http://localhost:8789'],\n    ttlSeconds: 900,\n  })\n  c.set('jwtConfig', config)\n  await next()\n})\n\n// Auth endpoint\napp.post('/auth/token', async c =&gt; {\n  const config = c.get('jwtConfig')\n\n  // Verify external token (Auth0, etc.)\n  const externalToken = c.req.header('Authorization')?.slice(7)\n  const externalPayload = await verifyAuth0Token(externalToken)\n\n  // Mint internal token\n  const token = await signWithConfig(\n    {\n      sub: externalPayload.sub,\n      email: externalPayload.email,\n      permissions: externalPayload.permissions,\n    },\n    config\n  )\n\n  return c.json({ token })\n})\n\nexport default app\n</code></pre>"},{"location":"quick-start-demo/#next-steps","title":"Next Steps","text":"<ol> <li>Install updated flarelette-jwt-kit: <code>npm install @chrislyons-dev/flarelette-jwt@latest</code></li> <li>Update gateway auth.ts to use explicit config</li> <li>Update backend services to use explicit config</li> <li>Remove bindEnv() middleware</li> <li>Simplify development environment</li> <li>Run tests to verify everything works</li> </ol> <p>The explicit configuration API makes flarelette-jwt-kit as simple to use as direct Web Crypto API, but with all the benefits of the library's features (delegation, policies, EdDSA support, etc.).</p>"},{"location":"security-guide/","title":"Security Guide","text":"<p>Comprehensive security baseline for Flarelette JWT Kit across HS512, EdDSA, and RSA profiles.</p>"},{"location":"security-guide/#trust-model-why-this-library-is-secure","title":"Trust Model: Why This Library Is Secure","text":"<p>Flarelette JWT Kit is designed from the ground up to prevent the most common JWT vulnerabilities. This section explains exactly how we mitigate historic attacks.</p>"},{"location":"security-guide/#protection-against-historic-jwt-vulnerabilities","title":"Protection Against Historic JWT Vulnerabilities","text":""},{"location":"security-guide/#1-algorithm-confusion-attacks-cve-2015-2951-alg-none","title":"1. Algorithm Confusion Attacks (CVE-2015-2951: <code>alg: none</code>)","text":"<p>Vulnerability: Attacker sets <code>alg: \"none\"</code> in token header, library accepts unsigned tokens.</p> <p>Our Protection:</p> <ul> <li>Mode determined by server configuration only \u2014 Verification mode (HS512 vs EdDSA/RSA) is chosen exclusively from server environment variables, never from the token header</li> <li>Strict algorithm whitelists \u2014 Each mode has an explicit whitelist of allowed algorithms:</li> <li>HS512 mode: <code>['HS512']</code> only</li> <li>EdDSA/RSA mode: <code>['EdDSA', 'RS256', 'RS384', 'RS512']</code> only</li> <li>No <code>none</code> algorithm support \u2014 The <code>none</code> algorithm is never included in any whitelist</li> <li>Token <code>alg</code> treated as untrusted input \u2014 The <code>alg</code> header must match the allowed algorithms for the selected mode. Mismatches are rejected.</li> </ul> <p>Code location: <code>src/verify.ts:145-152</code> (verification with explicit algorithm whitelist)</p>"},{"location":"security-guide/#2-algorithm-substitution-cve-2015-9235-rs256-public-key-as-hmac-secret","title":"2. Algorithm Substitution (CVE-2015-9235: RS256 Public Key as HMAC Secret)","text":"<p>Vulnerability: Attacker obtains RSA public key, creates HMAC-signed token, library verifies using public key as HMAC secret.</p> <p>Our Protection:</p> <ul> <li>Symmetric and asymmetric keys never shared \u2014 HS512 and EdDSA/RSA use completely separate code paths</li> <li>Configuration conflict detection \u2014 Throws error if both <code>JWT_SECRET</code> (HS512) and <code>JWT_PUBLIC_JWK</code>/<code>JWT_JWKS_*</code> (asymmetric) are configured</li> <li>Separate verification strategies \u2014 Key resolution uses strategy pattern with no code path allowing symmetric key to be used for asymmetric verification</li> </ul> <p>Code location: <code>src/config.ts:36-51</code> (mode conflict detection)</p> <pre><code>// SECURITY: Detect conflicting configuration\nif (hasHS512 &amp;&amp; hasAsymmetric) {\n  throw new Error(\n    'Configuration error: Both HS512 (JWT_SECRET) and asymmetric (JWT_PUBLIC_JWK/JWT_JWKS_*) secrets configured. Choose one to prevent algorithm confusion attacks.'\n  )\n}\n</code></pre>"},{"location":"security-guide/#3-jwks-injection-attacks","title":"3. JWKS Injection Attacks","text":"<p>Vulnerability: Token includes <code>jku</code> (JWKS URL) or <code>x5u</code> (X.509 URL) header, attacker points to malicious key server.</p> <p>Our Protection:</p> <ul> <li>JWKS URL pinned in server configuration \u2014 <code>JWT_JWKS_URL</code> is set in environment variables, never read from token headers</li> <li>No <code>jku</code>/<code>x5u</code> header support \u2014 These headers are completely ignored by the library</li> <li>Service binding JWKS \u2014 For Cloudflare Workers, JWKS is fetched via direct Worker-to-Worker RPC (no external URLs)</li> </ul> <p>Code location: <code>src/verify.ts:102-114</code> (HTTP JWKS with config-only URL)</p>"},{"location":"security-guide/#4-key-id-kid-injection-attacks","title":"4. Key ID (<code>kid</code>) Injection Attacks","text":"<p>Vulnerability: Attacker manipulates <code>kid</code> header to perform SQL injection, path traversal, or SSRF.</p> <p>Our Protection:</p> <ul> <li><code>kid</code> treated as pure lookup key \u2014 Used only for array/map lookups, never interpolated into SQL, file paths, or URLs</li> <li>JWKS array searched by equality \u2014 <code>kid</code> compared using strict equality (<code>===</code>), no string concatenation or interpolation</li> </ul> <p>Code location: <code>src/jwks.ts:219</code> (kid lookup with strict equality)</p> <pre><code>const jwk = jwks.find(k =&gt; k.kid === kid) // Safe: no interpolation\n</code></pre>"},{"location":"security-guide/#5-weak-hs512-secrets","title":"5. Weak HS512 Secrets","text":"<p>Vulnerability: Short HMAC secrets vulnerable to brute force attacks.</p> <p>Our Protection:</p> <ul> <li>64-byte minimum enforced \u2014 HS512 requires exactly 64 bytes (512 bits), matching SHA-512 digest size</li> <li>Fail-fast on short secrets \u2014 Configuration with secrets &lt; 64 bytes throws explicit error with remediation instructions</li> <li>CLI tool for secure generation \u2014 <code>npx flarelette-jwt-secret --len=64</code> generates cryptographically random secrets</li> </ul> <p>Code location: <code>src/config.ts:104-109</code>, <code>src/explicit.ts:139-142</code></p> <pre><code>// SECURITY: HS512 requires 64-byte minimum (SHA-512 digest size)\nif (buf.length &lt; 64) {\n  throw new Error(\n    `JWT secret too short: ${buf.length} bytes, need &gt;= 64 for HS512 (use 'npx flarelette-jwt-secret --len=64')`\n  )\n}\n</code></pre>"},{"location":"security-guide/#6-mode-confusion-within-library","title":"6. Mode Confusion Within Library","text":"<p>Vulnerability: Library allows both HS512 and asymmetric configuration simultaneously, creating unpredictable behavior.</p> <p>Our Protection:</p> <ul> <li>Single-mode enforcement \u2014 Configuration error thrown if both symmetric and asymmetric secrets detected</li> <li>Explicit mode detection \u2014 Mode determined once at startup based on environment variables</li> </ul> <p>Code location: <code>src/config.ts:47-51</code></p>"},{"location":"security-guide/#algorithm-pinning-at-key-import","title":"Algorithm Pinning at Key Import","text":"<p>When importing JWKs, the expected algorithm is provided explicitly to the <code>jose</code> library:</p> <pre><code>// Inline JWK import with explicit algorithm\nconst key = await importJWK(jwk, 'EdDSA') // Algorithm pinned at import time\n</code></pre> <p>This ensures keys cannot be repurposed for other algorithms, even within the same key family (e.g., cannot use Ed25519 key for RS256).</p> <p>Code location: <code>src/verify.ts:73</code></p>"},{"location":"security-guide/#fail-silent-pattern-with-observability","title":"Fail-Silent Pattern with Observability","text":"<p>Pattern: All verification failures return <code>null</code> to callers (never throw exceptions).</p> <p>Rationale:</p> <ul> <li>Simplifies error handling in HTTP request handlers</li> <li>Prevents information leakage via error messages</li> <li>Consistent interface for all failure modes</li> </ul> <p>Observability: While the library returns <code>null</code> for all failures, applications should log verification failures with structured metadata:</p> <pre><code>const payload = await verify(token)\nif (!payload) {\n  // Log failure with context (but not the token itself)\n  console.warn({\n    event: 'jwt_verification_failed',\n    iss: config.iss, // Expected issuer\n    aud: config.aud, // Expected audience\n    // DO NOT log the actual token\n  })\n  return new Response('Unauthorized', { status: 401 })\n}\n</code></pre> <p>Recommendation: Track verification failure rates in metrics/APM for anomaly detection.</p>"},{"location":"security-guide/#cryptographic-profiles","title":"Cryptographic Profiles","text":"<p>The kit supports three JWT algorithm profiles by design. Each has specific security properties and use cases.</p>"},{"location":"security-guide/#hs512-symmetric","title":"HS512 (Symmetric)","text":"Property Value Algorithm HMAC-SHA-512 Key material 64-byte base64url secret Security level ~256-bit Key distribution Shared secret between producer and consumer Use case Internal trusted services with shared secret <p>Security properties:</p> <ul> <li>Fast signing and verification</li> <li>Simple key management (single shared secret)</li> <li>No public key distribution needed</li> <li>Requires mutual trust between producer and consumer</li> </ul> <p>When to use:</p> <ul> <li>Both producer and consumer are trusted services</li> <li>Services can securely share a secret</li> <li>Simplest deployment with no key rotation requirements</li> </ul>"},{"location":"security-guide/#eddsa-ed25519","title":"EdDSA (Ed25519)","text":"Property Value Algorithm Ed25519 digital signature Key material 32-byte private key + public key (JSON Web Keys) Security level ~128-bit (quantum-safe path exists) Key distribution Public key distributed via JWKS or inline Use case One-way trust, public verification, key rotation <p>Security properties:</p> <ul> <li>Asymmetric: private key signs, public key verifies</li> <li>Public key can be distributed safely</li> <li>Supports key rotation via <code>kid</code> header</li> <li>Resistant to timing attacks</li> </ul> <p>When to use:</p> <ul> <li>Gateway signs, multiple services verify</li> <li>Key rotation required (multiple active keys)</li> <li>Zero-trust architecture with distributed services</li> <li>Public verification needed (consumers don't need signing capability)</li> </ul>"},{"location":"security-guide/#key-generation","title":"Key Generation","text":""},{"location":"security-guide/#hs512-secrets","title":"HS512 Secrets","text":"<p>Requirements:</p> <ul> <li>Minimum 64 bytes (512 bits)</li> <li>Cryptographically random</li> <li>Base64url-encoded for safe storage</li> </ul> <p>Generate with CLI:</p> <pre><code>npx flarelette-jwt-secret --len=64 --dotenv\n</code></pre> <p>Output:</p> <pre><code>JWT_SECRET=&lt;64-byte-base64url-string&gt;\n</code></pre> <p>Generate programmatically:</p> <p>TypeScript:</p> <pre><code>import { generateSecret } from '@chrislyons-dev/flarelette-jwt'\n\nconst secret = generateSecret(64)\nconsole.log(`JWT_SECRET=${secret}`)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import generate_secret\n\nsecret = generate_secret(64)\nprint(f\"JWT_SECRET={secret}\")\n</code></pre>"},{"location":"security-guide/#eddsa-keypairs","title":"EdDSA Keypairs","text":"<p>Generate with CLI:</p> <pre><code>npx flarelette-jwt-keygen --kid=ed25519-2025-01\n</code></pre> <p>Output:</p> <pre><code>{\n  \"kid\": \"ed25519-2025-01\",\n  \"publicJwk\": {\n    \"kty\": \"OKP\",\n    \"crv\": \"Ed25519\",\n    \"x\": \"&lt;base64url-public-key&gt;\",\n    \"kid\": \"ed25519-2025-01\"\n  },\n  \"privateJwk\": {\n    \"kty\": \"OKP\",\n    \"crv\": \"Ed25519\",\n    \"x\": \"&lt;base64url-public-key&gt;\",\n    \"d\": \"&lt;base64url-private-key&gt;\",\n    \"kid\": \"ed25519-2025-01\"\n  }\n}\n</code></pre> <p>Best practice for production:</p> <ul> <li>Generate keys during deployment CI (ephemeral keys no human ever sees)</li> <li>Store private key in secret binding immediately</li> <li>Distribute public key via JWKS or environment binding</li> </ul>"},{"location":"security-guide/#secret-storage","title":"Secret Storage","text":""},{"location":"security-guide/#never-commit-secrets","title":"Never Commit Secrets","text":"<p>\u274c Never do this:</p> <pre><code># wrangler.toml - DON'T COMMIT THIS\n[vars]\nJWT_SECRET = \"actual-secret-value\"  # \u274c Exposed in version control\n</code></pre> <p>\u2705 Use secret-name indirection:</p> <pre><code># wrangler.toml - Safe to commit\n[vars]\nJWT_SECRET_NAME = \"MY_JWT_SECRET\"  # References binding, not value\nJWT_ISS = \"https://gateway.example.com\"\nJWT_AUD = \"api.example.com\"\n</code></pre> <pre><code># Deploy secret separately\nwrangler secret put MY_JWT_SECRET\n# Paste secret when prompted\n</code></pre>"},{"location":"security-guide/#environment-scoping","title":"Environment Scoping","text":"<p>Use different secret bindings for each environment.</p> <pre><code># wrangler.dev.toml\n[vars]\nJWT_SECRET_NAME = \"JWT_SECRET_DEV\"\n\n# wrangler.staging.toml\n[vars]\nJWT_SECRET_NAME = \"JWT_SECRET_STAGING\"\n\n# wrangler.production.toml\n[vars]\nJWT_SECRET_NAME = \"JWT_SECRET_PROD\"\n</code></pre> <p>Deploy secrets to each environment:</p> <pre><code>wrangler secret put JWT_SECRET_DEV --env dev\nwrangler secret put JWT_SECRET_STAGING --env staging\nwrangler secret put JWT_SECRET_PROD --env production\n</code></pre>"},{"location":"security-guide/#eddsa-key-distribution","title":"EdDSA Key Distribution","text":"<p>Production (Service Binding - Recommended):</p> <ol> <li>Deploy JWT gateway with JWKS endpoint and public key</li> <li>Configure consumer workers with service binding</li> <li>Keys fetched via direct Worker-to-Worker RPC (private, low-latency)</li> </ol> <p>Benefits:</p> <ul> <li>No public HTTP endpoint required</li> <li>Lower latency (direct RPC, no DNS/TLS overhead)</li> <li>Better security (private Worker communication only)</li> <li>Integrated with Cloudflare routing</li> </ul> <p>Development/Offline (Inline JWK):</p> <ol> <li>Deploy public key directly to consumer environment</li> <li>Configure <code>JWT_PUBLIC_JWK_NAME</code> pointing to secret binding</li> <li>Note: Requires redeployment for key rotation, no JWKS support</li> </ol> <p>Optional: Thumbprint Pinning</p> <p>For additional security, pin trusted key thumbprints:</p> <pre><code>JWT_ALLOWED_THUMBPRINTS=abc123def456,789ghi012jkl\n</code></pre> <p>Only keys matching these thumbprints will be accepted for verification.</p>"},{"location":"security-guide/#key-rotation","title":"Key Rotation","text":""},{"location":"security-guide/#hs512-rotation","title":"HS512 Rotation","text":"<p>Process:</p> <ol> <li>Generate new secret</li> <li>Deploy new secret to producer and all consumers</li> <li>Start signing with new secret</li> <li>Wait for maximum token TTL (default 15 min)</li> <li>Remove old secret</li> </ol> <p>Downtime: None (if consumers support both secrets during transition)</p> <p>Frequency: Rotate at least every 90 days or immediately on suspicion of compromise.</p>"},{"location":"security-guide/#eddsa-rotation","title":"EdDSA Rotation","text":"<p>Process:</p> <ol> <li>Generate new keypair with new <code>kid</code></li> <li>Publish new JWKS including both old and new public keys</li> <li>Update producer to sign with new key</li> <li>Allow dual verification during TTL window</li> <li>After TTL expires, remove old key from JWKS</li> </ol> <p>Example:</p> <p>Before rotation (JWKS):</p> <pre><code>{\n  \"keys\": [\n    { \"kid\": \"ed25519-2025-01\", \"kty\": \"OKP\", ... }\n  ]\n}\n</code></pre> <p>During rotation (both keys active):</p> <pre><code>{\n  \"keys\": [\n    { \"kid\": \"ed25519-2025-01\", \"kty\": \"OKP\", ... },\n    { \"kid\": \"ed25519-2025-02\", \"kty\": \"OKP\", ... }\n  ]\n}\n</code></pre> <p>After rotation (old key removed):</p> <pre><code>{\n  \"keys\": [\n    { \"kid\": \"ed25519-2025-02\", \"kty\": \"OKP\", ... }\n  ]\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Zero downtime</li> <li>Consumers automatically fetch new keys</li> <li>No consumer redeployment needed</li> <li>Full audit trail via <code>kid</code> header</li> </ul>"},{"location":"security-guide/#token-issuance","title":"Token Issuance","text":""},{"location":"security-guide/#automatic-claims","title":"Automatic Claims","text":"<p>These claims are automatically populated:</p> <ul> <li><code>iss</code> \u2014 Token issuer (from <code>JWT_ISS</code>)</li> <li><code>aud</code> \u2014 Token audience (from <code>JWT_AUD</code>)</li> <li><code>iat</code> \u2014 Issued at (current timestamp)</li> <li><code>exp</code> \u2014 Expiration (current timestamp + TTL)</li> <li><code>jti</code> \u2014 JWT ID (optional, for replay prevention)</li> </ul>"},{"location":"security-guide/#manual-claims","title":"Manual Claims","text":"<p>Add custom claims with user identity and authorization:</p> <pre><code>const token = await sign({\n  sub: 'user123', // Subject (user ID)\n  permissions: ['read:data'], // Permission strings\n  roles: ['user', 'editor'], // Role strings\n  email: 'user@example.com', // OIDC standard claim\n  tid: 'tenant-123', // Multi-tenant apps\n})\n</code></pre>"},{"location":"security-guide/#minimal-claims-principle","title":"Minimal Claims Principle","text":"<p>Only include claims necessary for authorization decisions. Never include:</p> <ul> <li>Passwords or password hashes</li> <li>Credit card numbers or payment information</li> <li>Social security numbers or national IDs</li> <li>Full medical records</li> <li>Large datasets (keep tokens &lt; 8KB)</li> </ul> <p>Why: Tokens are transmitted with every request and logged in various places. Treat them as semi-public.</p>"},{"location":"security-guide/#token-lifetime","title":"Token Lifetime","text":"<p>Default: 900 seconds (15 minutes)</p> <p>Recommendation:</p> <ul> <li>External-facing APIs: 15-60 minutes</li> <li>Internal service tokens: 5-15 minutes</li> <li>Delegated tokens: 5 minutes</li> </ul> <p>Configure via:</p> <pre><code>JWT_TTL_SECONDS=300  # 5 minutes\n</code></pre> <p>Or override per-token:</p> <pre><code>const token = await createToken({ sub: 'user123' }, { ttlSeconds: 300 })\n</code></pre>"},{"location":"security-guide/#token-validation","title":"Token Validation","text":""},{"location":"security-guide/#automatic-verification","title":"Automatic Verification","text":"<p>When calling <code>verify()</code> or <code>checkAuth()</code>, these checks are performed:</p> <ol> <li>Signature verification \u2014 Cryptographic signature valid for detected algorithm</li> <li>Issuer check \u2014 <code>iss</code> matches <code>JWT_ISS</code></li> <li>Audience check \u2014 <code>aud</code> matches <code>JWT_AUD</code></li> <li>Expiration check \u2014 Token not expired (<code>exp</code> &gt; now - leeway)</li> <li>Not before check \u2014 If <code>nbf</code> present, token is valid (<code>nbf</code> &lt; now + leeway)</li> </ol>"},{"location":"security-guide/#clock-skew-tolerance","title":"Clock Skew Tolerance","text":"<p>Default leeway: 90 seconds</p> <p>Accounts for:</p> <ul> <li>Time sync differences between services</li> <li>Network latency</li> <li>Clock drift</li> </ul> <p>Configure via:</p> <pre><code>JWT_LEEWAY=120  # 2 minutes\n</code></pre> <p>Or override per-verification:</p> <pre><code>const payload = await verify(token, { leeway: 120 })\n</code></pre> <p>Security consideration: Keep leeway \u2264 90 seconds to avoid excessive expiry drift.</p>"},{"location":"security-guide/#algorithm-verification","title":"Algorithm Verification","text":"<p>The kit rejects tokens with unexpected <code>alg</code> headers. This prevents algorithm substitution attacks.</p> <p>Example: If environment detects HS512 mode, EdDSA tokens are rejected (and vice versa).</p>"},{"location":"security-guide/#replay-prevention-optional","title":"Replay Prevention (Optional)","text":"<p>For APIs requiring replay prevention, store <code>jti</code> in a short-TTL key-value store.</p> <pre><code>import { checkAuth } from '@chrislyons-dev/flarelette-jwt'\n\nconst auth = await checkAuth(token, policy().build())\nif (!auth) {\n  return new Response('Unauthorized', { status: 401 })\n}\n\n// Check if token was already used\nconst jti = auth.payload.jti\nif (await kv.get(`used:${jti}`)) {\n  return new Response('Token already used', { status: 403 })\n}\n\n// Mark token as used (expires with token TTL)\nawait kv.put(`used:${jti}`, 'true', {\n  expirationTtl: auth.payload.exp - Date.now() / 1000,\n})\n</code></pre>"},{"location":"security-guide/#transport-security","title":"Transport Security","text":""},{"location":"security-guide/#tls-everywhere","title":"TLS Everywhere","text":"<p>Never transmit tokens over plaintext HTTP. Always use HTTPS/TLS for:</p> <ul> <li>External API requests</li> <li>Internal service-to-service communication</li> <li>JWKS endpoint (if not using service bindings)</li> </ul>"},{"location":"security-guide/#authorization-header","title":"Authorization Header","text":"<p>\u2705 Correct:</p> <pre><code>Authorization: Bearer &lt;jwt-token&gt;\n</code></pre> <p>\u274c Never:</p> <ul> <li>Query parameters: <code>?token=&lt;jwt&gt;</code> (logged in access logs, proxy logs, browser history)</li> <li>Request body: <code>{\"token\": \"&lt;jwt&gt;\"}</code> (unnecessarily verbose)</li> <li>Cookies: (unless specifically designed for cookie-based auth with CSRF protection)</li> </ul>"},{"location":"security-guide/#logging-practices","title":"Logging Practices","text":"<p>Never log entire tokens. Log only non-sensitive parts:</p> <p>\u2705 Safe to log:</p> <pre><code>console.log({\n  jti: payload.jti, // JWT ID\n  sub: payload.sub, // Subject (user ID)\n  iss: payload.iss, // Issuer\n  aud: payload.aud, // Audience\n  exp: payload.exp, // Expiration\n  action: 'read:data', // Action performed\n})\n</code></pre> <p>\u274c Never log:</p> <pre><code>console.log(`Token: ${token}`) // \u274c Full token exposed\nconsole.log(`Bearer ${token}`) // \u274c Full token exposed\n</code></pre> <p>Redact in APM and telemetry:</p> <ul> <li>Configure log redaction rules for <code>Authorization</code> headers</li> <li>Use allowlists for logged fields (never log entire objects containing tokens)</li> </ul>"},{"location":"security-guide/#time-and-clock-skew","title":"Time and Clock Skew","text":""},{"location":"security-guide/#time-synchronization","title":"Time Synchronization","text":"<p>Depend on platform time sync:</p> <ul> <li>Cloudflare Workers: NTP-backed, reliable</li> <li>Node.js/Python: Ensure host has NTP configured</li> </ul>"},{"location":"security-guide/#leeway-configuration","title":"Leeway Configuration","text":"<p>Keep leeway \u2264 90 seconds to prevent excessive expiry drift while accounting for:</p> <ul> <li>Network latency (typically &lt; 1 second)</li> <li>Clock drift (NTP keeps this minimal)</li> <li>Service restart time skew</li> </ul> <p>Balance:</p> <ul> <li>Too low: Legitimate tokens rejected due to minor clock differences</li> <li>Too high: Expired tokens accepted for too long</li> </ul>"},{"location":"security-guide/#dependency-security","title":"Dependency Security","text":""},{"location":"security-guide/#typescript-dependencies","title":"TypeScript Dependencies","text":"<ul> <li><code>jose</code> library: Pinned version for cryptographic operations</li> <li>Review changelogs before upgrading</li> <li>Run <code>npm audit</code> regularly</li> </ul>"},{"location":"security-guide/#python-dependencies","title":"Python Dependencies","text":"<ul> <li>Zero external crypto dependencies \u2014 uses WebCrypto API directly</li> <li>Stdlib only \u2014 reduces supply chain risk</li> </ul>"},{"location":"security-guide/#lockfile-management","title":"Lockfile Management","text":"<p>Commit lockfiles:</p> <ul> <li><code>package-lock.json</code> (npm)</li> <li><code>yarn.lock</code> (Yarn)</li> <li><code>pyproject.toml</code> (Python)</li> </ul> <p>Benefits:</p> <ul> <li>Reproducible builds</li> <li>Security scanning can detect vulnerable versions</li> <li>Prevents unexpected dependency changes</li> </ul>"},{"location":"security-guide/#automated-updates","title":"Automated Updates","text":"<p>Use Dependabot or Renovate for automated dependency updates:</p> <pre><code># .github/dependabot.yml\nversion: 2\nupdates:\n  - package-ecosystem: 'npm'\n    directory: '/'\n    schedule:\n      interval: 'weekly'\n\n  - package-ecosystem: 'pip'\n    directory: '/packages/flarelette-jwt-py'\n    schedule:\n      interval: 'weekly'\n</code></pre>"},{"location":"security-guide/#testing-and-cicd","title":"Testing and CI/CD","text":""},{"location":"security-guide/#required-test-coverage","title":"Required Test Coverage","text":"<p>Unit tests must cover:</p> <ul> <li>Signature verification (positive and negative cases)</li> <li>Claim validation (<code>iss</code>, <code>aud</code>, <code>exp</code>, <code>nbf</code> with leeway)</li> <li>Authorization logic (permissions, roles, predicates)</li> <li>Mode detection (HS512 vs EdDSA based on environment)</li> <li>Secret-name indirection (resolution and fallback)</li> </ul>"},{"location":"security-guide/#static-analysis","title":"Static Analysis","text":"<p>Run these checks in CI:</p> <ul> <li>ESLint (TypeScript/JavaScript)</li> <li>Ruff (Python linting)</li> <li>mypy (Python type checking)</li> <li>TypeScript compiler (type checking)</li> </ul>"},{"location":"security-guide/#secret-scanning","title":"Secret Scanning","text":"<p>Enable secret scanning to prevent committed secrets:</p> <ul> <li>Gitleaks (open source)</li> <li>GitHub Advanced Security (GitHub)</li> <li>GitLab Secret Detection (GitLab)</li> </ul> <p>Example Gitleaks config:</p> <pre><code># .gitleaks.toml\n[[rules]]\nid = \"jwt-secrets\"\ndescription = \"JWT secrets and keys\"\nregex = '''JWT_(SECRET|PRIVATE_JWK|PUBLIC_JWK|JWKS_URL)\\s*=\\s*[\"']?[A-Za-z0-9_\\-+/={}:,\"\\.]{32,}[\"']?'''\n</code></pre>"},{"location":"security-guide/#hardening-checklist","title":"Hardening Checklist","text":"<p>Before deploying to production:</p> <ul> <li> HS512 or EdDSA explicitly enforced (not both in same environment)</li> <li> Secrets stored as Cloudflare bindings (<code>*_NAME</code> pattern)</li> <li> TTL \u2264 15 minutes; leeway \u2264 90 seconds</li> <li> <code>JWT_AUD</code> is specific per service (no wildcard audiences) \u2014 prevents token reuse between services</li> <li> No tokens in logs, URLs, or version control</li> <li> Minimal claims principle applied (no PII unless necessary)</li> <li> Rotation policy documented and tested (both HS512 and EdDSA)</li> <li> Thumbprint pinning configured (if using EdDSA with strict requirements)</li> <li> CI secret scan enabled</li> <li> Dependencies pinned in lockfiles</li> <li> Incident response runbook prepared</li> <li> TLS everywhere (no plaintext transmission)</li> <li> Authorization header used (<code>Authorization: Bearer</code>)</li> <li> Test coverage includes security-critical paths</li> </ul>"},{"location":"security-guide/#incident-response","title":"Incident Response","text":""},{"location":"security-guide/#on-leak-or-compromise","title":"On Leak or Compromise","text":"<p>Immediate actions:</p> <ol> <li>Rotate secrets/keys immediately</li> <li>Revoke sessions by shortening TTL and reissuing tokens</li> <li>Review access logs for suspicious activity</li> <li>Notify affected users if PII exposed</li> </ol> <p>Investigation:</p> <ol> <li>Identify scope of compromise (which secrets, how long exposed)</li> <li>Review logs for unusual patterns</li> <li>Check for permission escalation attempts</li> </ol> <p>Post-incident:</p> <ol> <li>Document root cause</li> <li>Update security procedures</li> <li>Add detection for similar incidents</li> <li>Consider additional controls (e.g., replay prevention, stricter TTLs)</li> </ol>"},{"location":"security-guide/#audit-logging","title":"Audit Logging","text":"<p>Log sufficient context for forensics without logging tokens:</p> <pre><code>console.log({\n  timestamp: new Date().toISOString(),\n  jti: payload.jti, // JWT ID\n  sub: payload.sub, // Subject\n  iss: payload.iss, // Issuer\n  aud: payload.aud, // Audience\n  iat: payload.iat, // Issued at\n  exp: payload.exp, // Expiration\n  actor: payload.act?.sub, // Actor service (if delegated)\n  action: 'read:sensitive', // Action performed\n  result: 'success', // Outcome\n  ip: requestIP, // Client IP (if applicable)\n})\n</code></pre>"},{"location":"security-guide/#threat-model","title":"Threat Model","text":""},{"location":"security-guide/#threats-mitigated","title":"Threats Mitigated","text":"<ul> <li>Token forgery \u2014 Cryptographic signature prevents creating valid tokens without secret/private key</li> <li>Algorithm substitution \u2014 Kit rejects tokens with unexpected <code>alg</code> headers</li> <li>Expired token reuse \u2014 Expiration checks with leeway prevent use of expired tokens</li> <li>Clock skew exploitation \u2014 Leeway limited to 90 seconds by default</li> <li>Permission escalation \u2014 Delegated tokens preserve original permissions, no escalation</li> <li>Replay attacks \u2014 Optional <code>jti</code> tracking in KV store</li> </ul>"},{"location":"security-guide/#threats-not-mitigated","title":"Threats Not Mitigated","text":"<p>Token theft:</p> <ul> <li>If attacker obtains valid token, they can use it until expiration</li> <li>Mitigate with: Short TTLs (5-15 min), TLS everywhere, secure storage</li> </ul> <p>Compromised secret/private key:</p> <ul> <li>Attacker can forge tokens indefinitely</li> <li>Mitigate with: Secret rotation, access controls, ephemeral keys, HSM storage</li> </ul> <p>Side-channel attacks:</p> <ul> <li>Timing attacks on signature verification (EdDSA resistant, HS512 uses constant-time comparisons)</li> <li>Mitigate with: Use vetted crypto libraries (<code>jose</code>, WebCrypto)</li> </ul> <p>Distributed denial of service:</p> <ul> <li>Signature verification is computationally expensive</li> <li>Mitigate with: Rate limiting, WAF rules, valid token caching</li> </ul>"},{"location":"security-guide/#references","title":"References","text":"<ul> <li>RFC 7519: JSON Web Token (JWT)</li> <li>RFC 7517: JSON Web Key (JWK)</li> <li>RFC 8693: OAuth 2.0 Token Exchange</li> <li>OWASP JWT Cheat Sheet</li> <li>Cloudflare Workers Security</li> </ul> <p>Questions or security concerns? Open a security issue or contact the maintainers directly.</p>"},{"location":"service-delegation/","title":"Service Delegation","text":"<p>Zero-trust service-to-service authentication using RFC 8693 actor claims.</p>"},{"location":"service-delegation/#the-problem","title":"The Problem","text":"<p>In a zero-trust microservices architecture, external tokens (like Auth0 JWTs) should not propagate beyond the edge. Instead, the gateway mints short-lived internal tokens for service-to-service communication.</p> <p>Challenge: How do internal services know which service is acting on behalf of the original user?</p> <p>Solution: RFC 8693 actor claims \u2014 tokens declare \"I'm <code>&lt;service&gt;</code> acting on behalf of <code>&lt;user&gt;</code>\".</p>"},{"location":"service-delegation/#actor-claims-rfc-8693","title":"Actor Claims (RFC 8693)","text":"<p>The <code>act</code> (actor) claim identifies a service acting on behalf of another principal.</p> <p>Structure:</p> <pre><code>{\n  \"sub\": \"user@example.com\", // Original end user\n  \"permissions\": [\"read:data\"], // Original permissions (no escalation)\n  \"act\": {\n    \"sub\": \"gateway-service\" // Service acting on behalf of user\n  }\n}\n</code></pre> <p>For delegation chains (service calling another service):</p> <pre><code>{\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\"],\n  \"act\": {\n    \"sub\": \"api-service\", // Current actor\n    \"act\": {\n      \"sub\": \"gateway-service\" // Previous actor (nested)\n    }\n  }\n}\n</code></pre>"},{"location":"service-delegation/#creating-delegated-tokens","title":"Creating Delegated Tokens","text":"<p>Use <code>createDelegatedToken()</code> to mint tokens for internal service communication.</p>"},{"location":"service-delegation/#typescript","title":"TypeScript","text":"<pre><code>import { createDelegatedToken } from '@chrislyons-dev/flarelette-jwt'\n\n// Gateway receives external token (e.g., from Auth0)\nconst externalPayload = await verifyAuth0Token(externalToken)\n\n// Create internal token for API service\nconst internalToken = await createDelegatedToken(\n  externalPayload, // Original verified payload\n  'gateway-service', // Actor service identifier\n  {\n    aud: 'internal-api', // Internal audience\n    ttlSeconds: 300, // Short-lived (5 min)\n  }\n)\n\n// Pass internal token to downstream service\nconst response = await fetch('https://api.internal', {\n  headers: { Authorization: `Bearer ${internalToken}` },\n})\n</code></pre>"},{"location":"service-delegation/#python","title":"Python","text":"<pre><code>from flarelette_jwt import create_delegated_token\n\n# Gateway receives external token\nexternal_payload = await verify_auth0_token(external_token)\n\n# Create internal token for API service\ninternal_token = await create_delegated_token(\n    external_payload,         # Original verified payload\n    \"gateway-service\",        # Actor service identifier\n    aud=\"internal-api\",       # Internal audience\n    ttl_seconds=300           # Short-lived (5 min)\n)\n\n# Pass internal token to downstream service\nresponse = await fetch(\"https://api.internal\", {\n    \"headers\": {\"Authorization\": f\"Bearer {internal_token}\"}\n})\n</code></pre>"},{"location":"service-delegation/#what-gets-preserved","title":"What Gets Preserved","text":"<p><code>createDelegatedToken()</code> automatically preserves identity and authorization context:</p> <p>Always copied:</p> <ul> <li><code>sub</code> \u2014 Original user identifier</li> <li><code>permissions</code> \u2014 Original permission list (no escalation)</li> <li><code>roles</code> \u2014 Original role list</li> </ul> <p>Conditionally copied (if present):</p> <ul> <li><code>email</code> \u2014 User email address</li> <li><code>name</code> \u2014 User display name</li> <li><code>groups</code> \u2014 Group memberships</li> <li><code>tid</code> \u2014 Tenant ID (multi-tenant apps)</li> <li><code>org_id</code> \u2014 Organization ID</li> <li><code>department</code> \u2014 Department/division</li> </ul> <p>Never copied:</p> <ul> <li>External token fields (<code>exp</code>, <code>iat</code>, <code>nbf</code>, <code>jti</code>) \u2014 New values generated</li> <li>Provider-specific fields \u2014 Not relevant for internal tokens</li> </ul>"},{"location":"service-delegation/#permission-preservation","title":"Permission Preservation","text":"<p>Critical security property: no permission escalation.</p> <pre><code>// External Auth0 token\n{\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\"]  // Limited scope\n}\n\n// Internal delegated token\n{\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\"],  // \u2705 Same permissions, no escalation\n  \"act\": { \"sub\": \"gateway-service\" }\n}\n\n// \u274c WRONG \u2014 Never do this\nconst badToken = await sign({\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\", \"admin:all\"],  // \u274c Escalation!\n  \"act\": { \"sub\": \"gateway-service\" }\n})\n</code></pre> <p>Why it matters:</p> <ul> <li>External auth providers control original permissions</li> <li>Internal services cannot grant additional permissions</li> <li>Prevents compromised services from escalating privileges</li> </ul>"},{"location":"service-delegation/#delegation-chains","title":"Delegation Chains","text":"<p>When services call other services, the <code>act</code> claim nests.</p>"},{"location":"service-delegation/#example-three-service-chain","title":"Example: Three-Service Chain","text":"<ol> <li>Gateway receives Auth0 token for <code>user@example.com</code></li> <li>Gateway \u2192 API Service with delegated token</li> <li>API Service \u2192 Data Service with further delegated token</li> </ol> <p>Token at step 2 (Gateway \u2192 API):</p> <pre><code>{\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\"],\n  \"act\": {\n    \"sub\": \"gateway-service\"\n  }\n}\n</code></pre> <p>Token at step 3 (API \u2192 Data):</p> <pre><code>import { createDelegatedToken } from '@chrislyons-dev/flarelette-jwt'\n\n// API service receives token from gateway\nconst gatewayPayload = await verify(gatewayToken)\n\n// API creates new token for data service\nconst dataToken = await createDelegatedToken(\n  gatewayPayload,\n  'api-service', // Current actor\n  { aud: 'data-service' }\n)\n</code></pre> <p>Resulting token:</p> <pre><code>{\n  \"sub\": \"user@example.com\",\n  \"permissions\": [\"read:data\"],\n  \"act\": {\n    \"sub\": \"api-service\", // Current actor\n    \"act\": {\n      \"sub\": \"gateway-service\" // Previous actor (nested)\n    }\n  }\n}\n</code></pre> <p>Audit trail:</p> <ul> <li>Original user: <code>user@example.com</code></li> <li>Request path: Gateway \u2192 API \u2192 Data</li> <li>Each service identified in nested <code>act</code> claims</li> </ul>"},{"location":"service-delegation/#verification-and-authorization","title":"Verification and Authorization","text":"<p>Services receiving delegated tokens verify them normally.</p> <pre><code>import { checkAuth, policy } from '@chrislyons-dev/flarelette-jwt'\n\n// Verify token and check permissions\nconst auth = await checkAuth(token, policy().needAll('read:data').build())\n\nif (!auth) {\n  return new Response('Unauthorized', { status: 401 })\n}\n\n// Access original user and actor\nconsole.log('User:', auth.sub) // user@example.com\nconsole.log('Actor:', auth.payload.act?.sub) // gateway-service\nconsole.log('Permissions:', auth.permissions) // [\"read:data\"]\n</code></pre> <p>Authorization still checks original permissions, not the actor service. The actor claim provides audit context, not additional authority.</p>"},{"location":"service-delegation/#architecture-pattern","title":"Architecture Pattern","text":""},{"location":"service-delegation/#recommended-eddsa-gateway-service-bindings","title":"Recommended: EdDSA Gateway + Service Bindings","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   External Auth Provider         \u2502\n\u2502   (Auth0, Okta, etc.)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502 External token\n                \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Gateway (Node.js + EdDSA)      \u2502\n\u2502                                  \u2502\n\u2502   1. Verify external token       \u2502\n\u2502   2. Create delegated token      \u2502\n\u2502   3. Pass to internal services   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502 Internal token (short TTL)\n                \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2193                \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 API Service  \u2502   \u2502 Data Service \u2502\n\u2502 (TS/Python)  \u2502   \u2502 (TS/Python)  \u2502\n\u2502              \u2502   \u2502              \u2502\n\u2502 Verify token \u2502   \u2502 Verify token \u2502\n\u2502 Check perms  \u2502   \u2502 Check perms  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits:</p> <ul> <li>External tokens never enter internal network</li> <li>Short-lived internal tokens (5-15 min)</li> <li>Full audit trail via nested <code>act</code> claims</li> <li>No permission escalation possible</li> </ul>"},{"location":"service-delegation/#configuration","title":"Configuration","text":"<p>Gateway (Producer):</p> <pre><code># wrangler.toml\n[vars]\nJWT_PRIVATE_JWK_NAME = \"GATEWAY_PRIVATE\"\nJWT_KID = \"ed25519-2025-01\"\nJWT_ISS = \"https://gateway.internal\"\nJWT_AUD = \"internal-services\"\nJWT_TTL_SECONDS = \"300\"  # 5 minutes\n</code></pre> <p>Internal Services (Consumers):</p> <pre><code># wrangler.toml\n[vars]\nJWT_JWKS_SERVICE_NAME = \"GATEWAY_BINDING\"\nJWT_ISS = \"https://gateway.internal\"\nJWT_AUD = \"internal-services\"\n\n# Service binding to gateway\n[[services]]\nbinding = \"GATEWAY_BINDING\"\nservice = \"gateway\"\nenvironment = \"production\"\n</code></pre>"},{"location":"service-delegation/#security-considerations","title":"Security Considerations","text":""},{"location":"service-delegation/#token-lifetime","title":"Token Lifetime","text":"<p>External tokens: Long-lived (hours), managed by external provider</p> <p>Delegated tokens: Short-lived (5-15 minutes)</p> <ul> <li>Reduces blast radius if token leaked</li> <li>Forces services to re-verify frequently</li> <li>Limits time window for replay attacks</li> </ul> <pre><code>// Short TTL for internal tokens\nconst token = await createDelegatedToken(\n  externalPayload,\n  'gateway-service',\n  { ttlSeconds: 300 } // \u2705 5 minutes\n)\n</code></pre>"},{"location":"service-delegation/#audience-scoping","title":"Audience Scoping","text":"<p>Use specific audiences for each internal service.</p> <pre><code>// \u2705 GOOD \u2014 Specific audience per service\nawait createDelegatedToken(payload, 'gateway', { aud: 'data-api' })\nawait createDelegatedToken(payload, 'gateway', { aud: 'billing-api' })\n\n// \u274c BAD \u2014 Generic audience\nawait createDelegatedToken(payload, 'gateway', { aud: 'all-services' })\n</code></pre> <p>Why: Prevents token meant for one service from being used by another.</p>"},{"location":"service-delegation/#actor-verification","title":"Actor Verification","text":"<p>Downstream services can verify which service created the token.</p> <pre><code>const auth = await checkAuth(token, policy().build())\n\nif (auth?.payload.act?.sub !== 'gateway-service') {\n  return new Response('Invalid actor', { status: 403 })\n}\n</code></pre> <p>Use when: Only specific services should be able to call your API.</p>"},{"location":"service-delegation/#permission-auditing","title":"Permission Auditing","text":"<p>Log actor claims for audit trails.</p> <pre><code>const auth = await checkAuth(token, policy().build())\n\nconsole.log({\n  user: auth.sub,\n  actor: auth.payload.act?.sub,\n  permissions: auth.permissions,\n  timestamp: new Date().toISOString(),\n})\n</code></pre>"},{"location":"service-delegation/#complete-example","title":"Complete Example","text":""},{"location":"service-delegation/#gateway-service","title":"Gateway Service","text":"<pre><code>import { Hono } from 'hono'\nimport { createDelegatedToken } from '@chrislyons-dev/flarelette-jwt'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\n\nconst app = new Hono&lt;{ Bindings: WorkerEnv }&gt;()\n\napp.use('*', async (c, next) =&gt; {\n  const jwt = makeKit(c.env)\n  c.set('jwt', jwt)\n  await next()\n})\n\napp.post('/internal-auth', async c =&gt; {\n  // Get external token from request\n  const externalToken = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  // Verify external token (Auth0, Okta, etc.)\n  const externalPayload = await verifyExternalToken(externalToken)\n  if (!externalPayload) {\n    return c.json({ error: 'Invalid external token' }, 401)\n  }\n\n  // Create delegated token for internal use\n  const internalToken = await createDelegatedToken(externalPayload, 'gateway-service', {\n    aud: 'internal-api',\n    ttlSeconds: 300, // 5 minutes\n  })\n\n  return c.json({ token: internalToken })\n})\n\nexport default app\n</code></pre>"},{"location":"service-delegation/#internal-api-service","title":"Internal API Service","text":"<pre><code>import { Hono } from 'hono'\nimport { checkAuth, policy } from '@chrislyons-dev/flarelette-jwt'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\n\nconst app = new Hono&lt;{ Bindings: WorkerEnv }&gt;()\n\napp.use('*', async (c, next) =&gt; {\n  const jwt = makeKit(c.env)\n  c.set('jwt', jwt)\n  await next()\n})\n\napp.get('/data', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  // Verify and authorize\n  const auth = await jwt.checkAuth(token, policy().needAll('read:data').build())\n\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  // Log for audit\n  console.log({\n    user: auth.sub,\n    actor: auth.payload.act?.sub,\n    action: 'read:data',\n    timestamp: new Date().toISOString(),\n  })\n\n  return c.json({ data: 'sensitive information', user: auth.sub })\n})\n\nexport default app\n</code></pre>"},{"location":"service-delegation/#references","title":"References","text":"<ul> <li>RFC 8693: OAuth 2.0 Token Exchange \u2014 Actor claim specification</li> <li>Core Concepts \u2014 Algorithm selection and architecture</li> <li>Security Guide \u2014 Cryptographic profiles and best practices</li> <li>Cloudflare Workers \u2014 Deployment and configuration</li> </ul>"},{"location":"usage-guide/","title":"Usage Guide","text":"<p>Complete API reference for Flarelette JWT Kit with examples in TypeScript and Python.</p>"},{"location":"usage-guide/#overview","title":"Overview","text":"<p>This guide covers all exported functions, types, and patterns for both languages. For conceptual understanding, see Core Concepts. For security best practices, see Security Guide.</p>"},{"location":"usage-guide/#core-functions","title":"Core Functions","text":""},{"location":"usage-guide/#sign","title":"sign()","text":"<p>Low-level JWT signing function. Algorithm (HS512 or EdDSA) is automatically detected from environment.</p> <p>TypeScript:</p> <pre><code>import { sign } from '@chrislyons-dev/flarelette-jwt'\n\nconst token = await sign({\n  sub: 'user123',\n  permissions: ['read:data', 'write:data'],\n  roles: ['user', 'editor'],\n})\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import sign\n\ntoken = await sign({\n    \"sub\": \"user123\",\n    \"permissions\": [\"read:data\", \"write:data\"],\n    \"roles\": [\"user\", \"editor\"]\n})\n</code></pre> <p>Parameters:</p> <ul> <li><code>payload</code> (ClaimsDict) - Custom claims to include in token. Standard claims (<code>iss</code>, <code>aud</code>, <code>iat</code>, <code>exp</code>) are added automatically from environment.</li> </ul> <p>Returns: <code>Promise&lt;string&gt;</code> (TypeScript) or <code>str</code> (Python) - Signed JWT token</p> <p>Automatically added claims:</p> <ul> <li><code>iss</code> - From <code>JWT_ISS</code> environment variable</li> <li><code>aud</code> - From <code>JWT_AUD</code> environment variable</li> <li><code>iat</code> - Current Unix timestamp</li> <li><code>exp</code> - Current timestamp + <code>JWT_TTL_SECONDS</code> (default 900)</li> <li><code>jti</code> - Optional, if <code>JWT_JTI</code> is set</li> </ul>"},{"location":"usage-guide/#verify","title":"verify()","text":"<p>Low-level JWT verification function. Validates signature, issuer, audience, and expiration.</p> <p>TypeScript:</p> <pre><code>import { verify } from '@chrislyons-dev/flarelette-jwt'\n\nconst payload = await verify(token)\nif (payload) {\n  console.log('Valid token for user:', payload.sub)\n} else {\n  console.log('Invalid or expired token')\n}\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import verify\n\npayload = await verify(token)\nif payload:\n    print(f\"Valid token for user: {payload.get('sub')}\")\nelse:\n    print(\"Invalid or expired token\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>token</code> (string) - JWT token to verify</li> <li><code>options</code> (optional) - Verification options:</li> <li><code>leeway</code> (number) - Clock skew tolerance in seconds (overrides <code>JWT_LEEWAY</code>)</li> </ul> <p>Returns: <code>Promise&lt;JwtPayload | null&gt;</code> (TypeScript) or <code>JwtPayload | None</code> (Python)</p> <p>Fail-silent behavior: Returns <code>null</code>/<code>None</code> on any verification failure (invalid signature, expired, wrong issuer/audience, etc.)</p>"},{"location":"usage-guide/#parse","title":"parse()","text":"<p>Parse JWT token without verification. Useful for inspecting token contents.</p> <p>TypeScript:</p> <pre><code>import { parse } from '@chrislyons-dev/flarelette-jwt'\n\nconst { header, payload } = parse(token)\nconsole.log('Algorithm:', header.alg)\nconsole.log('Key ID:', header.kid)\nconsole.log('Issuer:', payload.iss)\nconsole.log('Expires:', new Date(payload.exp * 1000))\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import parse\n\nparsed = parse(token)\nprint(f\"Algorithm: {parsed['header']['alg']}\")\nprint(f\"Key ID: {parsed['header'].get('kid')}\")\nprint(f\"Issuer: {parsed['payload']['iss']}\")\nprint(f\"Expires: {parsed['payload']['exp']}\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>token</code> (string) - JWT token to parse</li> </ul> <p>Returns: <code>ParsedJwt</code> - Object with <code>header</code> and <code>payload</code> fields</p> <p>Warning: Does not validate signature or claims. Never use parsed data for authorization decisions without calling <code>verify()</code> first.</p>"},{"location":"usage-guide/#high-level-functions","title":"High-Level Functions","text":""},{"location":"usage-guide/#createtoken","title":"createToken()","text":"<p>High-level token creation with options. Wraps <code>sign()</code> with additional configurability.</p> <p>TypeScript:</p> <pre><code>import { createToken } from '@chrislyons-dev/flarelette-jwt'\n\nconst token = await createToken(\n  {\n    sub: 'user123',\n    permissions: ['read:data'],\n    email: 'user@example.com',\n  },\n  {\n    ttlSeconds: 600, // Override default TTL\n    aud: 'special-api', // Override default audience\n  }\n)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import create_token\n\ntoken = await create_token(\n    {\"sub\": \"user123\", \"permissions\": [\"read:data\"], \"email\": \"user@example.com\"},\n    ttl_seconds=600,  # Override default TTL\n    aud=\"special-api\"  # Override default audience\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>claims</code> (ClaimsDict) - Custom claims</li> <li><code>options</code> (optional):</li> <li><code>ttlSeconds</code> / <code>ttl_seconds</code> (number) - Token lifetime in seconds (overrides <code>JWT_TTL_SECONDS</code>)</li> <li><code>aud</code> (string) - Audience claim (overrides <code>JWT_AUD</code>)</li> </ul> <p>Returns: <code>Promise&lt;string&gt;</code> (TypeScript) or <code>str</code> (Python) - Signed JWT token</p>"},{"location":"usage-guide/#checkauth","title":"checkAuth()","text":"<p>Verify token and check authorization policy in one call.</p> <p>TypeScript:</p> <pre><code>import { checkAuth, policy } from '@chrislyons-dev/flarelette-jwt'\n\nconst authPolicy = policy()\n  .needAll('read:data', 'write:data')\n  .rolesAny('admin', 'editor')\n  .build()\n\nconst auth = await checkAuth(token, authPolicy)\nif (auth) {\n  console.log('Authorized user:', auth.sub)\n  console.log('Permissions:', auth.permissions)\n  console.log('Full payload:', auth.payload)\n} else {\n  console.log('Authorization failed')\n}\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import check_auth, policy\n\nauth_policy = (\n    policy()\n    .need_all('read:data', 'write:data')\n    .roles_any('admin', 'editor')\n    .build()\n)\n\nauth = await check_auth(token, **auth_policy)\nif auth:\n    print(f\"Authorized user: {auth['sub']}\")\n    print(f\"Permissions: {auth['permissions']}\")\n    print(f\"Full payload: {auth['payload']}\")\nelse:\n    print(\"Authorization failed\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>token</code> (string) - JWT token to verify</li> <li><code>authzOpts</code> (AuthzOpts / dict) - Authorization requirements (from <code>policy().build()</code>)</li> </ul> <p>Returns: <code>Promise&lt;AuthUser | null&gt;</code> (TypeScript) or <code>AuthUser | None</code> (Python)</p> <p>AuthUser fields:</p> <ul> <li><code>sub</code> - Subject (user ID)</li> <li><code>permissions</code> - List of permission strings</li> <li><code>roles</code> - List of role strings</li> <li><code>payload</code> - Full JWT payload</li> </ul>"},{"location":"usage-guide/#createdelegatedtoken","title":"createDelegatedToken()","text":"<p>Create delegated token for service-to-service authentication using RFC 8693 actor claims.</p> <p>TypeScript:</p> <pre><code>import { createDelegatedToken } from '@chrislyons-dev/flarelette-jwt'\n\n// Gateway receives external token\nconst externalPayload = await verifyAuth0Token(externalToken)\n\n// Create internal token for API service\nconst internalToken = await createDelegatedToken(\n  externalPayload, // Original verified payload\n  'gateway-service', // Actor service identifier\n  {\n    aud: 'internal-api', // Internal audience\n    ttlSeconds: 300, // Short-lived (5 min)\n  }\n)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import create_delegated_token\n\n# Gateway receives external token\nexternal_payload = await verify_auth0_token(external_token)\n\n# Create internal token for API service\ninternal_token = await create_delegated_token(\n    external_payload,        # Original verified payload\n    \"gateway-service\",       # Actor service identifier\n    aud=\"internal-api\",      # Internal audience\n    ttl_seconds=300          # Short-lived (5 min)\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>originalPayload</code> / <code>original_payload</code> (JwtPayload) - Verified payload from external token</li> <li><code>actorServiceId</code> / <code>actor_service_id</code> (string) - Service identifier for <code>act</code> claim</li> <li><code>options</code> (optional):</li> <li><code>ttlSeconds</code> / <code>ttl_seconds</code> (number) - Token lifetime (default: 300 seconds)</li> <li><code>aud</code> (string) - Internal audience (overrides <code>JWT_AUD</code>)</li> </ul> <p>Returns: <code>Promise&lt;string&gt;</code> (TypeScript) or <code>str</code> (Python) - Delegated JWT token</p> <p>Preserved claims:</p> <ul> <li><code>sub</code> - Original user identifier</li> <li><code>permissions</code> - Original permissions (no escalation)</li> <li><code>roles</code> - Original roles</li> <li><code>email</code>, <code>name</code>, <code>groups</code>, <code>tid</code>, <code>org_id</code>, <code>department</code> - If present</li> </ul> <p>Added claims:</p> <ul> <li><code>act</code> - Actor claim with <code>sub</code> field containing <code>actorServiceId</code></li> <li>New <code>iss</code>, <code>aud</code>, <code>iat</code>, <code>exp</code>, <code>jti</code> - For internal token</li> </ul> <p>Delegation chains: If <code>originalPayload</code> already has an <code>act</code> claim, it is nested:</p> <pre><code>{\n  \"sub\": \"user@example.com\",\n  \"act\": {\n    \"sub\": \"api-service\",\n    \"act\": {\n      \"sub\": \"gateway-service\"\n    }\n  }\n}\n</code></pre> <p>See Service Delegation for detailed usage patterns.</p>"},{"location":"usage-guide/#policy","title":"policy()","text":"<p>Fluent builder for authorization policies.</p> <p>TypeScript:</p> <pre><code>import { policy } from '@chrislyons-dev/flarelette-jwt'\n\n// Require all listed permissions\nconst p1 = policy().needAll('read:data', 'write:data').build()\n\n// Require at least one listed permission\nconst p2 = policy().needAny('read:data', 'admin:all').build()\n\n// Require at least one listed role\nconst p3 = policy().rolesAny('admin', 'editor').build()\n\n// Require all listed roles\nconst p4 = policy().rolesAll('user', 'verified').build()\n\n// Custom predicate function\nconst p5 = policy()\n  .predicate(payload =&gt; payload.email?.endsWith('@example.com'))\n  .build()\n\n// Combine multiple requirements\nconst p6 = policy()\n  .needAll('read:data')\n  .rolesAny('admin', 'editor')\n  .predicate(payload =&gt; payload.email?.endsWith('@example.com'))\n  .build()\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import policy\n\n# Require all listed permissions\np1 = policy().need_all('read:data', 'write:data').build()\n\n# Require at least one listed permission\np2 = policy().need_any('read:data', 'admin:all').build()\n\n# Require at least one listed role\np3 = policy().roles_any('admin', 'editor').build()\n\n# Require all listed roles\np4 = policy().roles_all('user', 'verified').build()\n\n# Custom predicate function\np5 = policy().predicate(lambda payload: payload.get(\"email\", \"\").endswith(\"@example.com\")).build()\n\n# Combine multiple requirements\np6 = (\n    policy()\n    .need_all('read:data')\n    .roles_any('admin', 'editor')\n    .predicate(lambda payload: payload.get(\"email\", \"\").endswith(\"@example.com\"))\n    .build()\n)\n</code></pre> <p>Builder methods:</p> <ul> <li><code>needAll(...perms)</code> / <code>need_all(...perms)</code> - Require all listed permissions</li> <li><code>needAny(...perms)</code> / <code>need_any(...perms)</code> - Require at least one listed permission</li> <li><code>rolesAll(...roles)</code> / <code>roles_all(...roles)</code> - Require all listed roles</li> <li><code>rolesAny(...roles)</code> / <code>roles_any(...roles)</code> - Require at least one listed role</li> <li><code>predicate(fn)</code> - Add custom validation function</li> <li><code>build()</code> - Return authorization options object</li> </ul> <p>Predicates: Functions that receive <code>JwtPayload</code> and return boolean. Multiple predicates are AND-ed together.</p>"},{"location":"usage-guide/#configuration-functions","title":"Configuration Functions","text":""},{"location":"usage-guide/#envmode-mode","title":"envMode() / mode()","text":"<p>Detect which algorithm mode is active based on environment variables.</p> <p>TypeScript:</p> <pre><code>import { envMode } from '@chrislyons-dev/flarelette-jwt'\n\nconst producerMode = envMode('producer')\nconsole.log('Producer mode:', producerMode) // \"HS512\" or \"EdDSA\"\n\nconst consumerMode = envMode('consumer')\nconsole.log('Consumer mode:', consumerMode) // \"HS512\" or \"EdDSA\"\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import mode\n\nproducer_mode = mode('producer')\nprint(f'Producer mode: {producer_mode}')  # \"HS512\" or \"EdDSA\"\n\nconsumer_mode = mode('consumer')\nprint(f'Consumer mode: {consumer_mode}')  # \"HS512\" or \"EdDSA\"\n</code></pre> <p>Parameters:</p> <ul> <li><code>role</code> - Either <code>\"producer\"</code> (signing) or <code>\"consumer\"</code> (verification)</li> </ul> <p>Returns: <code>\"HS512\"</code> or <code>\"EdDSA\"</code></p> <p>Detection logic:</p> <ul> <li>Producer: If <code>JWT_PRIVATE_JWK_NAME</code> or <code>JWT_PRIVATE_JWK</code> exists \u2192 <code>\"EdDSA\"</code>, otherwise <code>\"HS512\"</code></li> <li>Consumer: If <code>JWT_PUBLIC_JWK_NAME</code> or <code>JWT_PUBLIC_JWK</code> or <code>JWT_JWKS_SERVICE_NAME</code> exists \u2192 <code>\"EdDSA\"</code>, otherwise <code>\"HS512\"</code></li> </ul>"},{"location":"usage-guide/#getprofile-profile","title":"getProfile() / profile()","text":"<p>Get complete JWT configuration profile for current mode.</p> <p>TypeScript:</p> <pre><code>import { getProfile } from '@chrislyons-dev/flarelette-jwt'\n\nconst producerProfile = getProfile('producer')\nconsole.log('Producer algorithm:', producerProfile.alg)\nconsole.log('Has secret:', !!producerProfile.secret)\nconsole.log('Has private key:', !!producerProfile.privateJwk)\n\nconst consumerProfile = getProfile('consumer')\nconsole.log('Consumer algorithm:', consumerProfile.alg)\nconsole.log('Has JWKS service:', !!consumerProfile.jwksService)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import profile\n\nproducer_profile = profile('producer')\nprint(f'Producer algorithm: {producer_profile[\"alg\"]}')\nprint(f'Has secret: {bool(producer_profile.get(\"secret\"))}')\n\nconsumer_profile = profile('consumer')\nprint(f'Consumer algorithm: {consumer_profile[\"alg\"]}')\n</code></pre> <p>Parameters:</p> <ul> <li><code>role</code> - Either <code>\"producer\"</code> or <code>\"consumer\"</code></li> </ul> <p>Returns: <code>JwtProfile</code> object with fields:</p> <ul> <li><code>alg</code> - Algorithm: <code>\"HS512\"</code> or <code>\"EdDSA\"</code></li> <li><code>secret</code> - Base64url-encoded secret (HS512 only)</li> <li><code>privateJwk</code> - Private JWK string (EdDSA producer only)</li> <li><code>publicJwk</code> - Public JWK string (EdDSA consumer with inline key only)</li> <li><code>jwksService</code> - Fetcher service binding (EdDSA consumer with service binding only, TypeScript only)</li> <li><code>kid</code> - Key ID (EdDSA producer only)</li> <li><code>allowedThumbprints</code> - List of allowed JWK thumbprints (EdDSA consumer only)</li> </ul>"},{"location":"usage-guide/#getcommon-common","title":"getCommon() / common()","text":"<p>Get common configuration shared by producer and consumer.</p> <p>TypeScript:</p> <pre><code>import { getCommon } from '@chrislyons-dev/flarelette-jwt'\n\nconst config = getCommon()\nconsole.log('Issuer:', config.iss)\nconsole.log('Audience:', config.aud)\nconsole.log('TTL:', config.ttlSeconds, 'seconds')\nconsole.log('Leeway:', config.leeway, 'seconds')\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import common\n\nconfig = common()\nprint(f'Issuer: {config[\"iss\"]}')\nprint(f'Audience: {config[\"aud\"]}')\nprint(f'TTL: {config[\"ttl_seconds\"]} seconds')\nprint(f'Leeway: {config[\"leeway\"]} seconds')\n</code></pre> <p>Returns: <code>JwtCommonConfig</code> object with fields:</p> <ul> <li><code>iss</code> - Token issuer (from <code>JWT_ISS</code>)</li> <li><code>aud</code> - Token audience (from <code>JWT_AUD</code>)</li> <li><code>ttlSeconds</code> / <code>ttl_seconds</code> - Token lifetime in seconds (from <code>JWT_TTL_SECONDS</code>, default 900)</li> <li><code>leeway</code> - Clock skew tolerance in seconds (from <code>JWT_LEEWAY</code>, default 90)</li> </ul>"},{"location":"usage-guide/#utility-functions","title":"Utility Functions","text":""},{"location":"usage-guide/#isexpiringsoon-is_expiring_soon","title":"isExpiringSoon() / is_expiring_soon()","text":"<p>Check if token is expiring within a threshold.</p> <p>TypeScript:</p> <pre><code>import { isExpiringSoon, verify } from '@chrislyons-dev/flarelette-jwt'\n\nconst payload = await verify(token)\nif (payload &amp;&amp; isExpiringSoon(payload, 300)) {\n  console.log('Token expires within 5 minutes, consider refreshing')\n}\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import is_expiring_soon, verify\n\npayload = await verify(token)\nif payload and is_expiring_soon(payload, 300):\n    print(\"Token expires within 5 minutes, consider refreshing\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>payload</code> (JwtPayload) - Verified JWT payload</li> <li><code>thresholdSeconds</code> / <code>threshold_seconds</code> (number) - Time window in seconds (default: 300)</li> </ul> <p>Returns: <code>boolean</code> - <code>true</code> if token expires within threshold</p>"},{"location":"usage-guide/#generatesecret-generate_secret","title":"generateSecret() / generate_secret()","text":"<p>Generate cryptographically random HS512 secret.</p> <p>TypeScript:</p> <pre><code>import { generateSecret } from '@chrislyons-dev/flarelette-jwt'\n\nconst secret = generateSecret(64) // 64 bytes\nconsole.log('JWT_SECRET=' + secret)\n</code></pre> <p>Python:</p> <pre><code>from flarelette_jwt import generate_secret\n\nsecret = generate_secret(64)  # 64 bytes\nprint(f\"JWT_SECRET={secret}\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>length</code> (number) - Secret length in bytes (default: 64)</li> </ul> <p>Returns: <code>string</code> - Base64url-encoded secret</p> <p>Usage: For HS512, use minimum 64 bytes (512 bits) for ~256-bit security.</p>"},{"location":"usage-guide/#adapters","title":"Adapters","text":""},{"location":"usage-guide/#typescript-makekit","title":"TypeScript: makeKit()","text":"<p>Inject Cloudflare Worker environment for use in Workers runtime.</p> <pre><code>import { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\nimport { Hono } from 'hono'\nimport type { WorkerEnv } from '@chrislyons-dev/flarelette-jwt'\n\nconst app = new Hono&lt;{ Bindings: WorkerEnv }&gt;()\n\n// Inject environment middleware\napp.use('*', async (c, next) =&gt; {\n  const jwt = makeKit(c.env)\n  c.set('jwt', jwt)\n  await next()\n})\n\n// Use in routes\napp.get('/secure', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  const auth = await jwt.checkAuth(token, jwt.policy().build())\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  return c.json({ data: 'secure', user: auth.sub })\n})\n\nexport default app\n</code></pre> <p>What it does:</p> <ol> <li>Extracts string variables from Worker <code>env</code> object</li> <li>Extracts Fetcher service bindings (for JWKS)</li> <li>Stores in <code>globalThis.__FLARELETTE_ENV</code> and <code>globalThis.__FLARELETTE_SERVICES</code></li> <li>Returns object with all JWT functions bound to environment</li> </ol> <p>Returns: Object with all JWT functions pre-configured for Worker environment</p>"},{"location":"usage-guide/#python-apply_env_bindings","title":"Python: apply_env_bindings()","text":"<p>Copy Worker environment to <code>os.environ</code> for use in Python Workers.</p> <pre><code>from flarelette_jwt.adapters import apply_env_bindings\nfrom flarelette_jwt import check_auth, policy\nfrom js import Response\n\nasync def on_fetch(request, env, ctx):\n    # Inject environment (call once per request)\n    apply_env_bindings(env)\n\n    # Get token\n    auth_header = request.headers.get('Authorization', '')\n    token = auth_header.removeprefix('Bearer ')\n\n    # Verify and authorize\n    auth = await check_auth(token, **policy().build())\n    if not auth:\n        return Response.new('{\"error\": \"Unauthorized\"}', status=401)\n\n    return Response.new(f'{{\"data\": \"secure\", \"user\": \"{auth[\"sub\"]}\"}}')\n</code></pre> <p>What it does:</p> <ol> <li>Iterates over Worker <code>env</code> mapping</li> <li>Copies string values to <code>os.environ</code></li> <li>All JWT functions read from <code>os.environ</code></li> </ol> <p>Note: Python Workers don't support Fetcher service bindings. Use inline <code>JWT_PUBLIC_JWK</code> for EdDSA verification.</p>"},{"location":"usage-guide/#types-and-interfaces","title":"Types and Interfaces","text":""},{"location":"usage-guide/#typescript-types","title":"TypeScript Types","text":"<p>AlgType - JWT algorithm:</p> <pre><code>type AlgType = 'HS512' | 'EdDSA'\n</code></pre> <p>ClaimsDict - Custom token claims:</p> <pre><code>interface ClaimsDict {\n  sub?: string // Subject (user ID)\n  permissions?: string[] // Permission strings\n  roles?: string[] // Role strings\n  email?: string // User email\n  name?: string // Display name\n  [key: string]: JwtValue // Additional custom claims\n}\n</code></pre> <p>JwtValue - Allowed claim value types:</p> <pre><code>type JwtValue =\n  | string\n  | number\n  | boolean\n  | null\n  | JwtValue[]\n  | { [key: string]: JwtValue }\n</code></pre> <p>JwtHeader - JWT header:</p> <pre><code>interface JwtHeader {\n  alg: AlgType\n  typ: 'JWT'\n  kid?: string // Key ID (EdDSA only)\n}\n</code></pre> <p>JwtPayload - JWT payload:</p> <pre><code>interface JwtPayload {\n  iss: string // Issuer\n  aud: string // Audience\n  sub: string // Subject\n  iat: number // Issued at (Unix timestamp)\n  exp: number // Expiration (Unix timestamp)\n  nbf?: number // Not before (Unix timestamp)\n  jti?: string // JWT ID\n  permissions?: string[] // Permission strings\n  roles?: string[] // Role strings\n  act?: ActorClaim // Actor claim for delegation\n  [key: string]: JwtValue // Additional claims\n}\n</code></pre> <p>ActorClaim - RFC 8693 actor claim:</p> <pre><code>interface ActorClaim {\n  sub: string // Actor service identifier\n  act?: ActorClaim // Nested actor (delegation chain)\n}\n</code></pre> <p>AuthUser - Authorized user result:</p> <pre><code>interface AuthUser {\n  sub: string // Subject (user ID)\n  permissions: string[] // Permission strings\n  roles: string[] // Role strings\n  payload: JwtPayload // Full JWT payload\n}\n</code></pre> <p>ParsedJwt - Parsed token:</p> <pre><code>interface ParsedJwt {\n  header: JwtHeader\n  payload: JwtPayload\n}\n</code></pre> <p>WorkerEnv - Cloudflare Worker environment:</p> <pre><code>interface WorkerEnv {\n  [key: string]: string | Fetcher\n}\n</code></pre> <p>Fetcher - Service binding:</p> <pre><code>interface Fetcher {\n  fetch(input: RequestInfo, init?: RequestInit): Promise&lt;Response&gt;\n}\n</code></pre>"},{"location":"usage-guide/#python-types","title":"Python Types","text":"<p>Python uses TypedDicts for type hints:</p> <p>AlgType - JWT algorithm:</p> <pre><code>AlgType = Literal[\"HS512\", \"EdDSA\"]\n</code></pre> <p>ClaimsDict - Custom token claims:</p> <pre><code>class ClaimsDict(TypedDict, total=False):\n    sub: str\n    permissions: list[str]\n    roles: list[str]\n    email: str\n    name: str\n    # Additional fields allowed via NotRequired\n</code></pre> <p>JwtHeader - JWT header:</p> <pre><code>class JwtHeader(TypedDict):\n    alg: AlgType\n    typ: Literal[\"JWT\"]\n    kid: NotRequired[str]\n</code></pre> <p>JwtPayload - JWT payload:</p> <pre><code>class JwtPayload(TypedDict):\n    iss: str\n    aud: str\n    sub: str\n    iat: int\n    exp: int\n    nbf: NotRequired[int]\n    jti: NotRequired[str]\n    permissions: NotRequired[list[str]]\n    roles: NotRequired[list[str]]\n    act: NotRequired[ActorClaim]\n</code></pre> <p>ActorClaim - RFC 8693 actor claim:</p> <pre><code>class ActorClaim(TypedDict):\n    sub: str\n    act: NotRequired[ActorClaim]\n</code></pre> <p>AuthUser - Authorized user result:</p> <pre><code>class AuthUser(TypedDict):\n    sub: str\n    permissions: list[str]\n    roles: list[str]\n    payload: JwtPayload\n</code></pre> <p>ParsedJwt - Parsed token:</p> <pre><code>class ParsedJwt(TypedDict):\n    header: JwtHeader\n    payload: JwtPayload\n</code></pre>"},{"location":"usage-guide/#common-patterns","title":"Common Patterns","text":""},{"location":"usage-guide/#pattern-cloudflare-worker-typescript-with-hono","title":"Pattern: Cloudflare Worker (TypeScript with Hono)","text":"<pre><code>import { Hono } from 'hono'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt/adapters/hono'\nimport type { WorkerEnv } from '@chrislyons-dev/flarelette-jwt'\n\nconst app = new Hono&lt;{ Bindings: WorkerEnv }&gt;()\n\n// Environment injection middleware\napp.use('*', async (c, next) =&gt; {\n  const jwt = makeKit(c.env)\n  c.set('jwt', jwt)\n  await next()\n})\n\n// Public route\napp.get('/health', c =&gt; c.json({ ok: true }))\n\n// Protected route with policy\napp.get('/secure', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  const auth = await jwt.checkAuth(\n    token,\n    jwt.policy().rolesAny('admin', 'editor').needAll('read:data').build()\n  )\n\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  return c.json({\n    message: 'Authorized',\n    user: auth.sub,\n    permissions: auth.permissions,\n  })\n})\n\nexport default app\n</code></pre>"},{"location":"usage-guide/#pattern-cloudflare-worker-python","title":"Pattern: Cloudflare Worker (Python)","text":"<pre><code>from flarelette_jwt.adapters import apply_env_bindings\nfrom flarelette_jwt import check_auth, policy\nfrom js import Response\n\nasync def on_fetch(request, env, ctx):\n    # Inject environment\n    apply_env_bindings(env)\n\n    # Parse authorization header\n    auth_header = request.headers.get('Authorization', '')\n    token = auth_header.removeprefix('Bearer ')\n\n    # Public endpoint\n    if request.url.endswith('/health'):\n        return Response.new('{\"ok\": true}', status=200)\n\n    # Protected endpoint\n    auth = await check_auth(\n        token,\n        **policy()\n            .roles_any('admin', 'editor')\n            .need_all('read:data')\n            .build()\n    )\n\n    if not auth:\n        return Response.new('{\"error\": \"Unauthorized\"}', status=401)\n\n    return Response.new(\n        f'{{\"message\": \"Authorized\", \"user\": \"{auth[\"sub\"]}\"}}',\n        status=200\n    )\n</code></pre>"},{"location":"usage-guide/#pattern-service-delegation-gateway","title":"Pattern: Service Delegation (Gateway)","text":"<pre><code>import { Hono } from 'hono'\nimport { makeKit, createDelegatedToken } from '@chrislyons-dev/flarelette-jwt'\n\nconst app = new Hono()\n\napp.use('*', async (c, next) =&gt; {\n  c.set('jwt', makeKit(c.env))\n  await next()\n})\n\napp.post('/internal-auth', async c =&gt; {\n  const jwt = c.get('jwt')\n\n  // Get external token from request\n  const externalToken = c.req.header('Authorization')?.replace('Bearer ', '')\n  if (!externalToken) {\n    return c.json({ error: 'No token provided' }, 401)\n  }\n\n  // Verify external token (Auth0, Okta, etc.)\n  const externalPayload = await verifyExternalToken(externalToken)\n  if (!externalPayload) {\n    return c.json({ error: 'Invalid external token' }, 401)\n  }\n\n  // Create delegated token for internal use\n  const internalToken = await createDelegatedToken(externalPayload, 'gateway-service', {\n    aud: 'internal-api',\n    ttlSeconds: 300, // 5 minutes\n  })\n\n  return c.json({ token: internalToken })\n})\n\nexport default app\n</code></pre>"},{"location":"usage-guide/#pattern-service-consumer","title":"Pattern: Service Consumer","text":"<pre><code>import { Hono } from 'hono'\nimport { makeKit } from '@chrislyons-dev/flarelette-jwt'\n\nconst app = new Hono()\n\napp.use('*', async (c, next) =&gt; {\n  c.set('jwt', makeKit(c.env))\n  await next()\n})\n\napp.get('/data', async c =&gt; {\n  const jwt = c.get('jwt')\n  const token = c.req.header('Authorization')?.replace('Bearer ', '')\n\n  // Verify delegated token\n  const auth = await jwt.checkAuth(token, jwt.policy().needAll('read:data').build())\n\n  if (!auth) {\n    return c.json({ error: 'Unauthorized' }, 401)\n  }\n\n  // Log actor for audit\n  console.log({\n    user: auth.sub,\n    actor: auth.payload.act?.sub,\n    action: 'read:data',\n    timestamp: new Date().toISOString(),\n  })\n\n  return c.json({ data: 'sensitive information', user: auth.sub })\n})\n\nexport default app\n</code></pre>"},{"location":"usage-guide/#next-topics","title":"Next Topics","text":"<ul> <li>Getting Started \u2014 Installation and first token</li> <li>Core Concepts \u2014 Algorithms, modes, and architecture</li> <li>Service Delegation \u2014 RFC 8693 actor claims for zero-trust</li> <li>Security Guide \u2014 Cryptographic profiles and best practices</li> <li>Cloudflare Workers \u2014 Workers deployment and configuration</li> </ul>"},{"location":"architecture/","title":"\ud83c\udfd7\ufe0f flarelette-jwt-kit","text":"<p>Architecture Documentation Generated 2025-12-08 19:38:11</p>"},{"location":"architecture/#overview","title":"Overview","text":"<p>JWT authentication and authorization library</p>"},{"location":"architecture/#system-context","title":"System Context","text":"<p>The system context diagram shows how flarelette-jwt-kit fits into its environment, including external systems and users.</p> <p></p>"},{"location":"architecture/#containers","title":"Containers","text":"<p>The container diagram shows the high-level technology choices and how containers communicate.</p> <p></p> Container Type Description Details @chrislyons-dev/flarelette-jwt <code>Service</code> Environment-driven JWT authentication for Cloudflare Workers with secret-name indirection View \u2192 flarelette-jwt <code>Service</code> Environment-driven JWT authentication for Cloudflare Workers Python with secret-name indirection View \u2192 <sub>Generated with Archlette Architecture-as-Code toolkit</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt/","title":"@chrislyons-dev/flarelette-jwt","text":"<p>\u2190 Back to System Overview</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt/#container-context","title":"Container Context","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt/#container-information","title":"Container Information","text":"Name @chrislyons-dev/flarelette-jwt Type <code>Service</code> Description Environment-driven JWT authentication for Cloudflare Workers with secret-name indirection Tags <code>Auto-generated</code>"},{"location":"architecture/chrislyons_dev_flarelette_jwt/#components","title":"Components","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt/#component-view","title":"Component View","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt/#component-details","title":"Component Details","text":"Component Type Description Code core <code>module</code> CLI utility for generating JWT secrets.  This script provides options to generate secrets in various formats, including JSON and dotenv. It is designed to be executed as a standalone Node.js script. | Configuration utilities for JWT operations.  This module provides functions to read environment variables and derive JWT-related configurations. It includes support for both symmetric (HS512) and asymmetric (EdDSA) algorithms. | JWT signing utilities.  This module provides functions to sign JWT tokens using either HS512 or EdDSA algorithms. It supports custom claims and configuration overrides. View \u2192 explicit <code>module</code> Explicit configuration API for JWT operations.  This module provides functions that accept explicit configuration objects instead of relying on environment variables or global state. Use this API when you need full control over configuration, especially in development environments or when working with multiple JWT configurations. View \u2192 util <code>module</code> High-level JWT utilities for creating, delegating, verifying, and authorizing JWT tokens | Key generation utility for EdDSA keys.  This script generates EdDSA key pairs and exports them in JWK format. It is designed to be executed as a standalone Node.js script. | Secret generation and validation utilities.  This module provides functions to generate secure secrets and validate base64url-encoded secrets. It ensures compatibility with JWT signing requirements. | Utility functions for JWT operations.  This module provides helper functions for parsing JWTs, checking expiration, and mapping OAuth scopes. It is designed to support core JWT functionalities. View \u2192 main <code>module</code> Entry point for the flarelette-jwt library.  This module re-exports core functionalities, including signing, verification, utilities, and type definitions. It serves as the main interface for library consumers. View \u2192 jwks <code>module</code> JSON Web Key Set (JWKS) utilities.  This module provides functions to fetch and manage JWKS, including caching and key lookup by key ID (kid). It supports integration with external JWKS services. View \u2192 types <code>module</code> Type definitions for JWT operations.  This module defines types for JWT headers, payloads, profiles, and related structures. It ensures type safety and consistency across the library. View \u2192 verify <code>module</code> JWT verification utilities.  This module provides functions to verify JWT tokens using either HS512 or EdDSA algorithms. It supports integration with JWKS services and thumbprint pinning. View \u2192 adapters <code>module</code> Component inferred from directory: adapters View \u2192 <sub>\u2190 Back to System Overview | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__adapters/","title":"adapters \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__adapters/#component-information","title":"Component Information","text":"Component adapters Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description Component inferred from directory: adapters"},{"location":"architecture/chrislyons_dev_flarelette_jwt__adapters/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__adapters/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__adapters/#code-elements","title":"Code Elements","text":"3 code element(s)    #### Functions  ##### `bindEnv()`  Store both environment variables and service bindings globally   Type <code>function</code> Visibility <code>public</code> Returns <code>void</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/adapters/hono.ts:13</code>   **Parameters:**  - `env`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").WorkerEnv</code>  --- ##### `getServiceBinding()`  Get service binding by name from global storage   Type <code>function</code> Visibility <code>private</code> Returns <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").Fetcher</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/adapters/hono.ts:35</code>   **Parameters:**  - `name`: <code>string</code>  --- ##### `makeKit()`  Returns a namespaced kit whose calls use the provided env bag. Automatically injects JWKS service binding if configured.   Type <code>function</code> Visibility <code>public</code> Returns <code>{ sign: typeof import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/sign\").sign; verify: (token: string, opts?: Partial&lt;{ iss: string; aud: string; leeway: number; }&gt;) =&gt; Promise; createToken: typeof import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high\").createToken; checkAuth: (token: string, opts?: import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high\").AuthzOpts) =&gt; Promise; policy: typeof import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high\").policy; parse: typeof import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/util\").parse; isExpiringSoon: typeof import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/util\").isExpiringSoon; } Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/adapters/hono.ts:45</code>   **Parameters:**  - `env`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").WorkerEnv</code>  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__core/","title":"core \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__core/#component-information","title":"Component Information","text":"Component core Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description CLI utility for generating JWT secrets.  This script provides options to generate secrets in various formats, including JSON and dotenv. It is designed to be executed as a standalone Node.js script. | Configuration utilities for JWT operations.  This module provides functions to read environment variables and derive JWT-related configurations. It includes support for both symmetric (HS512) and asymmetric (EdDSA) algorithms. | JWT signing utilities.  This module provides functions to sign JWT tokens using either HS512 or EdDSA algorithms. It supports custom claims and configuration overrides."},{"location":"architecture/chrislyons_dev_flarelette_jwt__core/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__core/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__core/#code-elements","title":"Code Elements","text":"11 code element(s)    #### Functions  ##### `envRead()`    Type <code>function</code> Visibility <code>private</code> Returns <code>string</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:13</code>   **Parameters:**  - `name`: <code>string</code>  --- ##### `envMode()`    Type <code>function</code> Visibility <code>public</code> Returns <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").AlgType</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:23</code>   **Parameters:**  - `role`: <code>\"producer\" | \"consumer\"</code>  --- ##### `getCommon()`  Get common JWT configuration from environment Returns partial JwtProfile-compatible configuration   Type <code>function</code> Visibility <code>public</code> Returns <code>{ iss: string; aud: string; leeway: number; ttlSeconds: number; }</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:65</code>     --- ##### `getProfile()`  Get JWT profile from environment Returns complete JwtProfile with detected algorithm   Type <code>function</code> Visibility <code>public</code> Returns <code>Partial &amp; { ttlSeconds: number; } Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:78</code>   **Parameters:**  - `role`: <code>\"producer\" | \"consumer\"</code>  --- ##### `getHSSecret()`    Type <code>function</code> Visibility <code>public</code> Returns <code>Uint8Array Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:93</code>     --- ##### `getPrivateJwkString()`    Type <code>function</code> Visibility <code>public</code> Returns <code>string</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:126</code>     --- ##### `getPublicJwkString()`    Type <code>function</code> Visibility <code>public</code> Returns <code>string</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:132</code>     --- ##### `getJwksServiceName()`    Type <code>function</code> Visibility <code>public</code> Returns <code>string</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:138</code>     --- ##### `getJwksUrl()`    Type <code>function</code> Visibility <code>public</code> Returns <code>string</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:144</code>     --- ##### `getJwksCacheTtl()`    Type <code>function</code> Visibility <code>public</code> Returns <code>number</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/config.ts:148</code>     --- ##### `sign()`  Sign a JWT token with HS512 or EdDSA algorithm   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Signed JWT token string Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/sign.ts:22</code>   **Parameters:**  - `payload`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload</code> \u2014 - Claims to include in the token (can include custom claims beyond standard JWT fields)- `opts`: <code>Partial&lt;{ iss: string; aud: string | string[]; ttlSeconds: number; }&gt;</code> \u2014 - Optional overrides for iss, aud, ttlSeconds  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__explicit/","title":"explicit \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__explicit/#component-information","title":"Component Information","text":"Component explicit Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description Explicit configuration API for JWT operations.  This module provides functions that accept explicit configuration objects instead of relying on environment variables or global state. Use this API when you need full control over configuration, especially in development environments or when working with multiple JWT configurations."},{"location":"architecture/chrislyons_dev_flarelette_jwt__explicit/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__explicit/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__explicit/#code-elements","title":"Code Elements","text":"9 code element(s)    #### Functions  ##### `signWithConfig()`  Sign a JWT token with explicit configuration   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Signed JWT token string Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit.ts:122</code>   **Parameters:**  - `payload`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload</code> \u2014 - Claims to include in the token- `config`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit\").SignConfig</code> \u2014 - Explicit JWT configuration- `overrides`: <code>Partial&lt;{ iss: string; aud: string | string[]; ttlSeconds: number; }&gt;</code> \u2014 - Optional per-call overrides for iss, aud, ttlSeconds **Examples:** <pre><code>\n</code></pre>  --- ##### `verifyWithConfig()`  Verify a JWT token with explicit configuration   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Payload if valid, null if invalid Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit.ts:181</code>   **Parameters:**  - `token`: <code>string</code> \u2014 - JWT token string to verify- `config`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit\").VerifyConfig</code> \u2014 - Explicit JWT configuration- `overrides`: <code>Partial&lt;{ iss: string; aud: string | string[]; leeway: number; }&gt;</code> \u2014 - Optional per-call overrides for iss, aud, leeway **Examples:** <pre><code>\n</code></pre>  --- ##### `createTokenWithConfig()`  Create a signed JWT token with explicit configuration  Higher-level wrapper around signWithConfig for convenience.   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Signed JWT token string Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit.ts:246</code>   **Parameters:**  - `claims`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload</code> \u2014 - Claims to include in the token- `config`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit\").SignConfig</code> \u2014 - Explicit JWT configuration- `overrides`: <code>Partial&lt;{ iss: string; aud: string | string[]; ttlSeconds: number; }&gt;</code> \u2014 - Optional per-call overrides  --- ##### `createDelegatedTokenWithConfig()`  Create a delegated JWT token with explicit configuration  Implements RFC 8693 actor claim pattern for service-to-service delegation.   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Signed JWT token string with delegation claim Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit.ts:283</code>   **Parameters:**  - `originalPayload`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload</code> \u2014 - The verified JWT payload from external auth- `actorService`: <code>string</code> \u2014 - Identifier of the service creating this delegated token- `config`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit\").SignConfig</code> \u2014 - Explicit JWT configuration- `overrides`: <code>Partial&lt;{ iss: string; aud: string | string[]; ttlSeconds: number; }&gt;</code> \u2014 - Optional per-call overrides **Examples:** <pre><code>\n</code></pre>  --- ##### `checkAuthWithConfig()`  Verify and authorize a JWT token with explicit configuration   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 AuthUser if valid and authorized, null otherwise Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit.ts:369</code>   **Parameters:**  - `token`: <code>string</code> \u2014 - JWT token string to verify- `config`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit\").VerifyConfig</code> \u2014 - Explicit JWT configuration- `authzOpts`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit\").AuthzOptsWithConfig</code> \u2014 - Authorization policy requirements- `verifyOverrides`: <code>Partial&lt;{ iss: string; aud: string | string[]; leeway: number; }&gt;</code> \u2014 - Optional per-call verification overrides **Examples:** <pre><code>\n</code></pre>  --- ##### `createHS512Config()`  Helper function to create HS512 config from base64url-encoded secret   Type <code>function</code> Visibility <code>public</code> Returns <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit\").HS512Config</code> \u2014 HS512 configuration Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit.ts:423</code>   **Parameters:**  - `secret`: <code>string</code> \u2014 - Base64url-encoded secret string- `baseConfig`: <code>Omit &amp; Partial&gt; \u2014 - Base JWT configuration  --- ##### `createEdDSASignConfig()`  Helper function to create EdDSA sign config from JWK   Type <code>function</code> Visibility <code>public</code> Returns <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit\").EdDSASignConfig</code> \u2014 EdDSA sign configuration Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit.ts:452</code>   **Parameters:**  - `privateJwk`: <code>any</code> \u2014 - Private JWK object or JSON string- `baseConfig`: <code>Omit &amp; Partial&gt; \u2014 - Base JWT configuration- `kid`: <code>string</code> \u2014 - Optional key ID  --- ##### `createEdDSAVerifyConfig()`  Helper function to create EdDSA verify config from JWK   Type <code>function</code> Visibility <code>public</code> Returns <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit\").EdDSAVerifyConfig</code> \u2014 EdDSA verify configuration Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit.ts:474</code>   **Parameters:**  - `publicJwk`: <code>any</code> \u2014 - Public JWK object or JSON string- `baseConfig`: <code>Omit &amp; Partial&gt; \u2014 - Base JWT configuration  --- ##### `createJWKSUrlVerifyConfig()`  Helper function to create HTTP JWKS URL verification config  Enables testing without environment variables by providing explicit configuration   Type <code>function</code> Visibility <code>public</code> Returns <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit\").JWKSUrlVerifyConfig</code> \u2014 JWKS URL verification configuration Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/explicit.ts:511</code>   **Parameters:**  - `jwksUrl`: <code>string</code> \u2014 - HTTP(S) URL to JWKS endpoint- `baseConfig`: <code>Omit &amp; Partial&gt; \u2014 - Base JWT configuration- `cacheTtl`: <code>number</code> \u2014 - Optional cache TTL in seconds (default: 300) **Examples:** <pre><code>\n</code></pre>  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__jwks/","title":"jwks \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__jwks/#component-information","title":"Component Information","text":"Component jwks Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description JSON Web Key Set (JWKS) utilities.  This module provides functions to fetch and manage JWKS, including caching and key lookup by key ID (kid). It supports integration with external JWKS services."},{"location":"architecture/chrislyons_dev_flarelette_jwt__jwks/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__jwks/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__jwks/#code-elements","title":"Code Elements","text":"7 code element(s)    #### Functions  ##### `clearJwksCache()`  Clear the JWKS cache (for testing purposes)   Type <code>function</code> Visibility <code>public</code> Returns <code>void</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/jwks.ts:49</code>     --- ##### `clearHttpJwksCache()`  Clear the HTTP JWKS cache (for testing purposes)   Type <code>function</code> Visibility <code>public</code> Returns <code>void</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/jwks.ts:57</code>     --- ##### `fetchJwksFromService()`  Fetch JWKS from a service binding Implements 5-minute caching to reduce load on JWKS service   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/jwks.ts:65</code>   **Parameters:**  - `service`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").Fetcher</code>  --- ##### `validateJwksUrl()`  Validate JWKS URL for security requirements  Requirements: - Must be valid URL format - Must use HTTPS (except localhost/127.0.0.1/[::1] for testing)   Type <code>function</code> Visibility <code>private</code> Returns <code>URL</code> \u2014 Parsed URL object Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/jwks.ts:103</code>   **Parameters:**  - `url`: <code>string</code> \u2014 - JWKS URL to validate  --- ##### `fetchJwksFromUrl()`  Fetch JWKS from HTTP URL with caching  Implements configurable TTL caching (default 5 minutes) Security: HTTPS-only (except localhost), 5-second timeout, 100KB size limit   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Array of JWK objects Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/jwks.ts:138</code>   **Parameters:**  - `url`: <code>string</code> \u2014 - HTTP(S) URL to JWKS endpoint- `ttlSeconds`: <code>number</code> \u2014 - Cache TTL in seconds (default: 300)  --- ##### `getKeyFromJwks()`  Find and import a specific key from JWKS by kid  Supports both EdDSA (Ed25519) and RSA (RS256/RS384/RS512) keys Algorithm is auto-detected from key type (kty) and curve (crv)   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise | CryptoKey&gt; \u2014 CryptoKey or Uint8Array suitable for jose verification Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/jwks.ts:209</code>   **Parameters:**  - `kid`: <code>string</code> \u2014 - Key ID from JWT header- `jwks`: <code>JWKWithKid[]</code> \u2014 - Array of JWK objects  --- ##### `allowedThumbprints()`  Get allowed thumbprints for key pinning (optional security measure)   Type <code>function</code> Visibility <code>public</code> Returns <code>Set Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/jwks.ts:242</code>     ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__main/","title":"main \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__main/#component-information","title":"Component Information","text":"Component main Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description Entry point for the flarelette-jwt library.  This module re-exports core functionalities, including signing, verification, utilities, and type definitions. It serves as the main interface for library consumers."},{"location":"architecture/chrislyons_dev_flarelette_jwt__main/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__main/#code-elements","title":"Code Elements","text":"<p>No code elements extracted for this component.</p> <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__types/","title":"types \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__types/#component-information","title":"Component Information","text":"Component types Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description Type definitions for JWT operations.  This module defines types for JWT headers, payloads, profiles, and related structures. It ensures type safety and consistency across the library."},{"location":"architecture/chrislyons_dev_flarelette_jwt__types/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__types/#code-elements","title":"Code Elements","text":"<p>No code elements extracted for this component.</p> <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__util/","title":"util \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__util/#component-information","title":"Component Information","text":"Component util Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description High-level JWT utilities for creating, delegating, verifying, and authorizing JWT tokens | Key generation utility for EdDSA keys.  This script generates EdDSA key pairs and exports them in JWK format. It is designed to be executed as a standalone Node.js script. | Secret generation and validation utilities.  This module provides functions to generate secure secrets and validate base64url-encoded secrets. It ensures compatibility with JWT signing requirements. | Utility functions for JWT operations.  This module provides helper functions for parsing JWTs, checking expiration, and mapping OAuth scopes. It is designed to support core JWT functionalities."},{"location":"architecture/chrislyons_dev_flarelette_jwt__util/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__util/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__util/#code-elements","title":"Code Elements","text":"10 code element(s)    #### Functions  ##### `createToken()`  Create a signed JWT token with optional claims   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Signed JWT token string Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high.ts:18</code>   **Parameters:**  - `claims`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload</code> \u2014 - Claims to include in the token (can include custom claims beyond standard JWT fields)- `opts`: <code>Partial&lt;{ iss: string; aud: string | string[]; ttlSeconds: number; }&gt;</code> \u2014 - Optional overrides for iss, aud, ttlSeconds  --- ##### `createDelegatedToken()`  Create a delegated JWT token following RFC 8693 actor claim pattern  Mints a new short-lived token for use within service boundaries where a service acts on behalf of the original end user. This implements zero-trust delegation: - Preserves original user identity (sub) and permissions - Identifies the acting service via 'act' claim - Prevents permission escalation by copying original permissions  Pattern: \"I'm  doing work on behalf of \"   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Signed JWT token string with delegation claim Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high.ts:61</code>   **Parameters:**  - `originalPayload`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload</code> \u2014 - The verified JWT payload from external auth (e.g., Auth0)- `actorService`: <code>string</code> \u2014 - Identifier of the service creating this delegated token- `opts`: <code>Partial&lt;{ iss: string; aud: string | string[]; ttlSeconds: number; }&gt;</code> \u2014 - Optional overrides for iss, aud, ttlSeconds **Examples:** <pre><code>\n</code></pre>  --- ##### `checkAuth()`  Verify and authorize a JWT token with policy enforcement   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 AuthUser if valid and authorized, null otherwise Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high.ts:142</code>   **Parameters:**  - `token`: <code>string</code> \u2014 - JWT token string to verify- `opts`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high\").AuthzOpts</code> \u2014 - Authorization options including verification and policy requirements  --- ##### `policy()`  Fluent builder for creating authorization policies   Type <code>function</code> Visibility <code>public</code> Returns <code>{ base(b: Partial&lt;{ iss: string; aud: string | string[]; leeway: number; }&gt;): any; needAll(...perms: string[]): any; needAny(...perms: string[]): any; rolesAll(...roles: string[]): any; rolesAny(...roles: string[]): any; where(fn: (payload: import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload) =&gt; boolean): any; build(): import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high\").AuthzOpts; }</code> \u2014 Policy builder with chainable methods Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/high.ts:177</code>     --- ##### `main()`    Type <code>function</code> Visibility <code>private</code> Async Yes Returns <code>Promise Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/keygen.ts:15</code>     --- ##### `generateSecret()`    Type <code>function</code> Visibility <code>public</code> Returns <code>string</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/secret.ts:13</code>   **Parameters:**  - `lengthBytes`: <code>number</code>  --- ##### `isValidBase64UrlSecret()`    Type <code>function</code> Visibility <code>public</code> Returns <code>boolean</code> Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/secret.ts:25</code>   **Parameters:**  - `s`: <code>string</code>- `minBytes`: <code>number</code>  --- ##### `parse()`  Parse a JWT token into header and payload without verification   Type <code>function</code> Visibility <code>public</code> Returns <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").ParsedJwt</code> \u2014 Parsed header and payload Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/util.ts:19</code>   **Parameters:**  - `token`: <code>string</code> \u2014 - JWT token string  --- ##### `isExpiringSoon()`  Check if JWT payload will expire within specified seconds   Type <code>function</code> Visibility <code>public</code> Returns <code>boolean</code> \u2014 True if token expires within the threshold Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/util.ts:35</code>   **Parameters:**  - `payload`: <code>import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").JwtPayload</code> \u2014 - JWT payload with 'exp' claim- `seconds`: <code>number</code> \u2014 - Number of seconds threshold  --- ##### `mapScopesToPermissions()`  Map OAuth scopes to permission strings   Type <code>function</code> Visibility <code>public</code> Returns <code>string[]</code> \u2014 List of permission strings (currently identity mapping) Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/util.ts:47</code>   **Parameters:**  - `scopes`: <code>string[]</code> \u2014 - List of OAuth scope strings  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__verify/","title":"verify \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/chrislyons_dev_flarelette_jwt__verify/#component-information","title":"Component Information","text":"Component verify Container @chrislyons-dev/flarelette-jwt Type <code>module</code> Description JWT verification utilities.  This module provides functions to verify JWT tokens using either HS512 or EdDSA algorithms. It supports integration with JWKS services and thumbprint pinning."},{"location":"architecture/chrislyons_dev_flarelette_jwt__verify/#code-structure","title":"Code Structure","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__verify/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/chrislyons_dev_flarelette_jwt__verify/#code-elements","title":"Code Elements","text":"2 code element(s)    #### Functions  ##### `resolveVerificationKey()`  Resolve verification key from configured sources  Implements key resolution strategy pattern: - Strategy 1: HS512 shared secret - Strategy 2: Inline public JWK - Strategy 3: Service binding JWKS - Strategy 4: HTTP JWKS URL   Type <code>function</code> Visibility <code>private</code> Async Yes Returns <code>Promise&lt;{ key: Uint8Array | CryptoKey; algorithms: string[]; }&gt; \u2014 Key and allowed algorithms Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/verify.ts:47</code>   **Parameters:**  - `token`: <code>string</code> \u2014 - JWT token string- `opts`: <code>Partial&lt;{ jwksService: import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").Fetcher; jwksUrl: string; jwksCacheTtl: number; }&gt;</code> \u2014 - Verification options  --- ##### `verify()`  Verify a JWT token with HS512, EdDSA, or RSA algorithms  Supports multiple key resolution strategies with automatic algorithm detection   Type <code>function</code> Visibility <code>public</code> Async Yes Returns <code>Promise \u2014 Decoded payload if valid, null otherwise Location <code>C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/verify.ts:132</code>   **Parameters:**  - `token`: <code>string</code> \u2014 - JWT token string to verify- `opts`: <code>Partial&lt;{ iss: string; aud: string | string[]; leeway: number; jwksService: import(\"C:/Users/chris/git/flarelette-jwt-kit/packages/flarelette-jwt-ts/src/types\").Fetcher; jwksUrl: string; jwksCacheTtl: number; }&gt;</code> \u2014 - Optional overrides for iss, aud, leeway, jwksService, jwksUrl, jwksCacheTtl  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/flarelette_jwt/","title":"flarelette-jwt","text":"<p>\u2190 Back to System Overview</p>"},{"location":"architecture/flarelette_jwt/#container-context","title":"Container Context","text":""},{"location":"architecture/flarelette_jwt/#container-information","title":"Container Information","text":"Name flarelette-jwt Type <code>Service</code> Description Environment-driven JWT authentication for Cloudflare Workers Python with secret-name indirection Tags <code>Auto-generated</code>"},{"location":"architecture/flarelette_jwt/#components","title":"Components","text":""},{"location":"architecture/flarelette_jwt/#component-view","title":"Component View","text":""},{"location":"architecture/flarelette_jwt/#component-details","title":"Component Details","text":"Component Type Description Code adapters <code>module</code> Adapters for Cloudflare Workers Environment  This module provides utilities to adapt Cloudflare Workers environment variables for use with the Flarelette JWT library. View \u2192 util <code>module</code> Environment Configuration for JWT Operations  This module provides functions to read environment variables and derive JWT-related configurations. It supports both symmetric (HS512) and asymmetric (EdDSA) algorithms. View \u2192 explicit <code>module</code> Explicit Configuration API for JWT Operations  This module provides functions that accept explicit configuration objects instead of relying on environment variables or global state. Use this API when you need full control over configuration, especially in development environments or when working with multiple JWT configurations. View \u2192 flarelette_jwt <code>module</code> Component derived from directory: flarelette_jwt View \u2192 <sub>\u2190 Back to System Overview | Generated with Archlette</sub>"},{"location":"architecture/flarelette_jwt__adapters/","title":"adapters \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/flarelette_jwt__adapters/#component-information","title":"Component Information","text":"Component adapters Container flarelette-jwt Type <code>module</code> Description Adapters for Cloudflare Workers Environment  This module provides utilities to adapt Cloudflare Workers environment variables for use with the Flarelette JWT library."},{"location":"architecture/flarelette_jwt__adapters/#code-structure","title":"Code Structure","text":""},{"location":"architecture/flarelette_jwt__adapters/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/flarelette_jwt__adapters/#code-elements","title":"Code Elements","text":"1 code element(s)    #### Functions  ##### `apply_env_bindings()`  Copy a Cloudflare Worker `env` mapping into os.environ so the kit can read it.   Type <code>function</code> Visibility <code></code> Returns <code>None</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\adapters.py:15</code>   **Parameters:**  - `env`: <code>Mapping[str, str]</code>  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/flarelette_jwt__explicit/","title":"explicit \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/flarelette_jwt__explicit/#component-information","title":"Component Information","text":"Component explicit Container flarelette-jwt Type <code>module</code> Description Explicit Configuration API for JWT Operations  This module provides functions that accept explicit configuration objects instead of relying on environment variables or global state. Use this API when you need full control over configuration, especially in development environments or when working with multiple JWT configurations."},{"location":"architecture/flarelette_jwt__explicit/#code-structure","title":"Code Structure","text":""},{"location":"architecture/flarelette_jwt__explicit/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/flarelette_jwt__explicit/#code-elements","title":"Code Elements","text":"18 code element(s)   #### Classes  ##### `BaseJwtConfig`  Base JWT configuration shared by HS512 and EdDSA modes.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:25</code>    --- ##### `HS512Config`  HS512 (HMAC-SHA512) symmetric configuration.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:41</code>    --- ##### `EdDSASignConfig`  EdDSA (Ed25519) asymmetric configuration for signing.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:55</code>    --- ##### `EdDSAVerifyConfig`  EdDSA (Ed25519) asymmetric configuration for verification.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:71</code>    --- ##### `AuthzOptsWithConfig`  Authorization options for check_auth_with_config.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:399</code>    --- ##### `AuthUser`  Authenticated user information.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:417</code>    ---  #### Functions  ##### `_b64url()`  Encode bytes to base64url without padding.   Type <code>function</code> Visibility <code></code> Returns <code>str</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:90</code>   **Parameters:**  - `b`: <code>bytes</code>  --- ##### `_b64url_decode()`  Decode base64url string (with or without padding).   Type <code>function</code> Visibility <code></code> Returns <code>bytes</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:95</code>   **Parameters:**  - `s`: <code>str</code>  --- ##### `sign_with_config()`  Sign a JWT token with explicit configuration.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>str</code> \u2014 Signed JWT token string Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:100</code>   **Parameters:**  - `payload`: <code>JwtPayload</code> \u2014 Claims to include in the token- `config`: <code>SignConfig</code> \u2014 Explicit JWT configuration **Examples:** <pre><code>\n</code></pre>  --- ##### `verify_with_config()`  Verify a JWT token with explicit configuration.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>JwtPayload | None</code> \u2014 Payload if valid, None if invalid Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:187</code>   **Parameters:**  - `token`: <code>str</code> \u2014 JWT token string to verify- `config`: <code>VerifyConfig</code> \u2014 Explicit JWT configuration **Examples:** <pre><code>\n</code></pre>  --- ##### `create_token_with_config()`  Create a signed JWT token with explicit configuration.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>str</code> \u2014 Signed JWT token string Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:296</code>   **Parameters:**  - `claims`: <code>JwtPayload</code> \u2014 Claims to include in the token- `config`: <code>SignConfig</code> \u2014 Explicit JWT configuration  --- ##### `create_delegated_token_with_config()`  Create a delegated JWT token with explicit configuration.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>str</code> \u2014 Signed JWT token string with delegation claim Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:323</code>   **Parameters:**  - `original_payload`: <code>JwtPayload</code> \u2014 The verified JWT payload from external auth- `actor_service`: <code>str</code> \u2014 Identifier of the service creating this delegated token- `config`: <code>SignConfig</code> \u2014 Explicit JWT configuration **Examples:** <pre><code>\n</code></pre>  --- ##### `check_auth_with_config()`  Verify and authorize a JWT token with explicit configuration.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>AuthUser | None</code> \u2014 AuthUser if valid and authorized, None otherwise Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:437</code>   **Parameters:**  - `token`: <code>str</code> \u2014 JWT token string to verify- `config`: <code>VerifyConfig</code> \u2014 Explicit JWT configuration- `authz_opts`: <code>AuthzOptsWithConfig | None</code> \u2014 Authorization policy requirements **Examples:** <pre><code>\n</code></pre>  --- ##### `create_hs512_config()`  Helper function to create HS512 config from base64url-encoded secret.   Type <code>function</code> Visibility <code></code> Returns <code>HS512Config</code> \u2014 HS512Config Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:519</code>   **Parameters:**  - `secret`: <code>str | bytes</code> \u2014 Base64url-encoded secret string or raw bytes (minimum 32 bytes)  --- ##### `create_eddsa_sign_config()`  Helper function to create EdDSA sign config from JWK.   Type <code>function</code> Visibility <code></code> Returns <code>EdDSASignConfig</code> \u2014 EdDSASignConfig Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:561</code>   **Parameters:**  - `private_jwk`: <code>dict[str, Any] | str</code> \u2014 Private JWK dictionary or JSON string  --- ##### `create_eddsa_verify_config()`  Helper function to create EdDSA verify config from JWK.   Type <code>function</code> Visibility <code></code> Returns <code>EdDSAVerifyConfig</code> \u2014 EdDSAVerifyConfig Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\explicit.py:596</code>   **Parameters:**  - `public_jwk`: <code>dict[str, Any] | str</code> \u2014 Public JWK dictionary or JSON string  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/flarelette_jwt__flarelette_jwt/","title":"flarelette_jwt \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/flarelette_jwt__flarelette_jwt/#component-information","title":"Component Information","text":"Component flarelette_jwt Container flarelette-jwt Type <code>module</code> Description Component derived from directory: flarelette_jwt"},{"location":"architecture/flarelette_jwt__flarelette_jwt/#code-structure","title":"Code Structure","text":""},{"location":"architecture/flarelette_jwt__flarelette_jwt/#code-elements","title":"Code Elements","text":"<p>No code elements extracted for this component.</p> <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"},{"location":"architecture/flarelette_jwt__util/","title":"util \u2014 Code View","text":"<p>\u2190 Back to Container | \u2190 Back to System</p>"},{"location":"architecture/flarelette_jwt__util/#component-information","title":"Component Information","text":"Component util Container flarelette-jwt Type <code>module</code> Description Environment Configuration for JWT Operations  This module provides functions to read environment variables and derive JWT-related configurations. It supports both symmetric (HS512) and asymmetric (EdDSA) algorithms."},{"location":"architecture/flarelette_jwt__util/#code-structure","title":"Code Structure","text":""},{"location":"architecture/flarelette_jwt__util/#class-diagram","title":"Class Diagram","text":""},{"location":"architecture/flarelette_jwt__util/#code-elements","title":"Code Elements","text":"46 code element(s)   #### Classes  ##### `JwtHeader`  JWT token header structure.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:35</code>    --- ##### `ActorClaim`  Actor claim for service delegation (RFC 8693).   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:49</code>    --- ##### `JwtPayload`  JWT token payload/claims structure.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:68</code>    --- ##### `JwtProfile`  JWT Profile structure matching flarelette-jwt.profile.schema.json.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:110</code>    --- ##### `JwtCommonConfig`  Common JWT configuration from environment variables.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:125</code>    --- ##### `AuthUser`  Authenticated user information returned by check_auth.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:24</code>    --- ##### `PolicyBuilder`  Builder interface for creating JWT authorization policies.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:40</code>    --- ##### `Builder`    Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:227</code>    --- ##### `ParsedJwt`  Parsed JWT token structure.   Type <code>class</code> Visibility <code></code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\util.py:19</code>    ---  #### Functions  ##### `mode()`  Detect JWT algorithm mode from environment variables based on role.   Type <code>function</code> Visibility <code></code> Returns <code>AlgType</code> \u2014 Either \"HS512\" or \"EdDSA\" Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:139</code>   **Parameters:**  - `role`: <code>str</code> \u2014 Either \"producer\" (signing) or \"consumer\" (verification)  --- ##### `common()`  Get common JWT configuration from environment.   Type <code>function</code> Visibility <code></code> Returns <code>JwtCommonConfig</code> \u2014 Configuration with iss, aud, leeway, ttl_seconds Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:169</code>     --- ##### `profile()`  Get JWT profile from environment.   Type <code>function</code> Visibility <code></code> Returns <code>dict[str, Any]</code> \u2014 dict containing alg, iss, aud, leeway_seconds, and ttl_seconds Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:183</code>   **Parameters:**  - `role`: <code>str</code> \u2014 Either \"producer\" (signing) or \"consumer\" (verification)  --- ##### `_get_indirect()`    Type <code>function</code> Visibility <code></code> Returns <code>str | None</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:206</code>   **Parameters:**  - `name_var`: <code>str</code>- `direct_var`: <code>str</code>  --- ##### `get_hs_secret_bytes()`    Type <code>function</code> Visibility <code></code> Returns <code>bytes</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:213</code>     --- ##### `get_public_jwk_string()`    Type <code>function</code> Visibility <code></code> Returns <code>str | None</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\env.py:228</code>     --- ##### `create_token()`  Create a signed JWT token with optional claims.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>str</code> \u2014 Signed JWT token string Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:58</code>   **Parameters:**  - `claims`: <code>JwtPayload</code> \u2014 Claims to include in the token (can include custom claims beyond standard JWT fields)  --- ##### `create_delegated_token()`  Create a delegated JWT token following RFC 8693 actor claim pattern.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>str</code> \u2014 Signed JWT token string with delegation claim  See Also:     - RFC 8693: OAuth 2.0 Token Exchange     - security.md: Service Delegation Pattern section Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:79</code>   **Parameters:**  - `original_payload`: <code>JwtPayload</code> \u2014 The verified JWT payload from external auth (e.g., Auth0)- `actor_service`: <code>str</code> \u2014 Identifier of the service creating this delegated token **Examples:** <pre><code>\n</code></pre>  --- ##### `check_auth()`  Verify and authorize a JWT token with policy enforcement.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>AuthUser | None</code> \u2014 AuthUser if valid and authorized, None otherwise Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:166</code>   **Parameters:**  - `token`: <code>str</code> \u2014 JWT token string to verify  --- ##### `policy()`  Fluent builder for creating authorization policies.   Type <code>function</code> Visibility <code></code> Returns <code>PolicyBuilder</code> \u2014 PolicyBuilder with chainable methods Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\high.py:219</code>     --- ##### `generate_secret()`    Type <code>function</code> Visibility <code></code> Returns <code>str</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\secret.py:18</code>   **Parameters:**  - `length_bytes`: <code>int</code>  --- ##### `is_valid_base64url_secret()`    Type <code>function</code> Visibility <code></code> Returns <code>bool</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\secret.py:23</code>   **Parameters:**  - `secret`: <code>str</code>- `min_bytes`: <code>int</code>  --- ##### `main()`    Type <code>function</code> Visibility <code></code> Returns <code>int</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\secret.py:32</code>   **Parameters:**  - `argv`: <code>list[str] | None</code>  --- ##### `_b64url()`    Type <code>function</code> Visibility <code></code> Returns <code>str</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\sign.py:21</code>   **Parameters:**  - `b`: <code>bytes</code>  --- ##### `sign()`  Sign a JWT token with HS512 or EdDSA algorithm.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>str</code> \u2014 Signed JWT token string Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\sign.py:25</code>   **Parameters:**  - `payload`: <code>JwtPayload</code> \u2014 Claims to include in the token (can include custom claims beyond standard JWT fields)  --- ##### `parse()`  Parse a JWT token into header and payload without verification.   Type <code>function</code> Visibility <code></code> Returns <code>ParsedJwt</code> \u2014 Dictionary with 'header' and 'payload' keys Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\util.py:31</code>   **Parameters:**  - `token`: <code>str</code> \u2014 JWT token string  --- ##### `is_expiring_soon()`  Check if JWT payload will expire within specified seconds.   Type <code>function</code> Visibility <code></code> Returns <code>bool</code> \u2014 True if token expires within the threshold Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\util.py:49</code>   **Parameters:**  - `payload`: <code>JwtPayload</code> \u2014 JWT payload with 'exp' claim- `seconds`: <code>int</code> \u2014 Number of seconds threshold  --- ##### `map_scopes_to_permissions()`  Map OAuth scopes to permission strings.   Type <code>function</code> Visibility <code></code> Returns <code>list[str]</code> \u2014 List of permission strings (currently identity mapping) Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\util.py:63</code>   **Parameters:**  - `scopes`: <code>list[str]</code> \u2014 List of OAuth scope strings  --- ##### `_b64url_decode()`    Type <code>function</code> Visibility <code></code> Returns <code>bytes</code> Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\verify.py:29</code>   **Parameters:**  - `s`: <code>str</code>  --- ##### `verify()`  Verify a JWT token with HS512 or EdDSA algorithm.   Type <code>function</code> Visibility <code></code> Async Yes Returns <code>JwtPayload | None</code> \u2014 Decoded payload if valid, None otherwise Location <code>C:\\Users\\chris\\git\\flarelette-jwt-kit\\packages\\flarelette-jwt-py\\flarelette_jwt\\verify.py:33</code>   **Parameters:**  - `token`: <code>str</code> \u2014 JWT token string to verify  ---   <sub>\u2190 Back to Container | \u2190 Back to System | Generated with Archlette</sub>"}]}